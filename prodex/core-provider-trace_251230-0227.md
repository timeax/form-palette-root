# Index  L8-L73 

> Note for LLMs: `Lx-Ly` ranges refer to lines in this Prodex trace file, not the original source files.

*Generated by [Prodex](https://github.com/emxhive/prodex#readme)*

Included Source Files: 66
- [packages/form-palette/src/adapters/axios.ts](#1)  L76-L182
- [packages/form-palette/src/adapters/index.ts](#2)  L183-L290
- [packages/form-palette/src/adapters/inertia.ts](#3)  L291-L475
- [packages/form-palette/src/core/adapter-registry.ts](#4)  L476-L570
- [packages/form-palette/src/core/bound/bind-host.ts](#5)  L571-L593
- [packages/form-palette/src/core/bound/observe-bound-field.ts](#6)  L594-L774
- [packages/form-palette/src/core/bound/wait-for-bound-field.ts](#7)  L775-L840
- [packages/form-palette/src/core/context.ts](#8)  L841-L872
- [packages/form-palette/src/core/core-provider.tsx](#9)  L873-L1780
- [packages/form-palette/src/core/core-root.tsx](#10)  L1781-L1861
- [packages/form-palette/src/core/core-shell.tsx](#11)  L1862-L1992
- [packages/form-palette/src/core/errors/error-strip.tsx](#12)  L1993-L2117
- [packages/form-palette/src/core/errors/index.ts](#13)  L2118-L2129
- [packages/form-palette/src/core/errors/map-error-bag.ts](#14)  L2130-L2189
- [packages/form-palette/src/core/errors/map-zod.ts](#15)  L2190-L2237
- [packages/form-palette/src/core/hooks/use-button.ts](#16)  L2238-L2466
- [packages/form-palette/src/core/hooks/use-core-context.ts](#17)  L2467-L2495
- [packages/form-palette/src/core/hooks/use-core.ts](#18)  L2496-L2517
- [packages/form-palette/src/core/hooks/use-field.ts](#19)  L2518-L3041
- [packages/form-palette/src/core/hooks/use-optional-field.ts](#20)  L3042-L3242
- [packages/form-palette/src/core/index.ts](#21)  L3243-L3263
- [packages/form-palette/src/core/registry/binder-registry.ts](#22)  L3264-L3354
- [packages/form-palette/src/core/registry/field-registry.ts](#23)  L3355-L3686
- [packages/form-palette/src/index.ts](#24)  L3687-L3742
- [packages/form-palette/src/input/index.ts](#25)  L3743-L3755
- [packages/form-palette/src/input/input-field.tsx](#26)  L3756-L4665
- [packages/form-palette/src/input/input-layout-graph.ts](#27)  L4666-L4898
- [packages/form-palette/src/input/input-props.ts](#28)  L4899-L5131
- [packages/form-palette/src/lib/json-editor/filters.ts](#29)  L5132-L5258
- [packages/form-palette/src/lib/json-editor/glob.ts](#30)  L5259-L5437
- [packages/form-palette/src/lib/json-editor/layout.ts](#31)  L5438-L5587
- [packages/form-palette/src/lib/json-editor/routes.ts](#32)  L5588-L5730
- [packages/form-palette/src/lib/json-editor/types.ts](#33)  L5731-L5804
- [packages/form-palette/src/lib/json-editor/utils.ts](#34)  L5805-L5868
- [packages/form-palette/src/lib/register-global.ts](#35)  L5869-L5942
- [packages/form-palette/src/lib/utils.ts](#36)  L5943-L5962
- [packages/form-palette/src/schema/adapter.ts](#37)  L5963-L6256
- [packages/form-palette/src/schema/core.ts](#38)  L6257-L6697
- [packages/form-palette/src/schema/field.ts](#39)  L6698-L6938
- [packages/form-palette/src/schema/input-field.ts](#40)  L6939-L7207
- [packages/form-palette/src/schema/variant.ts](#41)  L7208-L7439
- [packages/form-palette/src/variants/core/checkbox.tsx](#42)  L7440-L7502
- [packages/form-palette/src/variants/core/chips.tsx](#43)  L7503-L7533
- [packages/form-palette/src/variants/core/color.tsx](#44)  L7534-L7558
- [packages/form-palette/src/variants/core/custom.tsx](#45)  L7559-L7585
- [packages/form-palette/src/variants/core/date.tsx](#46)  L7586-L7619
- [packages/form-palette/src/variants/core/editor.ts](#47)  L7620-L7640
- [packages/form-palette/src/variants/core/file.tsx](#48)  L7641-L7658
- [packages/form-palette/src/variants/core/json-editor.tsx](#49)  L7659-L7747
- [packages/form-palette/src/variants/core/keyvalue.tsx](#50)  L7748-L7768
- [packages/form-palette/src/variants/core/lister.tsx](#51)  L7769-L7808
- [packages/form-palette/src/variants/core/multiselect.tsx](#52)  L7809-L7845
- [packages/form-palette/src/variants/core/number.tsx](#53)  L7846-L7969
- [packages/form-palette/src/variants/core/password.tsx](#54)  L7970-L8013
- [packages/form-palette/src/variants/core/phone.tsx](#55)  L8014-L8038
- [packages/form-palette/src/variants/core/radio.tsx](#56)  L8039-L8085
- [packages/form-palette/src/variants/core/select.tsx](#57)  L8086-L8109
- [packages/form-palette/src/variants/core/slider.tsx](#58)  L8110-L8173
- [packages/form-palette/src/variants/core/text.tsx](#59)  L8174-L8296
- [packages/form-palette/src/variants/core/textarea.tsx](#60)  L8297-L8327
- [packages/form-palette/src/variants/core/toggle-group.tsx](#61)  L8328-L8352
- [packages/form-palette/src/variants/core/toggle.tsx](#62)  L8353-L8411
- [packages/form-palette/src/variants/core/treeselect.tsx](#63)  L8412-L8431
- [packages/form-palette/src/variants/index.ts](#64)  L8432-L8523
- [packages/form-palette/src/variants/registry.ts](#65)  L8524-L8570
- [packages/form-palette/src/variants/shared.ts](#66)  L8571-L8708

---
---
#### 1


` File: packages/form-palette/src/adapters/axios.ts`  [↑ Back to top](#index)

```ts
// src/adapters/axios.ts
import axios, {
    type AxiosError,
    type AxiosRequestConfig,
    type AxiosResponse,
} from "axios";
import type {
    NamedAdapterFactory,
    AdapterResult,
    AdapterOk,
    AdapterError,
} from "@/schema/adapter";

// (Adapters augmentation is above in the same file)

export const createAxiosAdapter: NamedAdapterFactory<"axios"> = (
    config
): AdapterResult<AdapterOk<"axios">> => {
    const { method, url, data, callbacks, errorBag } = config;

    function buildRequestConfig(options?: unknown): AxiosRequestConfig<any> {
        return {
            method,
            url,
            data,
            ...(options as AxiosRequestConfig<any> | undefined),
            headers: {
                ...((options as AxiosRequestConfig)?.headers ?? {}),
                "X-Inertia-Error-Bag": errorBag,
            },
        };
    }

    function submit(options?: unknown): void {
        let finished = false;
        const finish = () => {
            if (finished) return;
            finished = true;
            callbacks?.onFinish?.();
        };

        axios
            .request(buildRequestConfig(options))
            .then((response: AxiosResponse<unknown>) => {
                callbacks?.onSuccess?.(response as AdapterOk<"axios">);
            })
            .catch((error: AxiosError | unknown) => {
                const axiosErr = error as AxiosError<unknown>;
                // Prefer response.data; this is usually where Laravel
                // puts `{ errors: {...} }` for validation failures.
                const payload = axiosErr?.response?.data ?? error;

                callbacks?.onError?.(payload as AdapterError<"axios">);
            })
            .finally(() => {
                finish();
            });
    }

    function send(options?: unknown): Promise<AdapterOk<"axios">> {
        return new Promise((resolve, reject) => {
            let finished = false;
            const finish = () => {
                if (finished) return;
                finished = true;
                callbacks?.onFinish?.();
            };

            axios
                .request(buildRequestConfig(options))
                .then((response: AxiosResponse<unknown>) => {
                    callbacks?.onSuccess?.(response as AdapterOk<"axios">);
                    resolve(response as AdapterOk<"axios">);
                })
                .catch((error: AxiosError | unknown) => {
                    const axiosErr = error as AxiosError<unknown>;
                    const payload = axiosErr?.response?.data ?? error;

                    callbacks?.onError?.(payload as AdapterError<"axios">);
                    reject(payload as AdapterError<"axios">);
                })
                .finally(() => {
                    finish();
                });
        });
    }

    function run(options?: unknown): Promise<AdapterOk<"axios">> {
        // "Smart" default: same as send(), so you can `await run()`.
        return send(options);
    }

    return {
        submit,
        send,
        run,
    };
};
```

---
#### 2


` File: packages/form-palette/src/adapters/index.ts`  [↑ Back to top](#index)

```ts
// src/adapters/index.ts

import axios from "axios";
import { registerAdapter } from "@/core/adapter-registry";
import type { AdapterKey } from "@/schema/adapter";

import { createAxiosAdapter } from "./axios";
import { createInertiaAdapter } from "./inertia";

// Re-export core adapter types + helpers so hosts can import from a single place.
export * from "@/schema/adapter";
export * from "@/core/adapter-registry";

// Re-export the concrete factories for hosts that want manual wiring.
export { createAxiosAdapter, createInertiaAdapter };

/**
 * Register the Axios adapter under the "axios" key.
 *
 * This performs a basic runtime check to make sure Axios is present.
 * If Axios isn't available or doesn't look like a proper Axios instance,
 * an error is thrown.
 */
export function registerAxiosAdapter(): void {
    // Basic sanity check – if this fails, something is wrong with the axios import.
    if (!axios || typeof axios.request !== "function") {
        throw new Error(
            "[form-palette] Axios does not appear to be available. " +
                "Make sure 'axios' is installed and resolvable before calling registerAxiosAdapter()."
        );
    }

    registerAdapter<"axios">("axios", createAxiosAdapter);
}

/**
 * Register the Inertia adapter under the "inertia" key.
 *
 * This explicitly tests that '@inertiajs/react' can be imported and that
 * it exposes a router with a .visit() method. If not, an error is thrown.
 *
 * Note:
 * - This function is async because it uses dynamic import.
 * - Call it at bootstrap time and await it:
 *
 *     await registerInertiaAdapter();
 */
export async function registerInertiaAdapter(): Promise<void> {
    try {
        const mod: any = await import("@inertiajs/react");
        const router = mod?.router ?? mod?.Inertia;

        if (!router || typeof router.visit !== "function") {
            throw new Error(
                "[form-palette] '@inertiajs/react' was imported, " +
                    "but no router with a .visit() method was found."
            );
        }
    } catch (error) {
        throw new Error(
            "[form-palette] Failed to import '@inertiajs/react'. " +
                "Cannot register the 'inertia' adapter. " +
                "Make sure '@inertiajs/react' is installed and resolvable."
        );
    }

    registerAdapter<"inertia">("inertia", createInertiaAdapter);
}

/**
 * Optional helper: convenience registration for known adapter keys.
 *
 * This is purely ergonomic; you can also call registerAxiosAdapter /
 * registerInertiaAdapter directly.
 */
export async function registerKnownAdapter(key: AdapterKey): Promise<void> {
    switch (key) {
        case "axios":
            registerAxiosAdapter();
            return;
        case "inertia":
            await registerInertiaAdapter();
            return;
        default:
            // For now, we only special-case axios/inertia here.
            // Other adapters can be registered by calling registerAdapter() directly.
            throw new Error(
                `[form-palette] registerKnownAdapter: adapter "${key}" is not handled here.`
            );
    }
}

/**
 * Convenience helper: register all known adapters.
 **/
export function registerAllAdapters(): void {
    registerAxiosAdapter();
    registerInertiaAdapter();
}
```

---
#### 3


` File: packages/form-palette/src/adapters/inertia.ts`  [↑ Back to top](#index)

```ts
import { Page, VisitOptions } from "@inertiajs/core";
// src/adapters/inertia.ts
import type {
    AdapterError,
    AdapterOk,
    AdapterResult,
    NamedAdapterConfig,
    NamedAdapterFactory,
} from "@/schema/adapter";

// (Adapters augmentation is above in the same file)

/**
 * Lazy-load the Inertia router from '@inertiajs/react'.
 *
 * This keeps '@inertiajs/react' out of the main bundle until an
 * Inertia adapter is actually used.
 */
async function loadInertiaRouter() {
    const mod: any = await import("@inertiajs/react");
    const router = mod?.router ?? mod?.Inertia;

    if (!router || typeof router.visit !== "function") {
        throw new Error(
            "[form-palette] Inertia router not found in @inertiajs/react"
        );
    }

    return router as {
        visit: (url: string, options?: VisitOptions) => void;
    };
}

/**
 * Shape raw Inertia errors into something with `.errors`
 * so Form Palette's autoErr branch can pick them up.
 */
function normalizeInertiaError(
    raw: unknown
): { errors: Record<string, string | string[]> } | unknown {
    if (
        raw &&
        typeof raw === "object" &&
        "errors" in (raw as any) &&
        typeof (raw as any).errors === "object"
    ) {
        // Already in { errors: {...} } shape
        return raw as any;
    }

    if (raw && typeof raw === "object" && !("errors" in (raw as any))) {
        // Inertia usually passes the error bag directly to onError.
        return { errors: raw as Record<string, string | string[]> };
    }

    return raw;
}

export const createInertiaAdapter: NamedAdapterFactory<"inertia"> = (
    config: NamedAdapterConfig<"inertia">
): AdapterResult<AdapterOk<"inertia">> => {
    const { method = "post", url, data, callbacks, errorBag } = config;

    const upperMethod = method.toUpperCase() as VisitOptions["method"];

    /**
     * Build VisitOptions with callbacks wired to AdapterCallbacks
     * + optional Promise resolve/reject.
     */
    function buildOptions(
        resolve?: (value: AdapterOk<"inertia">) => void,
        reject?: (reason: AdapterError<"inertia">) => void,
        extraOptions?: unknown
    ): VisitOptions {
        const user = (extraOptions as VisitOptions | undefined) ?? {};
        return {
            ...user, // user first
            errorBag,
            method: upperMethod as any,
            // @ts-ignore
            data,
            preserveState: "errors",
            onSuccess: (page: Page) => {
                user.onSuccess?.(page);

                callbacks?.onSuccess?.(page as AdapterOk<"inertia">);
                resolve?.(page as AdapterOk<"inertia">);
            },

            onError: (rawErrors: any) => {
                user.onError?.(rawErrors);

                const payload = normalizeInertiaError(rawErrors);

                callbacks?.onError?.(payload as AdapterError<"inertia">);
                reject?.(payload as AdapterError<"inertia">);
            },

            onFinish: (params) => {
                user.onFinish?.(params);
                callbacks?.onFinish?.();
            },
        };
    }

    function submit(options?: unknown): void {
        // Fire-and-forget; we still propagate callbacks and finish.
        (async () => {
            let finished = false;
            const finish = () => {
                if (finished) return;
                finished = true;
                callbacks?.onFinish?.();
            };

            try {
                const router = await loadInertiaRouter();
                const visitOptions = buildOptions(
                    undefined,
                    undefined,
                    options
                );
                // NOTE: buildOptions already wires onFinish, so we
                // call finish() only if the lazy import itself fails.
                router.visit(url, visitOptions);
            } catch (error) {
                const payload = normalizeInertiaError(error);
                callbacks?.onError?.(payload as AdapterError<"inertia">);
                finish();
            }
        })();
    }

    function send(options?: unknown): Promise<AdapterOk<"inertia">> {
        return new Promise(async (resolve, reject) => {
            let finished = false;
            const finish = () => {
                if (finished) return;
                finished = true;
                callbacks?.onFinish?.();
            };

            try {
                const router = await loadInertiaRouter();
                const visitOptions = buildOptions(
                    (page) => {
                        // buildOptions' onFinish will call onFinish();
                        resolve(page);
                    },
                    (err) => {
                        reject(err);
                    },
                    options
                );
                router.visit(url, visitOptions);
            } catch (error) {
                const payload = normalizeInertiaError(error);
                callbacks?.onError?.(payload as AdapterError<"inertia">);
                finish();
                reject(payload as AdapterError<"inertia">);
            }
        });
    }

    function run(options?: unknown): Promise<AdapterOk<"inertia">> {
        // Same as send(), so the core can safely `await adapter.run()`
        // if it wants, or ignore the promise if it doesn't care.
        return send(options);
    }

    return {
        submit,
        send,
        run,
    };
};
```

---
#### 4


` File: packages/form-palette/src/core/adapter-registry.ts`  [↑ Back to top](#index)

```ts
// src/core/adapter-registry.ts

import { AdapterKey, AdapterOk, NamedAdapterFactory } from "@/schema/adapter";

/**
 * Internal registry of adapter factories.
 *
 * We keep it simple: a plain JS object keyed by AdapterKey.
 */
const registry: Partial<
    Record<AdapterKey, NamedAdapterFactory<AdapterKey, any>>
> = {};

/**
 * Built-in 'local' adapter.
 *
 * Semantics:
 * - send(options?) resolves to `{ data: Body }`
 * - submit/run do nothing by default (no side effects)
 *
 * The core will typically call onSubmitted with the result of send().
 */
export const localAdapter: NamedAdapterFactory<"local", any> = (config) => {
    return {
        submit() {
            // no-op; core is responsible for calling onSubmitted
            // using send() if it chooses to.
        },
        async send() {
            const result: AdapterOk<"local"> = { data: config.data };

            if (config.callbacks?.onSuccess) {
                config.callbacks.onSuccess(result);
            }

            if (config.callbacks?.onFinish) {
                config.callbacks.onFinish();
            }

            return result;
        },
        run() {
            // By default, run behaves like submit (no-op),
            // but hosts can choose to always call send() instead.
            this.submit();
        },
    };
};

/**
 * Initialise registry with the built-in 'local' adapter.
 */
registry.local = localAdapter as NamedAdapterFactory<AdapterKey, any>;

/**
 * Register or override an adapter factory for a given key.
 *
 * Hosts can call this at bootstrap time, e.g.:
 *
 *   registerAdapter<'axios'>('axios', axiosAdapter);
 */
export function registerAdapter<K extends AdapterKey, Body = any>(
    key: K,
    factory: NamedAdapterFactory<K, Body>
): void {
    registry[key] = factory as NamedAdapterFactory<AdapterKey, any>;
}

/**
 * Lookup an adapter factory by key.
 *
 * If no adapter is found for the given key, this returns undefined.
 */
export function getAdapter<K extends AdapterKey>(
    key: K
): NamedAdapterFactory<K, any> | undefined {
    const factory = registry[key];
    return factory as NamedAdapterFactory<K, any> | undefined;
}

/**
 * Check whether an adapter is registered for the given key.
 */
export function hasAdapter(key: AdapterKey): boolean {
    return typeof registry[key] === "function";
}
```

---
#### 5


` File: packages/form-palette/src/core/bound/bind-host.ts`  [↑ Back to top](#index)

```ts
// src/core/bound/bind-host.ts (or inline in binder-registry.ts)
import type { Dict, CoreContext } from "@/schema/core";
import type { Field } from "@/schema/field";

/**
 * Minimal surface needed for bound helpers.
 *
 * CoreContext already satisfies this, and FieldRegistry can be made to
 * satisfy it as well (via getBind).
 */
export interface BindHost<V extends Dict = Dict> {
    getBind(id: string): Field | undefined;
    controlButton?(): void;
}
```

---
#### 6


` File: packages/form-palette/src/core/bound/observe-bound-field.ts`  [↑ Back to top](#index)

```ts
// src/core/bound/observe-bound-field.ts

import type { Dict } from "@/schema/core";
import type { Field } from "@/schema/field";
import type { BindHost } from "@/core/bound/bind-host";

/** Get the live bound field (if mounted and present). */
export function getBoundField<V extends Dict>(
    host: BindHost<V>,
    bindId: string
): Field | undefined {
    return host.getBind(bindId);
}

export function hasBoundField<V extends Dict>(
    host: BindHost<V>,
    bindId: string
): boolean {
    return !!getBoundField(host, bindId);
}

export function readBoundValue<T = unknown, V extends Dict = Dict>(
    host: BindHost<V>,
    bindId: string
): T | undefined {
    return getBoundField(host, bindId)?.value as T | undefined;
}

export function setBoundValue<T = unknown, V extends Dict = Dict>(
    host: BindHost<V>,
    bindId: string,
    value: T,
    variant: string = "util"
): boolean {
    const f = getBoundField(host, bindId);
    if (!f) return false;

    (f as any).value = value as unknown;

    // optional: dirty/enable logic if host supports it
    try {
        host.controlButton?.();
    } catch {
        // ignore
    }

    (f as any).onChange?.(value, undefined, variant);
    return true;
}

export function setBoundError<V extends Dict>(
    _host: BindHost<V>, // host not strictly needed here
    bindId: string,
    msg: string
): boolean {
    const f = _host.getBind(bindId);
    if (!f) return false;
    (f as any).error = msg ?? "";
    return true;
}

export function validateBoundField<V extends Dict>(
    host: BindHost<V>,
    bindId: string,
    report = true
): boolean {
    const f = getBoundField(host, bindId);
    if (!f) return false;
    return !!(f as any).validate?.(report);
}

/**
 * Observe a bound field for value/error + liveness.
 */
export function observeBoundField<T = unknown, V extends Dict = Dict>(
    host: BindHost<V>,
    bindId: string,
    handler: (evt: {
        exists: boolean;
        field?: Field;
        value?: T;
        error?: string;
    }) => void,
    pollMs = 300
): () => void {
    let current: Field | undefined = getBoundField(host, bindId);
    let restoreOnChange: Field["onChange"] | undefined;

    const fire = () => {
        if (!current) {
            handler({ exists: false });
            return;
        }

        handler({
            exists: true,
            field: current,
            value: (current as any).value as T,
            error: (current as any).error,
        });
    };

    const wire = () => {
        const f = getBoundField(host, bindId);

        if (f === current) return;

        if (current && restoreOnChange) {
            (current as any).onChange = restoreOnChange;
            restoreOnChange = undefined;
        }

        current = f;

        if (current) {
            restoreOnChange = (current as any).onChange;
            (current as any).onChange = (
                next: unknown,
                prev: unknown,
                variant: string
            ) => {
                restoreOnChange?.(next, prev, variant);
                handler({
                    exists: true,
                    field: current,
                    value: next as T,
                    error: (current as any).error,
                });
            };
        }

        fire();
    };

    // initial
    wire();

    let intervalId: number | undefined;
    if (typeof window !== "undefined") {
        intervalId = window.setInterval(wire, pollMs);
    }

    let mo: MutationObserver | undefined;
    if (
        typeof MutationObserver !== "undefined" &&
        typeof document !== "undefined"
    ) {
        try {
            mo = new MutationObserver(wire);
            mo.observe(document.body, {
                childList: true,
                subtree: true,
            });
        } catch {
            // ignore
        }
    }

    return () => {
        if (typeof window !== "undefined" && typeof intervalId === "number") {
            window.clearInterval(intervalId);
        }
        if (mo) {
            mo.disconnect();
            mo = undefined;
        }
        if (current && restoreOnChange) {
            (current as any).onChange = restoreOnChange;
            restoreOnChange = undefined;
        }
    };
}
```

---
#### 7


` File: packages/form-palette/src/core/bound/wait-for-bound-field.ts`  [↑ Back to top](#index)

```ts
// src/core/bound/wait-for-bound-field.ts

import type { Dict } from "@/schema/core";
import type { Field } from "@/schema/field";
import type { BindHost } from "@/core/bound/bind-host";
import {
    getBoundField,
    observeBoundField,
} from "@/core/bound/observe-bound-field";

export function waitForBoundField<V extends Dict>(
    host: BindHost<V>,
    bindId: string,
    timeoutMs = 5000
): Promise<Field> {
    const existing = getBoundField(host, bindId);
    if (existing) return Promise.resolve(existing);

    return new Promise<Field>((resolve, reject) => {
        let settled = false;

        const settleResolve = (field: Field) => {
            if (settled) return;
            settled = true;
            stop();
            clearTimeout(to);
            resolve(field);
        };

        const settleReject = (error: Error) => {
            if (settled) return;
            settled = true;
            stop();
            clearTimeout(to);
            reject(error);
        };

        const stop = observeBoundField(
            host,
            bindId,
            (e) => {
                if (e.exists && e.field) {
                    settleResolve(e.field);
                }
            },
            150
        );

        const to = setTimeout(() => {
            settleReject(
                new Error(
                    `waitForBoundField('${bindId}') timed out after ${timeoutMs}ms`
                )
            );
        }, timeoutMs);
    });
}
```

---
#### 8


` File: packages/form-palette/src/core/context.ts`  [↑ Back to top](#index)

```ts
// src/core/context.ts
import React from "react";
import type { CoreContext, Dict } from "@/schema/core";

/**
 * Non-generic alias for the core context type used at runtime.
 *
 * We store CoreContext<Dict> in React context and let
 * caller-side hooks (useCore, useCoreContext, etc.) cast
 * to a more specific generic shape when needed.
 */
export type AnyCoreContext = CoreContext<Dict>;

/**
 * React context carrying the current form/core instance.
 *
 * - Provider is set up in core-provider.tsx.
 * - Consumers should generally use the typed hook in
 *   hooks/use-core-context.ts instead of reading this directly.
 */
export const CoreContextReact = React.createContext<AnyCoreContext | null>(
    null
);
```

---
#### 9


` File: packages/form-palette/src/core/core-provider.tsx`  [↑ Back to top](#index)

```tsx
// src/core/core-provider.tsx
// noinspection JSConstantReassignment,JSUnusedGlobalSymbols,GrazieInspection

import * as React from "react";

import { CoreContextReact } from "@/core/context";
import { mapZodError } from "@/core/errors/map-zod";
import { mapErrorBag } from "@/core/errors/map-error-bag";
import { getAdapter, localAdapter } from "@/core/adapter-registry";
import { FieldRegistry } from "@/core/registry/field-registry";

import type { z } from "zod";
import type {
    AdapterKey,
    AdapterProps,
    AdapterResult,
    Method,
} from "@/schema/adapter";
import type {
    CoreContext,
    CoreProps,
    Dict,
    InferFromSchema,
    SubmitEvent,
    ValuesResult,
} from "@/schema/core";
import type { ButtonRef, Field } from "@/schema/field";
import { getPaletteUtil } from "@/lib/register-global";
import { toArray } from "@/lib/utils";
import type { FileItem } from "@/presets/shadcn-variants/file";

type Props<
    V extends Dict,
    S extends z.ZodType | undefined,
    K extends AdapterKey,
> = CoreProps<V, S, K> & {
    children?: React.ReactNode;
};

// Core-level props that are NOT part of AdapterProps<K>
const CORE_PROP_KEYS = new Set<string>([
    "adapter",
    "schema",
    "exceptions",
    "persist",
    "name",
    "activateButtonOnChange",
    "onChange",
    "onUpdate",
    "changeBefore",
    "formRef",
    "valueBag",
    "valueFeed",
    "onFinish",
    "init",
    "onSubmit",
    "onSubmitted",
    "children",
]);

// ─────────────────────────────────────────────────────────────
// Internal helpers (generic utils)
// ─────────────────────────────────────────────────────────────
function isPlainObject(value: unknown): value is Record<string, unknown> {
    return typeof value === "object" && value !== null && !Array.isArray(value);
}

function deepEqual(a: unknown, b: unknown): boolean {
    if (a === b) return true;

    // NaN === NaN
    if (typeof a === "number" && typeof b === "number") {
        if (Number.isNaN(a) && Number.isNaN(b)) return true;
    }

    if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) {
            if (!deepEqual(a[i], b[i])) return false;
        }
        return true;
    }

    if (isPlainObject(a) && isPlainObject(b)) {
        const aKeys = Object.keys(a);
        const bKeys = Object.keys(b);
        if (aKeys.length !== bKeys.length) return false;
        for (const key of aKeys) {
            if (!Object.prototype.hasOwnProperty.call(b, key)) return false;
            if (!deepEqual((a as any)[key], (b as any)[key])) return false;
        }
        return true;
    }

    return false;
}
// ─────────────────────────────────────────────────────────────
// CoreProvider
// ─────────────────────────────────────────────────────────────

/**
 * CoreProvider: owns the form/core runtime state and implements CoreContext.
 *
 * - Tracks all inputs in a single store (inputsRef)
 * - Supports:
 *   - named inputs via `name`
 *   - bound inputs via `bindId`
 *   - grouped inputs via `groupId`
 * - Manages errors and uncaught messages
 * - Builds values snapshots (including bucket values)
 * - Orchestrates submission via the adapter registry
 */
export function CoreProvider<
    V extends Dict,
    S extends z.ZodType | undefined,
    K extends AdapterKey = "local",
>(props: Props<V, S, K>) {
    type Values = InferFromSchema<S, V>;

    // Single input store: FieldRegistry
    const registryRef = React.useRef<FieldRegistry>(new FieldRegistry());
    ``;
    // bucket, errors, button
    const bucketRef = React.useRef<Dict>({});
    const uncaughtRef = React.useRef<string[]>([]);
    const errorsRef = React.useRef<Dict<string> | null>(null);
    const buttonRef = React.useRef<ButtonRef | null>(null);
    const activeButtonNameRef = React.useRef<string | null>(null);

    const [hasUncaughtErrors, setHasUncaughtErrors] = React.useState(0);
    /**
     * Original snapshot used for "dirty" checks.
     * Lazily captured on first dirty-check.
     */
    const originalRef = React.useRef<Values | null>(null);

    // latest props
    const propsRef = React.useRef(props);
    React.useEffect(() => {
        propsRef.current = props;
    }, [props]);

    const adapterKey = (props.adapter ?? "local") as AdapterKey;
    const schema = props.schema;
    const errorBagId = props.name ?? undefined;
    let context!: CoreContext<Values>;

    // ─────────────────────────────────────────────────────────
    // Common helpers
    // ─────────────────────────────────────────────────────────

    function fetchAllNamedFields(): Field[] {
        return registryRef.current.getAllNamed();
    }

    function clearFieldErrors() {
        for (const field of fetchAllNamedFields()) {
            const anyField = field as any;
            if (typeof anyField.setError === "function") {
                anyField.setError(undefined);
            } else if ("error" in anyField) {
                anyField.error = undefined;
            }
        }
    }

    function findFieldForErrorKey(key: string): Field | undefined {
        if (!key) return undefined;
        return fetchAllNamedFields().find((f) => {
            const raw = f.name;
            if (!raw) return false;
            const trimmed = raw.trim();
            if (!trimmed) return false;

            const base = trimmed.replace(/\[]$/, "");
            if (key === base || key === trimmed) return true;

            const sharedKey = (f as any).shared as string | undefined;
            if (!sharedKey) return false;

            const sharedBase = `${sharedKey}.${base}`;
            const sharedRaw = `${sharedKey}.${trimmed}`;
            return key === sharedBase || key === sharedRaw;
        });
    }

    function setFieldError(name: string, message: string) {
        const field = findFieldForErrorKey(name);

        if (field) {
            const anyField = field as any;
            if (typeof anyField.setError === "function") {
                anyField.setError(message);
            } else {
                anyField.error = message;
            }
        } else {
            uncaughtRef.current.push(message);
        }
    }

    /**
     * Collect values from inputs into a Values object.
     *
     * Semantics:
     * - `name="tags[]"` ⇒ `values.tags: unknown[]`
     * - `shared="profile", name="first_name"` ⇒ `values.profile.first_name`
     * - bucketRef.current is merged in and overridden by live field values.
     * - `exceptions` can hide keys (e.g. ["password", "profile.ssn"])
     */
    function collectValues(): Values {
        const exceptions = propsRef.current.exceptions ?? [];
        const list: Dict = {};
        const shared: Dict<Dict> = {};
        const formatFileValue = getPaletteUtil('formatFileValue')

        for (const item of fetchAllNamedFields()) {
            const rawName = item.name;
            if (!rawName) continue;

            const trimmed = rawName.trim();
            if (!trimmed) continue;

            const isArray = trimmed.endsWith("[]");
            const base = trimmed.replace(/\[]$/, "");
            const sharedKey = (item as any).shared as string | undefined;

            const target = sharedKey
                ? (shared[sharedKey] ?? (shared[sharedKey] = {}))
                : list;

            const fullPath = sharedKey ? `${sharedKey}.${base}` : base;
            if (
                exceptions.includes(trimmed) ||
                exceptions.includes(base) ||
                exceptions.includes(fullPath)
            ) {
                continue;
            }

            const anyField = item as any;
            const val =
                typeof anyField.getValue === "function"
                    ? (anyField.getValue() as unknown)
                    : (anyField.value as unknown);

            const onFormat = (value: any) => {
                if (anyField.onSubmit) {
                    return anyField.onSubmit(value);
                }

                if(formatFileValue && item.variant == 'file') {
                    return toArray(value as FileItem | FileItem[]).map(formatFileValue);
                }

                return value;
            };

            if (isArray) {
                const existing = target[base];
                if (Array.isArray(existing)) {
                    target[base] = onFormat([...existing, val]);
                } else if (typeof existing === "undefined") {
                    target[base] = onFormat([val]);
                } else {
                    target[base] = onFormat([existing, val]);
                }
            } else {
                target[base] = onFormat(val);
            }
        }

        const fromFields: Dict = { ...list, ...shared };
        const merged: Dict = {
            ...bucketRef.current,
            ...fromFields,
        };

        return merged as Values;
    }

    function validateInternal(report: boolean = false): boolean {
        let valid = true;

        if (report) {
            uncaughtRef.current = [];
            clearFieldErrors();
        }

        // field-level
        for (const field of fetchAllNamedFields()) {
            const anyField = field as any;
            if (typeof anyField.validate === "function") {
                const ok = anyField.validate(report);
                if (!ok) valid = false;
            }
        }

        // schema-level
        if (schema) {
            try {
                schema.parse(collectValues());
            } catch (err: unknown) {
                valid = false;

                if (report && err && typeof err === "object") {
                    const anyErr = err as any;
                    if (anyErr.issues) {
                        const { fieldErrors, uncaught } = mapZodError(anyErr);
                        for (const [name, message] of Object.entries(
                            fieldErrors,
                        )) {
                            setFieldError(name, message);
                        }
                        if (uncaught.length) {
                            uncaughtRef.current.push(...uncaught);
                        }
                    }
                }
            }
        }

        return valid;
    }

    function getAdapterPropsFrom(current: Props<V, S, K>): AdapterProps<K> {
        const result: any = {};
        for (const key in current) {
            if (!CORE_PROP_KEYS.has(key)) {
                result[key] = (current as any)[key];
            }
        }
        return result as AdapterProps<K>;
    }

    // ─────────────────────────────────────────────────────────
    // Submission
    // ─────────────────────────────────────────────────────────

    async function submitWithAdapter(
        adapterOverride?: Partial<AdapterProps<K>>,
        extra?: Partial<Values>,
        ignoreForm?: boolean,
        autoErr: boolean = true,
        autoRun: boolean = true,
    ): Promise<AdapterResult<any> | undefined> {
        const currentProps = propsRef.current as Props<V, S, K>;

        // active button + loading
        const btn = buttonRef.current as any;
        const activeName = activeButtonNameRef.current;
        const isActiveButton =
            !!btn && typeof btn === "object" && btn.name === activeName;

        const setButtonLoading = (loading: boolean) => {
            if (!isActiveButton) return;
            if (typeof btn.setLoading === "function") {
                btn.setLoading(loading);
            } else if ("loading" in btn) {
                btn.loading = loading;
            }
        };

        setButtonLoading(true);

        let finished = false;
        const finish = () => {
            if (finished) return;
            finished = true;
            if (uncaughtRef.current.length)
                setHasUncaughtErrors(hasUncaughtErrors + 1);
            setButtonLoading(false);
        };

        if (!ignoreForm) {
            const ok = validateInternal(true);
            if (!ok) {
                finish();
                return undefined;
            }
        }

        let submissionValues: Values = {
            ...collectValues(),
            ...(extra ?? {}),
        };

        // Base adapter config from props + override from caller
        let adapterConfig: AdapterProps<K> = {
            ...(getAdapterPropsFrom(currentProps) as any),
            ...(adapterOverride as Partial<AdapterProps<K>> | undefined),
        };

        const event: SubmitEvent<Values, K> = {
            preventDefault() {
                this.continue = false;
            },
            editData(cb) {
                const result = cb(submissionValues);
                if (result) {
                    submissionValues = result;
                }
            },
            setConfig(arg1: any, arg2?: any) {
                if (typeof arg1 === "string") {
                    // key, value
                    (adapterConfig as any)[arg1] = arg2;
                } else if (arg1 && typeof arg1 === "object") {
                    // partial props
                    adapterConfig = {
                        ...(adapterConfig as any),
                        ...arg1,
                    };
                }
            },

            button: buttonRef.current ?? undefined,
            get formData() {
                return submissionValues;
            },

            form: context,
            continue: true,
        };

        if (currentProps.onSubmit) {
            try {
                await currentProps.onSubmit(event as any);
            } catch (err) {
                // host blew up: end this submit cycle
                finish();
                throw err;
            }
        }

        if (!event.continue) {
            finish();
            return undefined;
        }

        const factory =
            getAdapter(adapterKey) ??
            (localAdapter as unknown as (cfg: any) => AdapterResult<any>);

        const adapter = factory({
            // adapter-specific config (url, method, config, etc.)
            ...(adapterConfig as any),

            // core config
            data: submissionValues,
            errorBag: errorBagId,
            callbacks: {
                onSuccess(ok: unknown) {
                    const maybe = propsRef.current.onSubmitted;
                    if (maybe) {
                        void maybe(context, ok as any, () => {
                            finish();
                        });
                    }
                },
                onError(err: unknown, updateRef) {
                    if (!autoErr || !err || typeof err !== "object") {
                        return;
                    }

                    const anyErr = err as any;
                    if (anyErr.errors && typeof anyErr.errors === "object") {
                        const { fieldErrors, uncaught } = mapErrorBag(
                            anyErr.errors ?? {},
                        );

                        if (updateRef) {
                            errorsRef.current = fieldErrors;
                        } else
                            for (const [name, message] of Object.entries(
                                fieldErrors,
                            )) {
                                setFieldError(name, message);
                            }
                        if (uncaught.length) {
                            uncaughtRef.current.push(...uncaught);
                        }
                    }
                },
                onFinish() {
                    const maybe = propsRef.current.onFinish;
                    if (maybe) {
                        maybe(context);
                    }
                    finish();
                },
            },
        });
        if (autoRun) {
            try {
                await adapter.send();
            } catch (e) {
                console.log("Adapter failed to send.", e);
                // errors flow via callbacks; adapter may still call onFinish
            }
        }

        return adapter;
    }

    // No separate inputs view: expose registry directly via context.inputs

    // ─────────────────────────────────────────────────────────
    // CoreContext implementation
    // ─────────────────────────────────────────────────────────

    context = {
        values(): Values {
            return collectValues();
        },

        submit(): ValuesResult<Values> {
            const valid = validateInternal(true);
            const vals = collectValues();
            return { values: vals, valid };
        },

        getBind(id: string): Field | undefined {
            return registryRef.current.getByBind(id);
        },

        validate(report?: boolean): boolean {
            return validateInternal(report);
        },

        addField(field: Field): void {
            // Normalise name
            const rawName = field.name ?? "";
            (field as any).name = rawName.trim();

            // hydrate from valueBag before registering
            const { valueBag, valueFeed } = propsRef.current;
            const trimmed = (field.name ?? "").trim();
            const hasName = !!trimmed;
            const isArray = hasName && trimmed.endsWith("[]");
            const base = hasName ? trimmed.replace(/\[]$/, "") : "";
            const sharedKey = (field as any).shared as string | undefined;

            if (valueBag && !(field as any).ignore && hasName) {
                const sourceRoot: any =
                    sharedKey && (valueBag as any)[sharedKey]
                        ? (valueBag as any)[sharedKey]
                        : valueBag;

                let value: unknown = undefined;

                if (sourceRoot && typeof sourceRoot === "object") {
                    if (isArray && Array.isArray(sourceRoot[base])) {
                        const siblings = fetchAllNamedFields().filter((f) => {
                            const rn = (f.name ?? "").trim();
                            return (
                                rn === trimmed &&
                                ((f as any).shared as string | undefined) ===
                                    sharedKey
                            );
                        });
                        const idx = siblings.length;
                        value = (sourceRoot[base] as unknown[])[idx];
                    } else {
                        value = sourceRoot[base];
                    }
                }

                let hydrated: unknown = value;
                if (valueFeed) {
                    const maybe = valueFeed(
                        base as keyof Values,
                        value as any,
                        context as any,
                    );
                    if (typeof maybe !== "undefined") {
                        hydrated = maybe;
                    }
                }

                if (typeof hydrated !== "undefined") {
                    const anyField = field as any;
                    if (typeof anyField.setValue === "function") {
                        anyField.setValue(hydrated);
                    } else {
                        anyField.value = hydrated;
                    }
                }
            }

            // finally register into the single store (name/bindId/groupId)
            registryRef.current.add(field);
        },

        // Expose registry view as inputs (delegates to FieldRegistry instance)
        inputs: registryRef.current,

        // Also expose raw list of fields for compatibility is defined later as a getter

        bucket: bucketRef.current,

        error(
            nameOrBag: string | Record<string, string>,
            maybeMsg?: string,
        ): void {
            if (typeof nameOrBag === "string") {
                if (!maybeMsg) return;
                setFieldError(nameOrBag, maybeMsg);
                return;
            }

            const { fieldErrors, uncaught } = mapErrorBag(nameOrBag);
            for (const [name, message] of Object.entries(fieldErrors)) {
                setFieldError(name, message);
            }
            if (uncaught.length) {
                uncaughtRef.current.push(...uncaught);
            }
        },

        controlButton(): void {
            const { activateButtonOnChange } = propsRef.current;
            if (!activateButtonOnChange) return;

            const btn = buttonRef.current as any;
            const activeName = activeButtonNameRef.current;

            // If there is no active button or it doesn't match, nothing to control.
            if (!btn || btn.name !== activeName) {
                return;
            }

            // Capture original snapshot lazily.
            if (!originalRef.current) {
                originalRef.current = collectValues();
            }

            const current = collectValues();
            const original = originalRef.current!;

            const dirty = !deepEqual(original, current);

            const setDisabled = (disabled: boolean) => {
                if (typeof btn.setDisabled === "function") {
                    btn.setDisabled(disabled);
                } else if ("disabled" in btn) {
                    btn.disabled = disabled;
                }
            };

            // Dirty ⇒ enable button, clean ⇒ disable button
            setDisabled(!dirty);
        },

        isDirty() {
            if (!originalRef.current) {
                originalRef.current = collectValues();
            }

            const current = collectValues();
            const original = originalRef.current!;

            return !deepEqual(original, current);
        },

        async prepare(
            type: Method,
            route: string,
            extra?: Partial<Values>,
            ignoreForm?: boolean,
            autoErr?: boolean,
        ): Promise<AdapterResult<any> | undefined> {
            // Bridge old (method, route) API into adapter config overrides.
            const override: any = {
                method: type,
                url: route,
            };
            return submitWithAdapter(
                override as Partial<AdapterProps<K>>,
                extra,
                ignoreForm,
                autoErr,
                false,
            );
        },

        persist(
            data: Partial<Values>,
            feed?: (name: string, value: unknown, original: unknown) => unknown,
        ): void {
            const seen: Record<string, number> = {};
            const root = data as any;

            const useFeed =
                feed ||
                (propsRef.current.valueFeed
                    ? (
                          name: string,
                          value: unknown,
                          original: unknown,
                      ): unknown => {
                          const vf = propsRef.current.valueFeed!;
                          const maybe = vf(
                              name as keyof Values,
                              value as any,
                              context as any,
                          );
                          return typeof maybe === "undefined"
                              ? original
                              : maybe;
                      }
                    : undefined);

            for (const field of fetchAllNamedFields()) {
                const rawName = field.name;
                if (!rawName) continue;
                if ((field as any).ignore) continue;

                const trimmed = rawName.trim();
                if (!trimmed) continue;

                const isArray = trimmed.endsWith("[]");
                const base = trimmed.replace(/\[]$/, "");
                const sharedKey = (field as any).shared as string | undefined;
                const key = sharedKey ? `${sharedKey}.${base}` : base;

                let value: unknown = undefined;

                if (sharedKey) {
                    const group = root[sharedKey];
                    if (group && typeof group === "object") {
                        if (isArray && Array.isArray(group[base])) {
                            const idx = seen[key] ?? 0;
                            value = (group[base] as unknown[])[idx];
                            seen[key] = idx + 1;
                        } else {
                            value = group[base];
                        }
                    }
                } else {
                    if (isArray && Array.isArray(root[base])) {
                        const idx = seen[key] ?? 0;
                        value = (root[base] as unknown[])[idx];
                        seen[key] = idx + 1;
                    } else {
                        value = root[base];
                    }
                }

                const anyField = field as any;
                const original =
                    typeof anyField.getValue === "function"
                        ? anyField.getValue()
                        : anyField.value;

                let next = value;
                if (useFeed) {
                    const maybe = useFeed(base, value, original);
                    if (typeof maybe === "undefined") {
                        continue;
                    }
                    next = maybe;
                }

                if (typeof anyField.setValue === "function") {
                    anyField.setValue(next);
                } else {
                    anyField.value = next;
                }
            }

            if (propsRef.current.onUpdate) {
                propsRef.current.onUpdate(collectValues());
            }
        },

        setValue(name: string, value: unknown): void {
            if (!name) return;

            let sharedKey: string | undefined;
            let base = name;

            if (name.includes(".")) {
                const [group, field] = name.split(".", 2);
                sharedKey = group;
                base = field;
            }

            const targetField = fetchAllNamedFields().find((f) => {
                const raw = (f.name ?? "").trim();
                if (!raw) return false;

                const isArray = raw.endsWith("[]");
                const rawBase = raw.replace(/\[]$/, "");
                const fShared = (f as any).shared as string | undefined;

                const sameGroup = fShared === sharedKey;
                const sameName =
                    raw === name ||
                    rawBase === base ||
                    `${fShared}.${rawBase}` === name;

                return (!sharedKey || sameGroup) && sameName && !isArray;
            });

            if (targetField) {
                const anyField = targetField as any;
                if (typeof anyField.setValue === "function") {
                    anyField.setValue(value);
                } else {
                    anyField.value = value;
                }
            } else {
                bucketRef.current[name] = value;
            }

            if (propsRef.current.onUpdate) {
                propsRef.current.onUpdate(collectValues());
            }
        },

        go(data?: Partial<Values>, ignoreForm?: boolean): void {
            void submitWithAdapter(undefined, data, ignoreForm, true, true);
        },

        reset(inputs: string[]): void {
            if (!inputs.length) return;

            for (const field of fetchAllNamedFields()) {
                const raw = field.name;
                if (!raw) continue;
                if (!inputs.includes(raw)) continue;

                const anyField = field as any;
                if (typeof anyField.reset === "function") {
                    anyField.reset();
                } else if (typeof anyField.setValue === "function") {
                    anyField.setValue(undefined);
                } else {
                    anyField.value = undefined;
                }
            }
        },

        set button(btn: ButtonRef) {
            buttonRef.current = btn;
        },

        async forceSubmit(): Promise<void> {
            await submitWithAdapter(undefined, undefined, false, true, true);
        },

        get fields(): Field[] {
            return fetchAllNamedFields();
        },

        get props() {
            const { formRef, valueBag, ...rest } = propsRef.current;
            return rest as any;
        },

        setActiveButton(name: string): void {
            activeButtonNameRef.current = name;
        },

        hasUncaughtErrors,

        getUncaught(): readonly string[] {
            return uncaughtRef.current;
        },
    } as CoreContext<Values>;

    // formRef exposure
    React.useEffect(() => {
        if (!props.formRef) return;

        props.formRef.current = context;
        return () => {
            if (props.formRef) {
                props.formRef.current = null;
            }
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [context]);

    // init hook once
    React.useEffect(() => {
        if (props.init) {
            props.init(context);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    return (
        <CoreContextReact.Provider value={context as any}>
            {props.children}
        </CoreContextReact.Provider>
    );
}
```

---
#### 10


` File: packages/form-palette/src/core/core-root.tsx`  [↑ Back to top](#index)

```tsx
// src/core/core-root.tsx

import * as React from "react";

import { useCore } from "@/core/hooks/use-core";
import { ErrorStrip } from "@/core/errors/error-strip";
import type { CoreContext, Dict } from "@/schema/core";

export interface CoreRootProps
    extends React.FormHTMLAttributes<HTMLFormElement> {
    /**
     * If true, the global ErrorStrip will not be rendered automatically.
     */
    noErrorStrip?: boolean;

    /**
     * Optional hook invoked after CoreRoot orchestrates the submit.
     *
     * - The native event is already `preventDefault()`-ed.
     * - The adapter flow is triggered via `form.go(...)`.
     * - Use this to tap into submit without breaking the core.
     */
    onSubmitForm?(
        event: React.FormEvent<HTMLFormElement>,
        form: CoreContext<Dict>
    ): void | Promise<void>;
}

/**
 * CoreRoot: actual <form> element wired to the core runtime.
 *
 * Responsibilities:
 * - Own the native submit event and prevent full-page navigation.
 * - Delegate submit orchestration to form.go().
 * - Optionally render the global ErrorStrip at the top.
 */
export function CoreRoot(props: CoreRootProps) {
    const { noErrorStrip, onSubmitForm, children, ...rest } = props;

    const form = useCore<Dict>();

    const handleSubmit = React.useCallback(
        (event: React.FormEvent<HTMLFormElement>) => {
            event.preventDefault();
            if (form.props.activateButtonOnChange && !form.isDirty()) return;
            // Core submit orchestration (adapter-specific behaviour lives inside).
            form.go();

            // Optional host-level hook.
            if (onSubmitForm) {
                void onSubmitForm(event, form);
            }

            // If the host provided a native onSubmit prop, call it too.
            if (typeof rest.onSubmit === "function") {
                rest.onSubmit(event);
            }
        },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [form, onSubmitForm, rest.onSubmit]
    );

    // We intentionally override onSubmit so the core owns submit routing.
    const { onSubmit: _ignored, ...passThrough } = rest;

    return (
        <form onSubmit={handleSubmit} {...passThrough}>
            {!noErrorStrip && <ErrorStrip className={'mb-2'} form={form} />}
            {children}
        </form>
    );
}
```

---
#### 11


` File: packages/form-palette/src/core/core-shell.tsx`  [↑ Back to top](#index)

```tsx
// src/core/core-shell.tsx

import * as React from "react";

import { CoreProvider } from "@/core/core-provider";
import { CoreRoot, type CoreRootProps } from "@/core/core-root";

import type { z } from "zod";
import type { AdapterKey } from "@/schema/adapter";
import type { CoreProps, Dict } from "@/schema/core";
import { cn } from "@/lib/utils";

/**
 * Shared base props for CoreShell, independent of wrapping behaviour.
 */
type CoreShellBaseProps<
    V extends Dict = Dict,
    S extends z.ZodType | undefined = z.ZodType | undefined,
    K extends AdapterKey = "local",
> = CoreProps<V, S, K> & {
    /**
     * Props passed directly to the underlying <form> element via CoreRoot.
     */
    formProps?: CoreRootProps;
    children?: React.ReactNode;
};

/**
 * When `wrapped` is true, you can provide gap/contentClassName.
 */
export type CoreShellWrappedProps<
    V extends Dict = Dict,
    S extends z.ZodType | undefined = z.ZodType | undefined,
    K extends AdapterKey = "local",
> = CoreShellBaseProps<V, S, K> & {
    wrapped: true;
    /**
     * Gap for the inner wrapper. You can still control layout
     * (flex/grid/etc.) via `contentClassName`.
     */
    gap?: React.CSSProperties["gap"];
    /**
     * Class applied to the wrapper around children.
     */
    contentClassName?: string;
};

/**
 * When `wrapped` is not true (false/undefined), gap/contentClassName
 * are not allowed.
 */
export type CoreShellUnwrappedProps<
    V extends Dict = Dict,
    S extends z.ZodType | undefined = z.ZodType | undefined,
    K extends AdapterKey = "local",
> = CoreShellBaseProps<V, S, K> & {
    wrapped?: false | undefined;
};

export type CoreShellProps<
    V extends Dict = Dict,
    S extends z.ZodType | undefined = z.ZodType | undefined,
    K extends AdapterKey = "local",
> = CoreShellWrappedProps<V, S, K> | CoreShellUnwrappedProps<V, S, K>;

/**
 * Combined provider + form-root wrapper.
 *
 * Usage:
 *   <CoreShell adapter="local" schema={schema} formProps={{ className: "space-y-4" }}>
 *     {...fields + buttons...}
 *   </CoreShell>
 *
 *   <CoreShell
 *     adapter="local"
 *     schema={schema}
 *     wrapped
 *     gap="1rem"
 *     contentClassName="flex flex-col"
 *   >
 *     {...fields + buttons...}
 *   </CoreShell>
 */
export function CoreShell<
    V extends Dict,
    S extends z.ZodType | undefined,
    K extends AdapterKey = "local",
>(props: CoreShellProps<V, S, K>) {
    if (props.wrapped) {
        const {
            formProps,
            children,
            wrapped, // eslint-disable-line @typescript-eslint/no-unused-vars
            gap,
            contentClassName,
            ...coreProps
        } = props;

        const content = (
            <div
                className={cn('flex flex-col', contentClassName)}
                style={gap !== undefined ? { gap } : undefined}
            >
                {children}
            </div>
        );

        return (
            <CoreProvider<V, S, K> {...coreProps as any}>
                <CoreRoot {...(formProps ?? {})}>{content}</CoreRoot>
            </CoreProvider>
        );
    }

    const { formProps, children, ...coreProps } = props;

    return (
        <CoreProvider<V, S, K> {...coreProps as any}>
            <CoreRoot {...(formProps ?? {})}>{children}</CoreRoot>
        </CoreProvider>
    );
}
```

---
#### 12


` File: packages/form-palette/src/core/errors/error-strip.tsx`  [↑ Back to top](#index)

```tsx
// src/core/errors/error-strip.tsx

import * as React from "react";
import { X, AlertCircle } from "lucide-react";

import { useCore } from "@/core/hooks/use-core";
import type { CoreContext, Dict } from "@/schema/core";
import { cn } from "@/lib/utils";

export interface ErrorStripProps extends React.HTMLAttributes<HTMLElement> {
    form?: CoreContext<Dict>;
    messages?: readonly string[];
    renderMessage?: (message: string, index: number) => React.ReactNode;
    as?: React.ElementType;
    listProps?: React.HTMLAttributes<HTMLUListElement>;
    dismissible?: boolean;
    onDismiss?: () => void;
    title?: string;
}

export function ErrorStrip(props: ErrorStripProps) {
    const {
        form: formProp,
        messages: messagesProp,
        renderMessage,
        as: As = "div",
        listProps,
        dismissible = true,
        onDismiss,
        title,
        className,
        ...wrapperProps
    } = props;

    const ctxFromHook = useCore<Dict>();
    const form = formProp ?? ctxFromHook;
    const [isVisible, setIsVisible] = React.useState(true);

    const messages = messagesProp
        ? messagesProp
        : ((form?.hasUncaughtErrors ? form?.getUncaught?.() : []) ?? []);

    React.useEffect(() => {
        if (messages.length > 0) {
            setIsVisible(true);
        }
    }, [messages, messages.length]);

    const handleDismiss = () => {
        setIsVisible(false);
        onDismiss?.();
    };

    if (!isVisible || messages.length === 0) {
        return null;
    }

    return (
        <As
            role="alert"
            // Changed: px-3 py-2 (tighter padding) and text-xs (smaller font)
            className={cn(
                "relative w-full rounded-md border border-destructive/50 bg-destructive/10 px-3 py-2 text-xs text-destructive dark:border-destructive/40 dark:text-red-400",
                className,
            )}
            {...wrapperProps}
        >
            <div className="flex items-start gap-2.5">
                {/* Icon scaled down to h-3.5 */}
                <AlertCircle className="mt-0.5 h-3.5 w-3.5 shrink-0" />

                <div className="flex-1 grow">
                    {title && (
                        <h5 className="mb-1 font-semibold leading-none tracking-tight">
                            {title}
                        </h5>
                    )}

                    <ul
                        {...listProps}
                        className={cn(
                            "list-none space-y-1",
                            listProps?.className,
                        )}
                    >
                        {messages.map((msg, index) => (
                            <li
                                key={index}
                                className="opacity-90 leading-tight"
                            >
                                {renderMessage
                                    ? renderMessage(msg, index)
                                    : msg}
                            </li>
                        ))}
                    </ul>
                </div>

                {dismissible && (
                    <button
                        type="button"
                        onClick={handleDismiss}
                        // Button styles adjusted for smaller footprint
                        className={cn(
                            "absolute right-1.5 top-1.5 rounded-sm p-0.5 opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-1 focus:ring-ring focus:ring-offset-1",
                            "hover:bg-destructive/15 text-destructive",
                        )}
                        aria-label="Dismiss errors"
                    >
                        <X className="h-3.5 w-3.5" />
                    </button>
                )}
            </div>
        </As>
    );
}
```

---
#### 13


` File: packages/form-palette/src/core/errors/index.ts`  [↑ Back to top](#index)

```ts
export * from "./map-error-bag";
export * from "./map-zod";
export * from './error-strip'
```

---
#### 14


` File: packages/form-palette/src/core/errors/map-error-bag.ts`  [↑ Back to top](#index)

```ts
// src/core/errors/map-error-bag.ts

export type ErrorBag = Record<string, string | string[] | undefined | null>;

export type ErrorBagMapResult = {
    /** Field-specific errors keyed by field name. */
    fieldErrors: Record<string, string>;
    /** Errors that could not be mapped to a specific field. */
    uncaught: string[];
};

/**
 * Map a generic "error bag" object into field errors + uncaught messages.
 *
 * Typical input:
 *   {
 *     name: "Name is required",
 *     email: ["Email is invalid"],
 *     message: "Something went wrong" // global
 *   }
 *
 * Heuristics:
 * - Keys like "message", "error", "_", "global" → treated as global/uncaught.
 * - Everything else → treated as a field error.
 * - Array values are joined with "\n".
 */
export function mapErrorBag(bag: ErrorBag): ErrorBagMapResult {
    const fieldErrors: Record<string, string> = {};
    const uncaught: string[] = [];

    const GLOBAL_KEYS = new Set(["message", "error", "errors", "_", "global"]);

    for (const [key, raw] of Object.entries(bag)) {
        if (raw == null) continue;

        const value = Array.isArray(raw)
            ? raw.filter(Boolean).join("\n")
            : String(raw);

        if (!value) continue;

        if (GLOBAL_KEYS.has(key)) {
            uncaught.push(value);
        } else {
            const existing = fieldErrors[key];
            fieldErrors[key] = existing ? `${existing}\n${value}` : value;
        }
    }

    return { fieldErrors, uncaught };
}
```

---
#### 15


` File: packages/form-palette/src/core/errors/map-zod.ts`  [↑ Back to top](#index)

```ts
// src/core/errors/map-zod.ts
import type { $ZodIssue, $ZodError } from "zod/v4/core";

export type ZodErrorMapResult = {
    /** Field-specific errors keyed by field name. */
    fieldErrors: Record<string, string>;
    /** Errors that could not be mapped to a specific field. */
    uncaught: string[];
};

/**
 * Map a ZodError into field-specific errors + uncaught messages.
 *
 * Heuristics:
 * - If issue.path[0] is a string → treated as a field name.
 * - Otherwise → message is pushed into `uncaught`.
 *
 * If a field has multiple issues, messages are joined with `\n`.
 */
export function mapZodError(error: $ZodError): ZodErrorMapResult {
    const fieldErrors: Record<string, string> = {};
    const uncaught: string[] = [];

    for (const issue of error.issues as $ZodIssue[]) {
        const path = issue.path;
        const message = issue.message || "Validation error";

        const first = path[0];

        if (typeof first === "string" && first.length > 0) {
            const existing = fieldErrors[first];
            fieldErrors[first] = existing ? `${existing}\n${message}` : message;
        } else {
            uncaught.push(message);
        }
    }

    return { fieldErrors, uncaught };
}
```

---
#### 16


` File: packages/form-palette/src/core/hooks/use-button.ts`  [↑ Back to top](#index)

```ts
// src/core/hooks/use-button.ts
// noinspection JSUnusedGlobalSymbols

import * as React from "react";

import { useCoreContext } from "@/core/hooks/use-core-context";
import type { CoreContext, Dict } from "@/schema/core";
import type { ButtonRef } from "@/schema/field";

export interface UseButtonOptions {
    /**
     * Logical name of the button.
     *
     * Used by the core to:
     * - mark this as the "active" button before submit
     * - toggle loading/disabled specifically for this button
     */
    name: string;

    /**
     * If true, clicking this button should trigger a submit:
     *
     * - form.setActiveButton(name)
     * - form.go()
     */
    submit?: boolean;

    /**
     * Initial disabled state.
     */
    disabled?: boolean;

    /**
     * Optional click handler.
     *
     * This runs *in addition to* the submit behavior (if `submit` is true).
     * You can call `event.preventDefault()` to prevent the auto-submit.
     */
    onClick?(
        event: React.MouseEvent<HTMLButtonElement>,
        form: CoreContext<Dict>
    ): void | Promise<void>;
}

export interface UseButtonReturn {
    /**
     * Current loading state, controlled by the core (via adapters) and
     * optionally by the host via setLoading.
     */
    loading: boolean;
    setLoading(loading: boolean): void;

    /**
     * Current disabled state.
     */
    disabled: boolean;
    setDisabled(disabled: boolean): void;

    /**
     * Ref for the underlying <button>.
     */
    ref: React.RefObject<HTMLButtonElement>;

    /**
     * Click handler wired to the core.
     */
    onClick(event: React.MouseEvent<HTMLButtonElement>): void;

    /**
     * Convenience bundle for spreading onto a <button>.
     *
     * Example:
     *   const btn = useButton({ name: "save", submit: true });
     *   return <button {...btn.buttonProps}>Save</button>;
     */
    buttonProps: {
        ref: React.RefObject<HTMLButtonElement>;
        disabled: boolean;
        "data-loading"?: "true" | "false";
        onClick(event: React.MouseEvent<HTMLButtonElement>): void;
    };
}

/**
 * useButton
 *
 * - Registers a ButtonRef with the core.
 * - Cooperates with setActiveButton + adapter-based submit.
 * - Handles loading/disabled toggling via the core's callbacks.
 */
export function useButton(options: UseButtonOptions): UseButtonReturn {
    const form = useCoreContext<Dict>();

    const { name, disabled: disabledProp = false } = options;

    const [loading, setLoadingState] = React.useState<boolean>(false);
    const [disabled, setDisabledState] = React.useState<boolean>(
        Boolean(disabledProp)
    );

    const ref = React.useRef<HTMLButtonElement>(null);

    // Keep latest options for callbacks
    const optsRef = React.useRef<UseButtonOptions>(options);
    React.useEffect(() => {
        optsRef.current = options;
    }, [options]);

    // Build the ButtonRef once
    const buttonRef = React.useRef<ButtonRef | (ButtonRef & any) | null>(null);

    if (!buttonRef.current) {
        // @ts-ignore
        const btn: ButtonRef & {
            loading: boolean;
            disabled: boolean;
            setLoading?(v: boolean): void;
            setDisabled?(v: boolean): void;
            ref?: React.RefObject<HTMLButtonElement>;
        } = {
            name,
            // Accessor for "loading" as required by ButtonRef
            set loading(v: boolean) {
                setLoadingState(v);
            },
            // Accessor for "disable" (note: interface uses `disable`, not `disabled`)
            //@ts-ignore
            set disable(v: boolean) {
                setDisabledState(v);
            },
            // Extra properties used by CoreProvider via any-casts
            get loading() {
                return loading;
            },
            setDisabled(v: boolean) {
                setDisabledState(v);
            },
            get disabled() {
                return disabled;
            },
            ref: ref as React.RefObject<HTMLButtonElement>,
        };

        // Also expose setLoading for CoreProvider's convenience
        (btn as any).setLoading = (v: boolean) => {
            setLoadingState(v);
        };

        buttonRef.current = btn;
    }

    // Keep mutable button properties in sync when name changes
    React.useEffect(() => {
        if (!buttonRef.current) return;
        buttonRef.current.name = name;
    }, [name]);

    // Register this button with the core
    React.useEffect(() => {
        if (!buttonRef.current) return;

        // Expose to the core runtime so submitWithAdapter can toggle loading.
        (form as any).button = buttonRef.current;

        return () => {
            // On unmount, if the core still points to this button,
            // we simply clear it.
            const anyForm = form as any;
            if (anyForm.button === buttonRef.current) {
                anyForm.button = null;
            }
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [form]);

    const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
        const currentOpts = optsRef.current;
        const shouldSubmit = !!currentOpts.submit;

        // Host-level handler first
        if (currentOpts.onClick) {
            currentOpts.onClick(event, form);
        }

        if (event.defaultPrevented) {
            return;
        }

        if (shouldSubmit) {
            // Mark this as the active button for the submit cycle.
            form.setActiveButton(currentOpts.name);

            // Kick off the standard submit pipeline.
            form.go();
        }
    };

    const setLoading = (v: boolean) => {
        setLoadingState(v);
    };

    const setDisabled = (v: boolean) => {
        setDisabledState(v);
    };

    return {
        loading,
        setLoading,
        disabled,
        setDisabled,
        ref: ref as React.RefObject<HTMLButtonElement>,
        onClick: handleClick,
        buttonProps: {
            ref: ref as React.RefObject<HTMLButtonElement>,
            disabled: disabled || loading,
            "data-loading": loading ? "true" : "false",
            onClick: handleClick,
        },
    };
}
```

---
#### 17


` File: packages/form-palette/src/core/hooks/use-core-context.ts`  [↑ Back to top](#index)

```ts
// src/core/hooks/use-core-context.ts
import { useContext } from "react";
import { CoreContextReact } from "@/core/context";
import type { CoreContext, Dict } from "@/schema/core";

/**
 * Typed hook to access the current core/form context.
 *
 * Must be used inside a <CoreProvider>. If no provider is found,
 * this will throw to make misuse obvious.
 */
export function useCoreContext<V extends Dict = Dict>(): CoreContext<V> {
    const ctx = useContext(CoreContextReact);

    if (!ctx) {
        throw new Error("useCoreContext must be used within a <CoreProvider>.");
    }

    return ctx as CoreContext<V>;
}
```

---
#### 18


` File: packages/form-palette/src/core/hooks/use-core.ts`  [↑ Back to top](#index)

```ts
// src/core/hooks/use-core.ts
import type { CoreContext, Dict } from "@/schema/core";
import { useCoreContext } from "./use-core-context";

/**
 * Convenience alias for useCoreContext.
 *
 * This mirrors the legacy useForm hook: you get the full CoreContext,
 * and can call core.values(), core.submit(), core.go(), etc.
 */
export function useCore<V extends Dict = Dict>(): CoreContext<V> {
    return useCoreContext<V>();
}
```

---
#### 19


` File: packages/form-palette/src/core/hooks/use-field.ts`  [↑ Back to top](#index)

```ts
// src/core/hooks/use-field.ts
// noinspection JSUnusedGlobalSymbols,GrazieInspection

import * as React from "react";

import { useCoreContext } from "@/core/hooks/use-core-context";
import type { CoreContext, Dict } from "@/schema/core";
import type { Field } from "@/schema/field";
import { VariantKey } from "@/schema/variant";

export type UseFieldValidate<T> = (
    value: T,
    field?: Field,
    form?: CoreContext<any>,
    report?: boolean,
) => boolean | string;

export interface UseFieldOptions<T = unknown> {
    /**
     * Primary field name.
     *
     * This is the key that will show up in the values snapshot and
     * error bags (unless mapped via `shared` or `alias`).
     */
    name?: string;

    variant: VariantKey

    /**
     * Optional internal binding identifier.
     *
     * Used by the bound helpers (observeBoundField, waitForBoundField)
     * and the binder registry.
     */
    bindId?: string;

    /**
     * Optional external binding key – a semantic identifier for this
     * field’s binding group.
     *
     * Example:
     *   bind="shipping"
     */
    bind?: string;

    /**
     * Shared key for nested grouping, e.g:
     *
     *   shared="profile", name="first_name"
     *   → values.profile.first_name
     */
    shared?: string;

    /**
     * Optional grouping identifier used to group related controls
     * (e.g. radio groups, segmented inputs).
     */
    groupId?: string;

    /**
     * Optional alias for error / mapping purposes.
     *
     * Example:
     *   alias="email" but name="contact.email"
     */
    alias?: string;

    /**
     * Marks this field as the "main" one in a group.
     */
    main?: boolean;

    /**
     * If true, this field is ignored by snapshot / some validation
     * flows, but may still exist in the registry.
     */
    ignore?: boolean;

    /**
     * Whether the field is required.
     */
    required?: boolean;

    /**
     * Initial/default value for this field.
     */
    defaultValue?: T;

    /**
     * Initial disabled flag.
     */
    disabled?: boolean;

    /**
     * Initial readOnly flag.
     */
    readOnly?: boolean;

    /**
     * Custom validation hook.
     *
     * Return:
     * - `true`       → valid
     * - `false`      → invalid (no message)
     * - `"message"`  → invalid with explicit message
     */
    validate?: UseFieldValidate<T>;

    /**
     * Optional projector to derive an "original" value from the
     * initial default.
     */
    getOriginalValue?(value: T | undefined): unknown;

    /**
     * Local change hook for the field.
     *
     * This is in addition to the form-level `onChange`.
     */
    onValueChange?(next: T, prev: T, variant: string): void;

    onSubmit?(e: any): any;
}

export interface UseFieldReturn<T = unknown> {
    /** Ref to the underlying DOM element */
    ref: React.RefObject<HTMLElement>;
    key: string;
    /** Current value */
    value: T | undefined;
    setValue(next: T | undefined, variant?: string): void;

    /** Current error message */
    error: string;
    setError(message: string): void;

    /** Async-loading flag (e.g. remote validation) */
    loading: boolean;
    setLoading(loading: boolean): void;

    /** Required flag */
    required: boolean;
    setRequired(required: boolean): void;

    /** Disabled flag */
    disabled: boolean;
    setDisabled(disabled: boolean): void;

    /** Readonly flag */
    readOnly: boolean;
    setReadOnly(readOnly: boolean): void;

    /** Metadata / wiring */
    name: string;
    bindId: string;
    bind?: string;
    shared?: string;
    groupId?: string;
    alias?: string;
    main?: boolean;
    ignore?: boolean;

    /** Snapshots */
    readonly defaultValue: T | undefined;
    readonly originalValue: unknown;

    /** Owning core context */
    form: CoreContext<Dict>;

    /** Run validation (optionally reporting errors) */
    validate(report?: boolean): boolean | undefined;
}

/**
 * Strict field hook.
 *
 * - Registers the field with the core provider / registry.
 * - Exposes value/error/loading and lifecycle helpers.
 * - Wires into:
 *   - core-level `onChange`
 *   - `controlButton()` dirty logic
 */
export function useField<T = unknown>(
    options: UseFieldOptions<T>,
): UseFieldReturn<T> {
    const form = useCoreContext<Dict>();

    const {
        name: rawName,
        bindId: rawBindId,
        bind,
        shared,
        groupId,
        alias,
        main,
        ignore,
        required: requiredProp = false,
        defaultValue,
        disabled: disabledProp = false,
        readOnly: readOnlyProp = false,
        validate,
        getOriginalValue,
        onValueChange,
        onSubmit,
    } = options;

    const ref = React.useRef<HTMLElement>(null);

    // Core state (value, error, loading, original) lives in a ref
    const stateRef = React.useRef<{
        value: T | undefined;
        error: string;
        loading: boolean;
        original: unknown;
    }>({
        value: defaultValue,
        error: "",
        loading: false,
        original: getOriginalValue
            ? getOriginalValue(defaultValue)
            : defaultValue,
    });

    // React state mirrors (used for rerenders)
    const [value, setValueState] = React.useState<T | undefined>(
        stateRef.current.value,
    );
    const [error, setErrorState] = React.useState<string>(
        stateRef.current.error,
    );
    const [loading, setLoadingState] = React.useState<boolean>(
        stateRef.current.loading,
    );
    const [required, setRequired] = React.useState<boolean>(
        Boolean(requiredProp),
    );
    const [disabled, setDisabled] = React.useState<boolean>(
        Boolean(disabledProp),
    );
    const [readOnly, setReadOnly] = React.useState<boolean>(
        Boolean(readOnlyProp),
    );

    const id = React.useId();
    // Stable wiring keys
    // @ts-ignore
    const keyRef = React.useRef<string>(
        (() => {
            if (rawName && rawName.trim()) return `${rawName.trim()}-${id}`;
            if (rawBindId && rawBindId.trim())
                return `${rawBindId.trim()}-${id}`;
            return `field-${Math.random().toString(36).slice(2)}-${id}`;
        })(),
    ) as React.RefObject<string>;

    const bindIdRef = React.useRef<string>(
        (rawBindId && rawBindId.trim()) || keyRef.current,
    );

    const fieldRef = React.useRef<Field | null>(null);

    // Build the Field object once
    if (!fieldRef.current) {
        const key = keyRef.current;
        const bindId = bindIdRef.current;
        const trimmedName = rawName?.trim() ?? "";

        const validateFn = (report?: boolean): boolean => {
            const formDisabled = false; // core-level disable could be added later
            const curDisabled = formDisabled || disabled || readOnly;

            if (curDisabled && !report) {
                return true;
            }

            const current = stateRef.current.value as T;
            let ok = true;
            let message = "";

            if (
                required &&
                (current === undefined ||
                    current === null ||
                    (typeof current === "string" && current.trim() === "") ||
                    (Array.isArray(current) && current.length === 0))
            ) {
                ok = false;
                message = "This field is required.";
            } else if (validate) {
                const result = validate(
                    current,
                    fieldRef.current!,
                    form,
                    !!report,
                );
                if (typeof result === "string") {
                    ok = false;
                    message = result;
                } else if (!result) {
                    ok = false;
                }
            }

            if (!report) {
                return ok;
            }

            // Report mode → set/clear error
            stateRef.current.error = ok ? "" : message;
            setErrorState(ok ? "" : message);
            return ok;
        };

        const f: Field = {
            key,
            bindId,
            bind,
            name: trimmedName,
            shared,
            groupId,
            alias,
            main,
            ignore,
            required,
            onSubmit,
            ref: ref as React.RefObject<HTMLElement>,
            get defaultValue() {
                return stateRef.current.original;
            },
            get value() {
                return stateRef.current.value;
            },
            set value(v: unknown) {
                stateRef.current.value = v as T | undefined;
                setValueState(v as T | undefined);
            },
            get originalValue() {
                return stateRef.current.original;
            },
            get error() {
                return stateRef.current.error;
            },
            set error(msg: string) {
                stateRef.current.error = msg;
                setErrorState(msg);
            },
            get loading() {
                return stateRef.current.loading;
            },
            set loading(v: boolean) {
                stateRef.current.loading = v;
                setLoadingState(v);
            },
            validate: validateFn,
            onChange(value: unknown, old: unknown, variant: string) {
                if (onValueChange) {
                    onValueChange(value as T, old as T, variant);
                }
            },
            variant: options.variant
            // Flags not directly on the Field interface but used via `as any`
            // in core-provider (getValue/setValue/reset).
        } as Field & {
            getValue(): T | undefined;
            setValue(next: T | undefined): void;
            reset(): void;
        };

        // Imperative helpers used by the core
        (f as any).getValue = () => stateRef.current.value;
        (f as any).setValue = (next: T | undefined) => {
            stateRef.current.value = next;
            setValueState(next);
        };
        (f as any).reset = () => {
            stateRef.current.value = defaultValue;
            stateRef.current.error = "";
            stateRef.current.loading = false;

            setValueState(defaultValue);
            setErrorState("");
            setLoadingState(false);
        };

        fieldRef.current = f;
    }

    const field = fieldRef.current;

    // Sync prop-driven flags when they change
    React.useEffect(() => {
        setRequired(requiredProp);
        if (field) {
            field.required = requiredProp;
        }
    }, [requiredProp, field]);

    React.useEffect(() => {
        setDisabled(disabledProp);
    }, [disabledProp]);

    React.useEffect(() => {
        setReadOnly(readOnlyProp);
    }, [readOnlyProp]);

    // Register field with the core
    React.useEffect(() => {
        if (!field) return;

        form.addField(field);

        return () => {
            // Remove from registry directly
            const registry = form.inputs as any;
            if (registry && typeof registry.remove === "function") {
                registry.remove(field.key);
            }
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [form, field]);

    // Value setter that wires into form-level change + button control
    function setValue(next: T | undefined, variant: string = "direct") {
        const prev = stateRef.current.value as T | undefined;
        if (Object.is(prev, next)) return;

        const runFormOnChange = () => {
            const props: any = form.props ?? {};
            const fn = props.onChange as
                | ((
                      form: CoreContext<Dict>,
                      current: Field,
                      options: Dict,
                  ) => void)
                | undefined;

            if (!fn) return;

            fn(form as any, field, {
                variant,
                value: next,
                previous: prev,
            });
        };

        const props: any = form.props ?? {};
        const changeBefore = !!props.changeBefore;

        if (changeBefore) {
            runFormOnChange();
        }

        stateRef.current.value = next;
        setValueState(next);

        // Local field-level onChange
        if (field.onChange) {
            field.onChange(next, prev, variant);
        }

        if (!changeBefore) {
            runFormOnChange();
        }

        // Let the core adjust the active button’s disabled state
        form.controlButton();
    }

    function setError(message: string) {
        stateRef.current.error = message;
        setErrorState(message);
    }

    function setLoading(loading: boolean) {
        stateRef.current.loading = loading;
        setLoadingState(loading);
    }

    return {
        ref: ref as React.RefObject<HTMLElement>,
        get key() {
            return keyRef.current!;
        },
        value,
        setValue,
        error,
        setError,
        loading,
        setLoading,
        required,
        setRequired,
        disabled,
        setDisabled,
        readOnly,
        setReadOnly,
        name: field.name!,
        bindId: field.bindId!,
        bind: field.bind,
        shared: field.shared,
        groupId: field.groupId,
        alias: field.alias,
        main: field.main,
        ignore: field.ignore,
        get defaultValue() {
            return stateRef.current.original as T | undefined;
        },
        get originalValue() {
            return stateRef.current.original;
        },
        form,
        validate(report?: boolean) {
            return field.validate?.(report);
        },
    };
}
```

---
#### 20


` File: packages/form-palette/src/core/hooks/use-optional-field.ts`  [↑ Back to top](#index)

```ts
// src/core/hooks/use-optional-field.ts
// noinspection GrazieInspection
import * as React from "react";
import {
    useField,
    type UseFieldOptions,
    type UseFieldReturn,
} from "@/core/hooks/use-field";
import type { CoreContext, Dict } from "@/schema/core";

/**
 * Optional variant of `useField`.
 *
 * - If there is a CoreProvider, behaves like `useField`.
 * - If not, it becomes a self-managed field (value/error/loading/etc).
 */
export function useOptionalField<T = unknown>(
    options: UseFieldOptions<T>
): UseFieldReturn<T> {
    // Try strict core-bound field first.
    try {
        return useField<T>(options);
    } catch {
        // Fall through to self-managed mode.
    }

    // --- Self-managed fallback (no CoreProvider) ---

    if (process.env.NODE_ENV !== "production") {
        // eslint-disable-next-line no-console
        console.warn(
            "[FormPalette] useOptionalField: No CoreProvider found. " +
            "Running in self-managed mode."
        );
    }

    const {
        name: rawName,
        bindId: rawBindId,
        bind,
        shared,
        groupId,
        alias,
        main,
        ignore,
        required: requiredProp = false,
        defaultValue,
        disabled: disabledProp = false,
        readOnly: readOnlyProp = false,
        validate,
        getOriginalValue,
        onValueChange,
    } = options;

    const ref = React.useRef<HTMLElement>(null);

    const [value, setValueState] = React.useState<T | undefined>(defaultValue);
    const [error, setErrorState] = React.useState<string>("");
    const [loading, setLoadingState] = React.useState<boolean>(false);
    const [required, setRequired] = React.useState<boolean>(requiredProp);
    const [disabled, setDisabled] = React.useState<boolean>(disabledProp);
    const [readOnly, setReadOnly] = React.useState<boolean>(readOnlyProp);

    const originalRef = React.useRef<unknown>(
        getOriginalValue
            ? getOriginalValue(defaultValue as T | undefined)
            : defaultValue
    );

    const id = React.useId();

    const keyRef = React.useRef<string>("");
    if (!keyRef.current) {
        if (rawName && rawName.trim()) {
            keyRef.current = `${rawName.trim()}-${id}`;
        } else if (rawBindId && rawBindId.trim()) {
            keyRef.current = `${rawBindId.trim()}-${id}`;
        } else {
            keyRef.current = `field-${Math.random()
                .toString(36)
                .slice(2)}-${id}`;
        }
    }

    const bindIdRef = React.useRef<string>("");
    if (!bindIdRef.current) {
        bindIdRef.current = (rawBindId && rawBindId.trim()) || keyRef.current;
    }

    // Keep prop-driven flags in sync
    React.useEffect(() => {
        setRequired(requiredProp);
    }, [requiredProp]);

    React.useEffect(() => {
        setDisabled(disabledProp);
    }, [disabledProp]);

    React.useEffect(() => {
        setReadOnly(readOnlyProp);
    }, [readOnlyProp]);

    function setValue(next: T | undefined, variant: string = "direct") {
        const prev = value;
        if (Object.is(prev, next)) return;

        setValueState(next);

        if (onValueChange) {
            onValueChange(next as T, prev as T, variant);
        }
    }

    function setError(message: string) {
        setErrorState(message);
    }

    function setLoading(next: boolean) {
        setLoadingState(next);
    }

    function runValidate(report?: boolean): boolean {
        const current = value as T;
        let ok = true;
        let message = "";

        if (
            required &&
            (current === undefined ||
                current === null ||
                (typeof current === "string" && current.trim() === "") ||
                (Array.isArray(current) && current.length === 0))
        ) {
            ok = false;
            message = "This field is required.";
        } else if (validate) {
            const result = validate(current, undefined, undefined, !!report);
            if (typeof result === "string") {
                ok = false;
                message = result;
            } else if (!result) {
                ok = false;
            }
        }

        if (report) {
            setErrorState(ok ? "" : message);
        }

        return ok;
    }

    // Minimal stub so callers can safely access `field.form`
    const dummyForm = {} as CoreContext<Dict>;

    return {
        ref: ref as React.RefObject<HTMLElement>,
        get key() {
            return keyRef.current;
        },
        value,
        setValue,
        error,
        setError,
        loading,
        setLoading,
        required,
        setRequired,
        disabled,
        setDisabled,
        readOnly,
        setReadOnly,
        name: rawName?.trim() ?? "",
        bindId: bindIdRef.current,
        bind,
        shared,
        groupId,
        alias,
        main,
        ignore,
        get defaultValue() {
            return originalRef.current as T | undefined;
        },
        get originalValue() {
            return originalRef.current;
        },
        form: dummyForm,
        validate(report?: boolean) {
            return runValidate(report);
        },
    };
}
```

---
#### 21


` File: packages/form-palette/src/core/index.ts`  [↑ Back to top](#index)

```ts
export * from './adapter-registry';

export { CoreProvider } from './core-provider'
export { CoreShell as Form, type CoreShellProps } from './core-shell'
export { CoreRoot as FormRoot } from './core-root'

export * from './hooks/use-button';
export * from './hooks/use-core';
export * from './hooks/use-core-context';
export * from './hooks/use-field';
export * from './hooks/use-optional-field'
export * from './errors'
```

---
#### 22


` File: packages/form-palette/src/core/registry/binder-registry.ts`  [↑ Back to top](#index)

```ts
// src/core/registry/binder-registry.ts
// noinspection JSUnusedGlobalSymbols

import type { Dict } from "@/schema/core";
import type { Field } from "@/schema/field";
import type { BindHost } from "@/core/bound/bind-host";
import {
    getBoundField,
    hasBoundField,
    readBoundValue,
    setBoundValue,
    setBoundError,
    validateBoundField,
    observeBoundField,
} from "@/core/bound/observe-bound-field";
import { waitForBoundField } from "@/core/bound/wait-for-bound-field";

/**
 * BinderRegistry: bound-field utilities for a given host (CoreContext or FieldRegistry).
 *
 * - Hosts must satisfy BindHost (getBind + optional controlButton).
 * - FieldRegistry already does (via getBind() we added).
 * - CoreContext also does.
 *
 * You typically access this via:
 *   form.inputs.binding  // where inputs is a FieldRegistry
 */
export class BinderRegistry<V extends Dict = Dict> {
    constructor(private readonly host: BindHost<V>) {}

    /** Raw field access. */
    get(bindId: string): Field | undefined {
        return getBoundField(this.host, bindId);
    }

    has(bindId: string): boolean {
        return hasBoundField(this.host, bindId);
    }

    /** Read current value. */
    value<T = unknown>(bindId: string): T | undefined {
        return readBoundValue<T, V>(this.host, bindId);
    }

    /** Set value (and trigger controlButton / onChange). */
    set<T = unknown>(
        bindId: string,
        value: T,
        variant: string = "util"
    ): boolean {
        return setBoundValue<T, V>(this.host, bindId, value, variant);
    }

    /** Set error message on the bound field. */
    error(bindId: string, msg: string): boolean {
        return setBoundError<V>(this.host, bindId, msg);
    }

    /** Run the field’s own validate(). */
    validate(bindId: string, report = true): boolean {
        return validateBoundField<V>(this.host, bindId, report);
    }

    /** Observe a bound field’s value/error and liveness. */
    observe<T = unknown>(
        bindId: string,
        handler: (evt: {
            exists: boolean;
            field?: Field;
            value?: T;
            error?: string;
        }) => void,
        pollMs = 300
    ): () => void {
        return observeBoundField<T, V>(this.host, bindId, handler, pollMs);
    }

    /** Wait for a bound field to appear. */
    wait(bindId: string, timeoutMs = 5000): Promise<Field> {
        return waitForBoundField<V>(this.host, bindId, timeoutMs);
    }
}
```

---
#### 23


` File: packages/form-palette/src/core/registry/field-registry.ts`  [↑ Back to top](#index)

```ts
// src/core/registry/field-registry.ts

import type { Field } from "@/schema/field";
import { BinderRegistry } from "@/core/registry/binder-registry";

/**
 * Runtime helper: check if a DOM node is currently attached.
 *
 * Guards against SSR or test environments where document may not exist.
 */
export function isInDom(node: Element | null | undefined): boolean {
    if (!node || !(node instanceof Node)) return false;
    if (typeof document === "undefined") return false;
    return document.body.contains(node);
}

/**
 * Central store for all fields registered with the core runtime.
 *
 * Goals:
 * - Keep stable Field references (no cloning).
 * - Prefer mounted fields for all “get” operations.
 * - Prune stale/detached fields opportunistically.
 */
export class FieldRegistry {
    private list: Field[] = [];
    #binding: BinderRegistry | undefined;

    // ─────────────────────────────────────────────────────────
    // internals
    // ─────────────────────────────────────────────────────────

    private getEl(field: Field): Element | null {
        const anyField = field as any;
        const el = anyField?.ref?.current as Element | null | undefined;
        return el ?? null;
    }

    /** Mounted = has an element and that element is currently in the DOM. */
    private isMounted(field: Field): boolean {
        return isInDom(this.getEl(field));
    }

    /**
     * Detached = has an element but it is NOT currently in the DOM.
     * Note: if ref.current is null, we treat it as “unknown” (do NOT prune).
     */
    private isDetached(field: Field): boolean {
        const el = this.getEl(field);
        return !isInDom(el);
    }

    /** Mounted-first stable ordering (does not mutate input). */
    private sortMountedFirst(fields: Field[]): Field[] {
        if (fields.length <= 1) return fields.slice();
        return fields
            .slice()
            .sort(
                (a, b) => Number(this.isMounted(b)) - Number(this.isMounted(a))
            );
    }

    /** Prefer the first mounted candidate; else fall back to first candidate. */
    private pickPreferred(fields: Field[]): Field | undefined {
        if (!fields.length) return undefined;
        const mounted = fields.find((f) => this.isMounted(f));
        return mounted ?? fields[0];
    }

    /**
     * Remove detached fields.
     *
     * IMPORTANT: We only remove entries that have a non-null ref.current AND are
     * not in the DOM. We do not remove “unknown” (null-ref) fields because they
     * may be in the process of mounting.
     */
    private pruneDetached(): void {
        if (!this.list.length) return;
        this.list = this.list.filter((f) => !this.isDetached(f));
    }

    /**
     * Remove detached fields that conflict with an incoming field by identifier.
     * This prevents stale “same-name / same-bindId / same-groupId” entries from
     * hijacking lookups.
     */
    private pruneDetachedConflicts(incoming: Field): void {
        const anyIncoming = incoming as any;

        const name = (incoming.name ?? "").trim();
        const bindId = (anyIncoming.bindId as string | undefined) ?? "";
        const groupId = (anyIncoming.groupId as string | undefined) ?? "";

        if (!name && !bindId && !groupId) return;

        this.list = this.list.filter((f) => {
            if (!this.isDetached(f)) return true;

            const anyF = f as any;
            const fName = (f.name ?? "").trim();

            const sameName = !!name && fName === name;
            const sameBind = !!bindId && anyF.bindId === bindId;
            const sameGroup = !!groupId && anyF.groupId === groupId;

            // If it matches any identifier and is detached → prune it.
            return !(sameName || sameBind || sameGroup);
        });
    }

    /**
     * Whether this field should be tracked at all.
     *
     * We require at least one of: name, bindId, groupId.
     */
    hasIdentifier(field: Field): boolean {
        const anyField = field as any;
        const name = (field.name ?? "").trim();
        return !!(name || anyField.bindId || anyField.groupId);
    }

    // ─────────────────────────────────────────────────────────
    // mutations
    // ─────────────────────────────────────────────────────────

    /**
     * Add a field to the registry if it has an identifier.
     *
     * Rules:
     * - Opportunistically prune detached fields.
     * - Prune detached conflicts (same name/bindId/groupId) before adding.
     * - If the same field instance is already tracked, ignore.
     * - If the same key already exists (rare), prefer mounted; otherwise replace.
     */
    add(field: Field): void {
        if (!this.hasIdentifier(field)) return;

        // Keep the list clean as fields remount/unmount.
        this.pruneDetached();

        // Remove stale entries that would conflict with lookups.
        this.pruneDetachedConflicts(field);

        // Same instance? do nothing.
        if (this.list.includes(field)) return;

        const incomingKey = (field as any)?.key as string | undefined;

        // If a field with the same key exists, prefer mounted one.
        if (incomingKey) {
            const idx = this.list.findIndex(
                (f) => (f as any)?.key === incomingKey
            );
            if (idx !== -1) {
                const existing = this.list[idx];
                const existingMounted = this.isMounted(existing);
                const incomingMounted = this.isMounted(field);

                // Prefer mounted; if neither mounted, prefer the incoming (newer).
                if (existingMounted && !incomingMounted) return;
                this.list[idx] = field;
                return;
            }
        }

        this.list.push(field);
    }

    /**
     * Remove a field from the registry.
     */
    remove(field: Field): void {
        const idx = this.list.indexOf(field);
        if (idx === -1) return;
        this.list.splice(idx, 1);
    }

    /**
     * Clear all tracked fields.
     */
    clear(): void {
        this.list = [];
    }

    // ─────────────────────────────────────────────────────────
    // accessors (mounted-preferred)
    // ─────────────────────────────────────────────────────────

    /**
     * All fields tracked by this registry (mounted-first).
     */
    all(): Field[] {
        // Keep list tidy when reading too.
        this.pruneDetached();
        return this.sortMountedFirst(this.list);
    }

    /** All fields that have a non-empty name (mounted-first). */
    getAllNamed(): Field[] {
        this.pruneDetached();
        return this.sortMountedFirst(
            this.list.filter((f) => !!(f.name && f.name.trim().length > 0))
        );
    }

    /** All fields that have a bindId (mounted-first). */
    getAllBound(): Field[] {
        this.pruneDetached();
        return this.sortMountedFirst(
            this.list.filter((f) => (f as any).bindId)
        );
    }

    /** All fields that have a groupId (mounted-first). */
    getAllGrouped(): Field[] {
        this.pruneDetached();
        return this.sortMountedFirst(
            this.list.filter((f) => (f as any).groupId)
        );
    }

    // ─────────────────────────────────────────────────────────
    // name-based lookups (prefer mounted)
    // ─────────────────────────────────────────────────────────

    /**
     * First field with a given name (exact, trimmed match).
     *
     * Behaviour:
     * - Prefer a field whose ref is currently in the DOM.
     * - If none are mounted, fall back to the first matching field.
     */
    getByName(name: string): Field | undefined {
        if (!name) return undefined;
        const target = name.trim();
        if (!target) return undefined;

        this.pruneDetached();

        const candidates = this.list.filter(
            (f) => (f.name ?? "").trim() === target
        );
        return this.pickPreferred(candidates);
    }

    /**
     * All fields with a given name (exact, trimmed match), mounted-first.
     */
    getAllByName(name: string): Field[] {
        if (!name) return [];
        const target = name.trim();
        if (!target) return [];

        this.pruneDetached();

        return this.sortMountedFirst(
            this.list.filter((f) => (f.name ?? "").trim() === target)
        );
    }

    // ─────────────────────────────────────────────────────────
    // groupId-based lookups (prefer mounted)
    // ─────────────────────────────────────────────────────────

    /** First field with the given groupId (prefer mounted). */
    getByGroupId(id: string): Field | undefined {
        if (!id) return undefined;

        this.pruneDetached();

        const candidates = this.list.filter((f) => (f as any).groupId === id);
        return this.pickPreferred(candidates);
    }

    /** All fields with the given groupId (mounted-first). */
    getAllByGroupId(id: string): Field[] {
        if (!id) return [];

        this.pruneDetached();

        return this.sortMountedFirst(
            this.list.filter((f) => (f as any).groupId === id)
        );
    }

    // ─────────────────────────────────────────────────────────
    // bindId-based lookups (prefer mounted)
    // ─────────────────────────────────────────────────────────

    /**
     * All fields that share the given bindId (mounted-first).
     */
    getAllByBind(id: string): Field[] {
        if (!id) return [];

        this.pruneDetached();

        return this.sortMountedFirst(
            this.list.filter((f) => (f as any).bindId === id)
        );
    }

    /**
     * First field with the given bindId (prefer mounted).
     */
    getByBind(id: string): Field | undefined {
        if (!id) return undefined;

        const candidates = this.getAllByBind(id);
        return this.pickPreferred(candidates);
    }

    getBind(id: string): Field | undefined {
        return this.getByBind(id);
    }

    get binding(): BinderRegistry {
        if (!(this.#binding instanceof BinderRegistry)) {
            this.#binding = new BinderRegistry(this);
        }
        return this.#binding;
    }
}
```

---
#### 24


` File: packages/form-palette/src/index.ts`  [↑ Back to top](#index)

```ts
// src/index.ts

// ─────────────────────────────────────────────────────────────
// Schema exports (types only)
// ─────────────────────────────────────────────────────────────

// TS 5.x+ — keep these as type-only to avoid runtime cycles & noise.
export type * from "@/schema/core";
export type * from "@/schema/adapter";
export type * from "@/schema/field";
export type * from "@/schema/input-field";
export type * from "@/schema/variant";

// ─────────────────────────────────────────────────────────────
// Core runtime: provider + shell/root
// ─────────────────────────────────────────────────────────────

export * from './core'
// ─────────────────────────────────────────────────────────────
// Errors / helpers
// ─────────────────────────────────────────────────────────────

// ─────────────────────────────────────────────────────────────
// Input layer
// ─────────────────────────────────────────────────────────────

export * from "@/input";

// ─────────────────────────────────────────────────────────────
// Variants & registry
// ─────────────────────────────────────────────────────────────

export { registerVariant, getVariant, listVariants } from "@/variants/registry";

export { registerCoreVariants } from "@/variants"; // if you have a convenience registrar there

export { Textarea } from "@/presets/ui/textarea";
export { InputMask } from './presets/ui/input-mask';
export { InputNumber } from './presets/ui/number';
export { Input } from '@/presets/ui/input';
// ─────────────────────────────────────────────────────────────
// Adapters
// ─────────────────────────────────────────────────────────────

export * from "@/adapters";

export { registerPaletteUtil, getPaletteUtil } from "@/lib/register-global";
```

---
#### 25


` File: packages/form-palette/src/input/index.ts`  [↑ Back to top](#index)

```ts
// src/input/index.ts

export type { InputFieldProps, InputFieldBaseProps } from "@/input/input-props";
export { InputField } from "@/input/input-field";
```

---
#### 26


` File: packages/form-palette/src/input/input-field.tsx`  [↑ Back to top](#index)

```tsx
// src/input/input-field.tsx
// noinspection JSUnusedLocalSymbols,SpellCheckingInspection,DuplicatedCode

import * as React from "react";

import type {
    InputFieldClassNameProps,
    InputFieldClassNames,
    InputFieldProps,
} from "@/input/input-props";
import type {
    FieldLayoutConfig,
    LayoutResolveContext,
    SlotPlacement,
    ValidateResult,
} from "@/schema/input-field";
import type { VariantKey, VariantValueFor } from "@/schema/variant";
import { getVariant } from "@/variants";

import {
    Field as UiField,
    FieldContent,
    FieldDescription,
    FieldError,
    FieldGroup,
    FieldLabel,
    FieldTitle,
} from "@/presets/ui/field";
import { ChangeDetail } from "@/variants/shared";
import { buildLayoutGraph, type HelperSlot } from "@/input/input-layout-graph";
import { cn } from "@/lib/utils";
import { useOptionalField } from "@/core";

/**
 * Normalise a ValidateResult into an array of error messages.
 */
function normalizeValidateResult(result: ValidateResult): string[] {
    if (result === undefined || result === null || result === true) return [];
    if (result === false) return ["Invalid value."];
    if (typeof result === "string") return result ? [result] : [];
    if (Array.isArray(result)) return result.filter(Boolean);
    return [];
}

/**
 * Build the layout for this field using:
 * - variant defaults
 * - host overrides
 * - optional variant-level resolveLayout()
 */
function resolveLayoutForField(
    defaults: FieldLayoutConfig | undefined,
    overrides: Partial<FieldLayoutConfig>,
    props: unknown,
    variantResolve?: (ctx: LayoutResolveContext) => FieldLayoutConfig,
): FieldLayoutConfig {
    const base: FieldLayoutConfig = defaults ? { ...defaults } : {};

    if (variantResolve) {
        return variantResolve({
            defaults: base,
            overrides,
            props,
        });
    }

    // Fallback: shallow merge defaults + overrides
    return {
        ...base,
        ...overrides,
    };
}

/**
 * Render a single helper slot using the Shadcn field primitives.
 */
function renderHelperSlot(
    root: "label" | "input",
    slot: HelperSlot,
    classes: any,
): React.ReactNode {
    const placement: SlotPlacement = slot.placement;

    switch (slot.id) {
        case "sublabel":
            return (
                <FieldDescription
                    key={`sublabel-${placement}-${root}`}
                    className={cn(
                        "text-xs text-muted-foreground",
                        classes?.sublabel,
                    )}
                    data-slot={`sublabel-${placement}`}
                >
                    {slot.content}
                </FieldDescription>
            );

        case "description":
            return (
                <FieldDescription
                    key={`description-${placement}-${root}`}
                    className={cn(
                        "text-xs text-muted-foreground",
                        classes?.description,
                    )}
                    data-slot={`description-${placement}`}
                >
                    {slot.content}
                </FieldDescription>
            );

        case "helpText":
            return (
                <FieldDescription
                    key={`helpText-${placement}-${root}`}
                    className={cn(
                        "text-xs text-muted-foreground",
                        classes?.helpText,
                    )}
                    data-slot={`helptext-${placement}`}
                >
                    {slot.content}
                </FieldDescription>
            );

        case "errorText":
            return (
                <FieldError
                    key={`error-${placement}-${root}`}
                    className={cn("text-xs text-destructive", classes?.error)}
                    data-slot={`error-${placement}`}
                >
                    {slot.content}
                </FieldError>
            );

        case "tags":
            return (
                <div
                    key={`tags-${placement}-${root}`}
                    className={cn("flex items-center gap-1", classes?.tags)}
                    data-slot={`tags-${placement}`}
                >
                    {slot.content}
                </div>
            );

        default:
            return null;
    }
}

export function getClasses(
    props: InputFieldClassNameProps & {
        className?: string;
        classes?: Partial<InputFieldClassNames>;
    },
): InputFieldClassNames {
    const legacy = props.classes ?? {};

    return {
        root: cn(legacy.root, props.className) || undefined,

        labelRow: cn(legacy.labelRow, props.labelRowClassName) || undefined,
        inlineRow: cn(legacy.inlineRow, props.inlineRowClassName) || undefined,

        label: cn(legacy.label, props.labelClassName) || undefined,
        sublabel: cn(legacy.sublabel, props.sublabelClassName) || undefined,
        description:
            cn(legacy.description, props.descriptionClassName) || undefined,
        helpText: cn(legacy.helpText, props.helpTextClassName) || undefined,
        error: cn(legacy.error, props.errorClassName) || undefined,

        group: cn(legacy.group, props.groupClassName) || undefined,
        content: cn(legacy.content, props.contentClassName) || undefined,
        variant: cn(legacy.variant, props.variantClassName) || undefined,

        inlineInputColumn:
            cn(legacy.inlineInputColumn, props.inlineInputColumnClassName) ||
            undefined,
        inlineLabelColumn:
            cn(legacy.inlineLabelColumn, props.inlineLabelColumnClassName) ||
            undefined,

        required: cn(legacy.required, props.requiredClassName) || undefined,
        tag: cn(legacy.tag, props.tagClassName) || undefined,
    };
}

/**
 * Public InputField component.
 *
 * - Uses `useField` to register a Field and manage value/error/loading.
 * - Delegates rendering to the chosen variant's `Variant` component.
 * - Uses Shadcn's Field primitives for structure.
 * - Lets variants influence layout via defaults + optional resolveLayout().
 * - Uses a layout graph (buildLayoutGraph) + getSlotsFor().render(...) to
 *   position helpers (sublabel, description, helpText, error, tags) relative to
 *   "label" vs "input" roots without empty wrapper divs.
 */
export function InputField<K extends VariantKey = VariantKey>(
    props: InputFieldProps<K>,
) {
    const {
        variant,
        onSubmit,

        // Field identity / wiring
        name,
        bind,
        shared,
        groupId,
        alias,
        main,
        ignore,
        required,
        defaultValue,

        // Chrome
        label,
        sublabel,
        description,
        helpText,
        errorText,
        autoOff,

        // Container + tags
        contain,
        tags,
        tagPlacement,

        // Layout overrides
        labelPlacement,
        sublabelPlacement,
        descriptionPlacement,
        helpTextPlacement,
        errorTextPlacement,
        inline,
        fullWidth,
        size,
        density,

        // Validation hook
        onValidate,
        onChange,

        // Field wrapper props
        className,
        style,
        classes: _depreciated,

        // Everything else → forwarded to variant
        ...rest
    } = props as InputFieldProps & {
        className?: string;
        style?: React.CSSProperties;
    };

    const module = getVariant(variant);

    if (!module) {
        if (process.env.NODE_ENV !== "production") {
            // eslint-disable-next-line no-console
            console.warn(
                `[form-palette] InputField: variant "${String(
                    variant,
                )}" is not registered.`,
            );
        }
        return null;
    }

    const classes = getClasses(props);

    type TValue = VariantValueFor<K>;

    // Compute layout: defaults + host overrides + optional variant resolver
    const layout = React.useMemo(() => {
        const defaultsLayout = module.defaults?.layout;
        const overrides: Partial<FieldLayoutConfig> = {};

        if (labelPlacement !== undefined) {
            overrides.labelPlacement = labelPlacement;
        }
        if (sublabelPlacement !== undefined) {
            overrides.sublabelPlacement = sublabelPlacement;
        }
        if (descriptionPlacement !== undefined) {
            overrides.descriptionPlacement = descriptionPlacement;
        }
        if (helpTextPlacement !== undefined) {
            overrides.helpTextPlacement = helpTextPlacement;
        }
        if (errorTextPlacement !== undefined) {
            overrides.errorTextPlacement = errorTextPlacement;
        }
        if (tagPlacement !== undefined) {
            overrides.tagPlacement = tagPlacement;
        }
        if (inline !== undefined) {
            overrides.inline = inline;
        }
        if (fullWidth !== undefined) {
            overrides.fullWidth = fullWidth;
        }

        return resolveLayoutForField(
            defaultsLayout,
            overrides,
            props,
            module.resolveLayout as any,
        );
    }, [
        module,
        labelPlacement,
        sublabelPlacement,
        descriptionPlacement,
        helpTextPlacement,
        errorTextPlacement,
        tagPlacement,
        inline,
        fullWidth,
        props,
    ]);

    const effectiveSize =
        size ?? module.defaults?.layout?.defaultSize ?? undefined;
    const effectiveDensity =
        density ?? module.defaults?.layout?.defaultDensity ?? undefined;

    /**
     * Validation callback used by the field hook.
     *
     * It combines:
     * - variant-level validation (module.validate)
     * - per-field validation (props.onValidate)
     */
    const validate = React.useCallback(
        (
            value: TValue | undefined,
            field: any,
            form: any,
            _report: boolean,
        ): boolean | string => {
            const messages: string[] = [];

            if (module.validate) {
                const res = module.validate(value, {
                    required: !!required,
                    props: props as any,
                    field: field as any,
                    form: form as any,
                });
                messages.push(...normalizeValidateResult(res));
            }

            if (onValidate) {
                const res = onValidate(value as any, field as any, form as any);
                messages.push(...normalizeValidateResult(res));
            }

            if (!messages.length) return true;
            return messages[0] ?? "Invalid value.";
        },
        [module, required, onValidate, props],
    );

    // Hook into the core: register field, track value/error/loading
    const field = useOptionalField<TValue>({
        name,
        bind,
        shared,
        groupId,
        alias,
        main,
        ignore,
        onSubmit,
        variant,
        required,
        defaultValue: defaultValue as TValue | undefined,
        validate,
    } as any);

    const { value, setValue, error, ref, key } = field;

    const Variant = module.Variant as React.ComponentType<any>;
    const visualError = (errorText ?? error) || "";

    /**
     * Central change handler for this field.
     *
     * Flow:
     *   Variant.onValue(next, detail) →
     *   InputField.handleValueChange →
     *   props.onChange?.({ value, detail, event, preventDefault }) →
     *   (if not prevented) setValue(final)
     */
    const handleValueChange = React.useCallback(
        (next: TValue | undefined, detail?: ChangeDetail) => {
            let finalValue = next;
            let defaultPrevented = false;

            if (onChange) {
                const e = {
                    value: next,
                    preventDefault() {
                        defaultPrevented = true;
                    },
                    get isDefaultPrevented() {
                        return defaultPrevented;
                    },
                    event: detail?.nativeEvent as
                        | React.SyntheticEvent
                        | undefined,
                    detail: detail as ChangeDetail,
                };

                onChange(e);

                // If the handler returns a value, use it instead of `next`.
                finalValue = e.value;
                if (defaultPrevented) {
                    // Host took control and blocked the core update.
                    return;
                }
            }

            // NOTE: Second argument is an optional "source" tag.
            // If your setValue only accepts one arg, drop `String(variant)`.
            (setValue as any)(finalValue, String(variant));
        },
        [onChange, setValue, variant],
    );

    const disabledProp = (rest as any).disabled;
    const readOnlyProp = (rest as any).readOnly;

    // Convenience shorthands for layout
    const lp = layout.labelPlacement;
    const sp = layout.sublabelPlacement;
    const dp = layout.descriptionPlacement;
    const hp = layout.helpTextPlacement;
    const ep = layout.errorTextPlacement;
    const tp = layout.tagPlacement;

    const isInline = !!layout.inline;
    const isCompactInline = isInline && layout.fullWidth === false;

    const rootClassName = cn(
        "gap-1",
        contain && !inline && "rounded-xl border border-border bg-background",
        classes?.root,
        className,
    );

    // Variant-level className merge (host + classes.variant)
    const hostVariantClass = (rest as any).className as string | undefined;

    const mergedVariantClass =
        cn(
            // In compact inline mode, force the control to size to its content
            isCompactInline && "inline-flex w-auto",
            hostVariantClass,
            classes?.variant,
        ) || undefined;

    // Build tags content cluster (individual pills)
    const tagsContent = React.useMemo(() => {
        const items = (tags ?? []) as any[];

        if (!items.length) return null;

        return (
            <>
                {items.map((tag, index) => (
                    <span
                        key={index}
                        className={cn(
                            "inline-flex items-center gap-1 rounded-full px-3 py-1 text-xs font-medium",
                            tag.className,
                            classes?.tag,
                        )}
                        style={{
                            color: tag.color,
                            backgroundColor: tag.bgColor,
                        }}
                    >
                        {tag.icon && (
                            <span className="shrink-0">{tag.icon}</span>
                        )}
                        <span>{tag.label}</span>
                    </span>
                ))}
            </>
        );
    }, [tags, classes?.tag]);

    // Build helper layout graph for this field
    const graph = React.useMemo(
        () =>
            buildLayoutGraph({
                layout,
                sublabel,
                description,
                helpText,
                errorText: visualError || undefined,
                tags: tagsContent || undefined,
            }),
        [layout, sublabel, description, helpText, visualError, tagsContent],
    );

    // Detect whether there are any label-root slots so we don't render empty rows/spacing
    const hasLabelSlotsAt = (placement: SlotPlacement): boolean => {
        let found = false;

        graph.getSlotsFor("label", placement).render((slots: HelperSlot[]) => {
            if (slots.length > 0) {
                found = true;
            }
            return null;
        });

        return found;
    };

    const hasLabelLeftSlots = hasLabelSlotsAt("left");
    const hasLabelRightSlots = hasLabelSlotsAt("right");
    const hasLabelAboveSlots = hasLabelSlotsAt("above");
    const hasLabelBelowSlots = hasLabelSlotsAt("below");

    // Any content that belongs to the label *block* at all
    const hasAnyLabelBlockContent =
        !!label ||
        hasLabelLeftSlots ||
        hasLabelRightSlots ||
        hasLabelAboveSlots ||
        hasLabelBelowSlots;

    // Content that specifically lives inside the label "row"
    const hasLabelRowContent =
        !!label || hasLabelLeftSlots || hasLabelRightSlots;

    // ─────────────────────────────────────────────────────
    // INLINE LAYOUT
    // ─────────────────────────────────────────────────────

    // In inline mode, label can effectively be left / right / hidden.
    const inlineLabelSide: "left" | "right" | "hidden" =
        lp === "right" ? "right" : lp === "hidden" ? "hidden" : "left";

    // Width semantics for inline:
    // - compact inline (fullWidth === false) → input column is content-sized
    // - normal inline                     → input grows, label minimal
    const inlineInputColClass = cn(
        "flex flex-col",
        isCompactInline ? "flex-none" : "flex-1 min-w-0",
        classes?.inlineInputColumn,
    );

    const inlineLabelColClass = cn(
        isCompactInline ? "flex-1 min-w-0" : "min-w-0",
        classes?.inlineLabelColumn,
    );

    const inlineFieldGroupClass = isCompactInline
        ? cn(
              // compact, content-sized group
              "inline-flex w-auto",
              // kill the Shadcn container on this group in compact-inline mode
              "[container-type:normal]",
              "[container-name:none]",
              classes?.group,
          )
        : (classes?.group ?? undefined);

    const inlineFieldContentClass = isCompactInline
        ? cn("flex-none w-auto", classes?.content)
        : cn("w-full", classes?.content);

    const inlineInputColumn = (
        <div className={inlineInputColClass}>
            {/* Above input (input root) */}
            {graph
                .getSlotsFor("input", "above")
                .render((slots) =>
                    slots.map((slot) =>
                        renderHelperSlot("input", slot, classes),
                    ),
                )}

            <FieldGroup className={inlineFieldGroupClass}>
                <FieldContent className={inlineFieldContentClass}>
                    <Variant
                        {...(rest as any)}
                        name={autoOff ? undefined : name}
                        id={key}
                        value={value}
                        onValue={handleValueChange}
                        error={error}
                        required={required}
                        disabled={disabledProp}
                        readOnly={readOnlyProp}
                        size={effectiveSize}
                        density={effectiveDensity}
                        className={mergedVariantClass}
                    />
                </FieldContent>
            </FieldGroup>

            {/* Below input (input root) */}
            {graph
                .getSlotsFor("input", "below")
                .render((slots) =>
                    slots.map((slot) =>
                        renderHelperSlot("input", slot, classes),
                    ),
                )}
        </div>
    );

    const inlineLabelColumn =
        inlineLabelSide === "hidden" || !hasAnyLabelBlockContent ? null : (
            <div className={cn("flex flex-col gap-0", inlineLabelColClass)}>
                {/* Above label (label root) */}
                {graph
                    .getSlotsFor("label", "above")
                    .render((slots) =>
                        slots.map((slot) =>
                            renderHelperSlot("label", slot, classes),
                        ),
                    )}

                {hasLabelRowContent && (
                    <div
                        className={cn(
                            "flex items-baseline justify-between gap-1",
                            classes?.labelRow,
                        )}
                        data-slot="label-row"
                    >
                        {/* Left-of-label helpers (label root) */}
                        {graph.getSlotsFor("label", "left").render((slots) => (
                            <div className="flex items-baseline gap-1">
                                {slots.map((slot) =>
                                    renderHelperSlot("label", slot, classes),
                                )}
                            </div>
                        ))}

                        {label && (
                            <FieldLabel
                                htmlFor={key}
                                className={cn(
                                    "text-sm font-medium text-foreground",
                                    classes?.label,
                                )}
                            >
                                <FieldTitle>
                                    {label}{" "}
                                    {required ? (
                                        <span
                                            className={cn(
                                                "text-destructive",
                                                classes?.required,
                                            )}
                                        >
                                            *
                                        </span>
                                    ) : (
                                        ""
                                    )}
                                </FieldTitle>
                            </FieldLabel>
                        )}

                        {/* Right-of-label helpers (label root) */}
                        {graph.getSlotsFor("label", "right").render((slots) => (
                            <div className="flex items-baseline gap-1">
                                {slots.map((slot) =>
                                    renderHelperSlot("label", slot, classes),
                                )}
                            </div>
                        ))}
                    </div>
                )}

                {/* Below label (label root) */}
                {graph
                    .getSlotsFor("label", "below")
                    .render((slots) =>
                        slots.map((slot) =>
                            renderHelperSlot("label", slot, classes),
                        ),
                    )}
            </div>
        );

    const inlineRowClassName = cn(
        "flex gap-2",
        hasLabelAboveSlots || hasLabelBelowSlots
            ? "items-start"
            : "items-center",
        classes?.inlineRow,
    );

    // ─────────────────────────────────────────────────────
    // STACKED LAYOUT
    // ─────────────────────────────────────────────────────

    const hasStackedLabelBlock = lp !== "hidden" && hasAnyLabelBlockContent;

    const stackedGroupClassName = cn(
        hasStackedLabelBlock && hasLabelRowContent && "mt-0.5",
        classes?.group,
    );

    const Element = contain ? "div" : React.Fragment;
    const attrs = (a: "l" | "i" = "l") =>
        contain
            ? a === "l"
                ? { className: "p-4 border-b border-input" }
                : { className: "px-4 pt-2 pb-4" }
            : {};

    return (
        <UiField
            className={rootClassName}
            ref={ref as any}
            style={style}
            data-variant={String(variant)}
            data-label-placement={lp ?? undefined}
            data-sublabel-placement={sp ?? undefined}
            data-description-placement={dp ?? undefined}
            data-helptext-placement={hp ?? undefined}
            data-errortext-placement={ep ?? undefined}
            data-tag-placement={tp ?? undefined}
            data-inline={isInline ? "true" : "false"}
            data-fullwidth={layout.fullWidth ? "true" : "false"}
        >
            {isInline ? (
                // INLINE MODE: label + control on the same row
                <div className={inlineRowClassName} data-slot="inline-row">
                    {inlineLabelSide === "right" ? (
                        <>
                            {inlineInputColumn}
                            {inlineLabelColumn}
                        </>
                    ) : inlineLabelSide === "hidden" ? (
                        <>{inlineInputColumn}</>
                    ) : (
                        <>
                            {inlineLabelColumn}
                            {inlineInputColumn}
                        </>
                    )}
                </div>
            ) : (
                // STACKED MODE
                <>
                    {hasStackedLabelBlock && (
                        <Element {...attrs()}>
                            {/* Above label (label root) */}
                            {graph
                                .getSlotsFor("label", "above")
                                .render((slots) =>
                                    slots.map((slot) =>
                                        renderHelperSlot(
                                            "label",
                                            slot,
                                            classes,
                                        ),
                                    ),
                                )}

                            {hasLabelRowContent && (
                                <div
                                    className={cn(
                                        "flex items-baseline justify-between gap-1",
                                        classes?.labelRow,
                                    )}
                                    data-slot="label-row"
                                >
                                    {/* Left-of-label helpers (label root) */}
                                    {graph
                                        .getSlotsFor("label", "left")
                                        .render((slots) => (
                                            <div className="flex items-baseline gap-1">
                                                {slots.map((slot) =>
                                                    renderHelperSlot(
                                                        "label",
                                                        slot,
                                                        classes,
                                                    ),
                                                )}
                                            </div>
                                        ))}

                                    {label && (
                                        <FieldLabel
                                            htmlFor={key}
                                            className={cn(
                                                "text-sm font-medium text-foreground",
                                                classes?.label,
                                            )}
                                        >
                                            <FieldTitle>
                                                {label}{" "}
                                                {required ? (
                                                    <span
                                                        className={cn(
                                                            "text-destructive",
                                                            classes?.required,
                                                        )}
                                                    >
                                                        *
                                                    </span>
                                                ) : (
                                                    ""
                                                )}
                                            </FieldTitle>
                                        </FieldLabel>
                                    )}

                                    {/* Right-of-label helpers (label root) */}
                                    {graph
                                        .getSlotsFor("label", "right")
                                        .render((slots) => (
                                            <div className="flex items-baseline gap-1">
                                                {slots.map((slot) =>
                                                    renderHelperSlot(
                                                        "label",
                                                        slot,
                                                        classes,
                                                    ),
                                                )}
                                            </div>
                                        ))}
                                </div>
                            )}

                            {/* Below label (label root) */}
                            {graph
                                .getSlotsFor("label", "below")
                                .render((slots) =>
                                    slots.map((slot) =>
                                        renderHelperSlot(
                                            "label",
                                            slot,
                                            classes,
                                        ),
                                    ),
                                )}
                        </Element>
                    )}

                    <Element {...attrs("i")}>
                        {/* Above input (input root) */}
                        {graph
                            .getSlotsFor("input", "above")
                            .render((slots) =>
                                slots.map((slot) =>
                                    renderHelperSlot("input", slot, classes),
                                ),
                            )}

                        <FieldGroup className={stackedGroupClassName}>
                            <FieldContent
                                className={cn("w-full", classes?.content)}
                            >
                                <Variant
                                    {...(rest as any)}
                                    name={autoOff ? undefined : name}
                                    id={key}
                                    value={value}
                                    onValue={handleValueChange}
                                    error={error}
                                    required={required}
                                    disabled={disabledProp}
                                    readOnly={readOnlyProp}
                                    size={effectiveSize}
                                    density={effectiveDensity}
                                    className={mergedVariantClass}
                                />
                            </FieldContent>
                        </FieldGroup>

                        {/* Below input (input root) */}
                        {graph
                            .getSlotsFor("input", "below")
                            .render((slots) =>
                                slots.map((slot) =>
                                    renderHelperSlot("input", slot, classes),
                                ),
                            )}
                    </Element>
                </>
            )}
        </UiField>
    );
}
```

---
#### 27


` File: packages/form-palette/src/input/input-layout-graph.ts`  [↑ Back to top](#index)

```ts
// src/input/input-layout-graph.ts

import * as React from "react";

import type {
    FieldLayoutConfig,
    FieldOrdering,
    FieldRootId,
    FieldSlotId,
    RelativeRootsMap,
    SlotPlacement,
} from "@/schema/input-field";

/**
 * Helper slots are all non-root slots:
 * - sublabel
 * - description
 * - helpText
 * - errorText
 */
export type HelperSlotId = Exclude<FieldSlotId, FieldRootId>;

export interface HelperSlot {
    id: HelperSlotId;
    root: FieldRootId;
    placement: SlotPlacement;
    content: React.ReactNode;
}

/**
 * Accessor for a (root, placement) group.
 *
 * - `slots()` gives you the concrete HelperSlot[] (possibly empty).
 * - `render(fn)` calls `fn(slots)` only if there are slots,
 *   otherwise returns null (so React renders nothing).
 */
export interface SlotAccessor {
    root: FieldRootId;
    placement: SlotPlacement;

    /**
     * Concrete list of slots for this root + placement.
     * May be an empty array.
     */
    slots(): HelperSlot[];

    /**
     * Render this group.
     *
     * If no slots are present, returns null so nothing is rendered.
     *
     * Example:
     *   graph
     *     .getSlotsFor("input", "below")
     *     .render((slots) =>
     *       slots.map((slot) =>
     *         renderHelperSlot("input", slot, classes)
     *       )
     *     );
     */
    render(renderFn: (slots: HelperSlot[]) => React.ReactNode): React.ReactNode;
}

/**
 * Layout graph for helpers.
 */
export interface LayoutGraph {
    helperSlots: HelperSlot[];

    /**
     * Get a slot accessor for a given root + placement.
     */
    getSlotsFor(root: FieldRootId, placement: SlotPlacement): SlotAccessor;
}

/**
 * Default root attachment for helpers when layout.relativeRoots
 * does not specify anything.
 */
const defaultRelativeRoots: RelativeRootsMap = {
    sublabel: "label",
    description: "input",
    helpText: "input",
    errorText: "input",
};

/**
 * Default relative ordering per root when layout.ordering
 * is not provided.
 *
 * Only governs *priority* when multiple helpers share the same
 * root + placement. It does not decide the placement itself.
 */
const defaultOrdering: FieldOrdering = {
    label: ["sublabel"],
    input: ["errorText", "description", "helpText"],
};

function defaultPlacementFor(id: HelperSlotId): SlotPlacement {
    if (id === "sublabel") {
        // Typical: small label text to the right of the main label
        return "right";
    }

    if (id == "tags") return "right";
    // For description/help/error, "below" the root is the usual default
    return "below";
}

interface BuildLayoutGraphArgs {
    layout: FieldLayoutConfig;
    /**
     * Raw contents for each helper slot.
     * Undefined/null means "no slot".
     */
    sublabel?: React.ReactNode;
    description?: React.ReactNode;
    helpText?: React.ReactNode;
    errorText?: React.ReactNode;
    tags?: React.ReactNode;
}

/**
 * Build a layout graph for helper slots given:
 * - the effective layout (after variant defaults + overrides)
 * - the actual content for each slot
 */
export function buildLayoutGraph(args: BuildLayoutGraphArgs): LayoutGraph {
    const { layout, sublabel, description, helpText, errorText, tags } = args;

    const relativeRoots: RelativeRootsMap = {
        ...defaultRelativeRoots,
        ...(layout.relativeRoots ?? {}),
    };

    const ordering: FieldOrdering = {
        ...defaultOrdering,
        ...(layout.ordering ?? {}),
    };

    const helperSlots: HelperSlot[] = [];

    const pushSlot = (
        id: HelperSlotId,
        content: React.ReactNode | undefined,
        placement: SlotPlacement | undefined,
    ) => {
        if (content === undefined || content === null) return;

        const root: FieldRootId =
            relativeRoots[id] ?? ((id === "sublabel" || id == 'tags') ? "label" : "input");

        const effectivePlacement: SlotPlacement =
            placement ?? defaultPlacementFor(id);

        if (effectivePlacement === "hidden") return;

        helperSlots.push({
            id,
            root,
            placement: effectivePlacement,
            content,
        });
    };

    pushSlot("sublabel", sublabel, layout.sublabelPlacement);
    pushSlot("description", description, layout.descriptionPlacement);
    pushSlot("helpText", helpText, layout.helpTextPlacement);
    pushSlot("errorText", errorText, layout.errorTextPlacement);
    pushSlot("tags", tags, layout.tagPlacement);

    function makeAccessor(
        root: FieldRootId,
        placement: SlotPlacement,
    ): SlotAccessor {
        // cache per accessor so multiple .slots()/.render() calls
        // don't keep re-filtering
        let cache: HelperSlot[] | null = null;

        const compute = (): HelperSlot[] => {
            if (cache) return cache;

            const base = helperSlots.filter(
                (s) => s.root === root && s.placement === placement,
            );

            const order = ordering[root] ?? [];
            if (!order.length) {
                cache = base;
                return cache;
            }

            cache = [...base].sort((a, b) => {
                const ai = order.indexOf(a.id);
                const bi = order.indexOf(b.id);

                const aRank = ai === -1 ? Number.POSITIVE_INFINITY : ai;
                const bRank = bi === -1 ? Number.POSITIVE_INFINITY : bi;

                return aRank - bRank;
            });

            return cache;
        };

        return {
            root,
            placement,
            slots: () => compute(),
            render(renderFn) {
                const slots = compute();
                if (!slots.length) return null; // nothing rendered
                return renderFn(slots);
            },
        };
    }

    return {
        helperSlots,
        getSlotsFor(root, placement) {
            return makeAccessor(root, placement);
        },
    };
}
```

---
#### 28


` File: packages/form-palette/src/input/input-props.ts`  [↑ Back to top](#index)

```ts
// src/input/input-props.ts
// noinspection DuplicatedCode

import * as React from "react";

import type { CoreContext, Dict } from "@/schema/core";
import type { Field } from "@/schema/field";
import type { FieldSize, FieldDensity, ChangeDetail } from "@/variants/shared";
import type {
    VariantKey,
    VariantValueFor,
    VariantPropsFor,
} from "@/schema/variant";
import type {
    LabelPlacement,
    SublabelPlacement,
    DescriptionPlacement,
    HelpTextPlacement,
    ErrorTextPlacement,
    ValidateResult,
    SlotPlacement,
} from "@/schema/input-field";

/**
 * Core, variant-agnostic props for InputField.
 *
 * @template TValue Logical value type for this field. Will be refined by
 *                  variant typing (VariantValueFor<K>).
 */
export interface InputFieldBaseProps<TValue = unknown> {
    // ─────────────────────────────────────────────
    // Identity / wiring into the core runtime
    // ─────────────────────────────────────────────

    name?: string;
    bind?: string;
    groupId?: string;
    shared?: string;
    ignore?: boolean;
    alias?: string;
    main?: boolean;
    tags?: FieldTag[];
    contain?: boolean;
    autoOff?: boolean;

    /**
     * Handles the submission logic for a given form or process.
     *
     * @param {TValue} e - The value associated with the submission action.
     * @return {any} Value to be submitted.
     */
    onSubmit?(e: TValue): any;
    onReset?(e: React.FormEvent<HTMLFormElement>): void;
    // ─────────────────────────────────────────────
    // Chrome / description
    // ─────────────────────────────────────────────

    label?: React.ReactNode;
    sublabel?: React.ReactNode;
    description?: React.ReactNode;
    helpText?: React.ReactNode;

    /**
     * Optional explicit error text to display.
     *
     * This is *visual* error copy. The actual validation state still
     * lives in field.error / schema / onValidate.
     */
    errorText?: React.ReactNode;

    /**
     * Placement hints for label / sublabel / description / helpText / errorText.
     *
     * These are purely layout hints; actual behaviour is implemented
     * by the preset / host component.
     */
    labelPlacement?: LabelPlacement;
    sublabelPlacement?: SublabelPlacement;
    descriptionPlacement?: DescriptionPlacement;
    helpTextPlacement?: HelpTextPlacement;
    errorTextPlacement?: ErrorTextPlacement;
    tagPlacement?: SlotPlacement;

    // ─────────────────────────────────────────────
    // State flags
    // ─────────────────────────────────────────────

    required?: boolean;
    disabled?: boolean;
    readOnly?: boolean;

    size?: FieldSize;
    density?: FieldDensity;

    // ─────────────────────────────────────────────
    // Layout hooks
    // ─────────────────────────────────────────────

    inline?: boolean;
    fullWidth?: boolean;

    // ─────────────────────────────────────────────
    // Validation hooks
    // ─────────────────────────────────────────────

    onValidate?(
        value: TValue | undefined,
        field: Field,
        form: CoreContext<Dict>,
    ): ValidateResult;

    /**
     * Per-field change hook at the InputField level.
     *
     * - `value` is what the variant is trying to set.
     * - `detail` comes from the variant (`ChangeDetail`).
     * - If you return `undefined`, the original value is used.
     * - If you return *anything else*, that is what will be stored
     *   in the core (and emitted to the form).
     */
    onChange?(e: {
        value: TValue | undefined;
        preventDefault(): void;
        event?: React.SyntheticEvent;
        readonly isDefaultPrevented?: boolean;
        readonly detail: ChangeDetail;
    }): void;
}

export type Events<TRaw, TValue, TMeta> = {
    onValidate?(
        value: TValue | undefined,
        field: Field,
        form: CoreContext<Dict>,
    ): ValidateResult;

    /**
     * Per-field change hook at the InputField level.
     *
     * - `value` is what the variant is trying to set.
     * - `detail` comes from the variant (`ChangeDetail`).
     * - If you return `undefined`, the original value is used.
     * - If you return *anything else*, that is what will be stored
     *   in the core (and emitted to the form).
     */
    onChange?(e: {
        value: TValue | undefined;
        preventDefault(): void;
        event?: React.SyntheticEvent;
        readonly isDefaultPrevented?: boolean;
        readonly detail: ChangeDetail<TMeta, TRaw>;
    }): void;
};

/**
 * Public props for <InputField />.
 *
 * - `variant` selects the variant module.
 * - All variant-specific props are merged directly into the field props
 *   via `VariantPropsFor<K>`.
 *
 * NOTE: this is a type alias (not an interface) so we can safely intersect
 * unions coming from VariantPropsFor<K> / VariantValueFor<K>.
 */
export type InputFieldProps<
    K extends VariantKey = VariantKey,
    H = unknown,
> = InputFieldBaseProps<VariantValueFor<K, H>> &
    VariantPropsFor<K, H> &
    InputFieldClassNameProps &
    Omit<React.HTMLAttributes<HTMLDivElement>, "onChange" | "defaultValue"> & {
        variant: K;

        /**
         * @deprecated Use the specific *ClassName props instead
         * (className, labelClassName, errorClassName, etc.).
         */
        classes?: Partial<InputFieldClassNames>;
        defaultValue?: any;
    };

export interface InputFieldClassNameProps {
    /** Root comes from `className` on HTMLDivElement */
    labelRowClassName?: string;
    inlineRowClassName?: string;
    labelClassName?: string;
    sublabelClassName?: string;
    descriptionClassName?: string;
    helpTextClassName?: string;
    errorClassName?: string;
    groupClassName?: string;
    contentClassName?: string;
    variantClassName?: string;
    inlineInputColumnClassName?: string;
    inlineLabelColumnClassName?: string;
    requiredClassName?: string;
    tagClassName?: string;
}

export interface InputFieldClassNames {
    root?: string;
    labelRow?: string;
    inlineRow?: string;
    label?: string;
    sublabel?: string;
    description?: string;
    helpText?: string;
    error?: string;
    group?: string;
    content?: string;
    variant?: string;
    inlineInputColumn?: string;
    inlineLabelColumn?: string;
    required?: string;
    tag?: string;
}

export interface FieldTag {
    label: React.ReactNode;
    icon?: React.ReactNode;
    className?: string;
    color?: string; // text color
    bgColor?: string; // background color
}
```

---
#### 29


` File: packages/form-palette/src/lib/json-editor/filters.ts`  [↑ Back to top](#index)

```ts
// src/lib/json-editor/filters.ts
import type { JsonEditorFilters, JsonPath } from "./types";
import { lastSegment, matchPath } from "./glob";

/* ─────────────────────────────────────────────────────────────
 * Routes
 * ───────────────────────────────────────────────────────────── */

/**
 * Route visibility:
 * - includeRoutes (if set) acts as allow-list
 * - excludeRoutes always remove
 * - if excludeRouteSubtree=true: excluding "config" also excludes "config.**"
 */
export function isRouteAllowed(
    path: JsonPath,
    filters?: JsonEditorFilters
): boolean {
    if (!filters) return true;

    const excludeSubtree = filters.excludeRouteSubtree ?? true;

    if (filters.includeRoutes && filters.includeRoutes.length) {
        const ok = filters.includeRoutes.some((p) => matchPath(p, path));
        if (!ok) return false;
    }

    if (filters.excludeRoutes && filters.excludeRoutes.length) {
        for (const p of filters.excludeRoutes) {
            if (!p) continue;

            // direct match (wildcards + leaf-aware matching)
            if (matchPath(p, path)) return false;

            if (!excludeSubtree) continue;

            // subtree match for exact path prefixes (best effort)
            // (we only do this for exact-ish patterns without glob chars)
            const isExact =
                !p.includes("*") && p !== "." && p !== "/" && p.trim() !== "";
            if (!isExact) continue;

            // If p is a leaf-only pattern (no dots), don't treat it as a subtree prefix unless it
            // actually matches a real ancestor prefix of the route.
            const leaf = lastSegment(path);
            if (!p.includes(".") && p === leaf) continue;

            if (path === p) return false;
            if (path.startsWith(p + ".")) return false;
        }
    }

    return true;
}

/* ─────────────────────────────────────────────────────────────
 * Fields
 * ───────────────────────────────────────────────────────────── */

/**
 * Field visibility:
 * - includeFields (if set) acts as allow-list
 * - excludeFields always remove
 *
 * NOTE: field patterns use the same leaf-aware matcher:
 * - "token" (no dots) matches leaf key only
 * - "config.*token*" matches full path
 */
export function isFieldAllowed(
    fieldPath: JsonPath,
    filters?: JsonEditorFilters
): boolean {
    if (!filters) return true;

    if (filters.includeFields && filters.includeFields.length) {
        const ok = filters.includeFields.some((p) => matchPath(p, fieldPath));
        if (!ok) return false;
    }

    if (filters.excludeFields && filters.excludeFields.length) {
        const hit = filters.excludeFields.some((p) => matchPath(p, fieldPath));
        if (hit) return false;
    }

    return true;
}

/* ─────────────────────────────────────────────────────────────
 * Bulk helpers
 * ───────────────────────────────────────────────────────────── */

export function filterVisibleRoutes<T extends { path: JsonPath }>(
    nodes: T[],
    filters?: JsonEditorFilters
): T[] {
    return nodes.filter((n) => isRouteAllowed(n.path, filters));
}

export function filterVisibleFieldPaths(
    fieldPaths: JsonPath[],
    filters?: JsonEditorFilters
): JsonPath[] {
    return fieldPaths.filter((p) => isFieldAllowed(p, filters));
}

/**
 * Convenience for code that still uses a generic "paths" list.
 * By default, this uses field filtering semantics (because most callers are rendering fields).
 */
export function filterVisiblePaths(
    paths: JsonPath[],
    filters?: JsonEditorFilters,
    kind: "field" | "route" = "field"
): JsonPath[] {
    return kind === "route"
        ? paths.filter((p) => isRouteAllowed(p, filters))
        : paths.filter((p) => isFieldAllowed(p, filters));
}
```

---
#### 30


` File: packages/form-palette/src/lib/json-editor/glob.ts`  [↑ Back to top](#index)

```ts
// src/lib/json-editor/glob.ts
import type { JsonPath, JsonWildcard } from "./types";

/* ─────────────────────────────────────────────────────────────
 * Tiny helpers
 * ───────────────────────────────────────────────────────────── */

export function splitPath(path: JsonPath): string[] {
    if (!path) return [];
    return path.split(".").filter(Boolean);
}

export function lastSegment(path: JsonPath): string {
    const segs = splitPath(path);
    return segs[segs.length - 1] ?? "";
}

/**
 * Escapes regex special chars except '*'
 */
function escapeRegexExceptStar(input: string): string {
    return input.replace(/[.+?^${}()|[\]\\]/g, "\\$&");
}

function segmentGlobToRegex(pattern: string): RegExp {
    // segment-level glob: "*" means "any chars" (including empty)
    const src = "^" + escapeRegexExceptStar(pattern).replace(/\*/g, ".*") + "$";
    return new RegExp(src, "i");
}

export function matchSegment(pattern: string, segment: string): boolean {
    return segmentGlobToRegex(pattern).test(segment);
}

/* ─────────────────────────────────────────────────────────────
 * matchPath(pattern, path)
 *
 * Supports:
 * - "*api*"     (segment glob; default matches leaf key if no dots)
 * - "config.*"  (one segment)
 * - "config.**" (subtree)
 * - "**.*token*" (any depth)
 *
 * Semantics:
 * - If pattern contains '.' or '**' → match against the full path segments.
 * - Else → match against the leaf segment only.
 * ───────────────────────────────────────────────────────────── */

export function matchPath(pattern: JsonWildcard, path: JsonPath): boolean {
    const pat = (pattern ?? "").trim();
    if (!pat) return path === "";

    const pHasDot = pat.includes(".");
    const pHasDeep = pat.includes("**");

    const targetSegs = splitPath(path);

    // leaf-only matcher (no dots / deep)
    if (!pHasDot && !pHasDeep) {
        const leaf = targetSegs[targetSegs.length - 1] ?? "";
        return matchSegment(pat, leaf);
    }

    const patSegs = splitPath(pat);

    // backtracking matcher for ** (tiny; routes are small)
    function walk(pi: number, ti: number): boolean {
        while (pi < patSegs.length) {
            const seg = patSegs[pi];

            if (seg === "**") {
                // '**' matches zero or more segments
                if (pi === patSegs.length - 1) return true; // trailing '**' matches rest
                for (let k = ti; k <= targetSegs.length; k++) {
                    if (walk(pi + 1, k)) return true;
                }
                return false;
            }

            if (ti >= targetSegs.length) return false;

            // normal segment: can include '*' wildcards inside the segment
            if (!matchSegment(seg, targetSegs[ti])) return false;

            pi++;
            ti++;
        }

        return ti === targetSegs.length;
    }

    return walk(0, 0);
}

/* ─────────────────────────────────────────────────────────────
 * Specificity scoring for "best match wins"
 * (higher score = more specific)
 * ───────────────────────────────────────────────────────────── */

export function scoreMatch(pattern: JsonWildcard, path: JsonPath): number {
    if (!matchPath(pattern, path)) return -1;

    const pat = (pattern ?? "").trim();
    if (pat === path) return 10_000;

    const patSegs = splitPath(pat);
    const pathSegs = splitPath(path);

    // More segments + fewer wildcards => higher
    const segCountScore = patSegs.length * 100;

    // Character specificity: count non-wildcard chars
    const nonWildChars = pat.replace(/\*/g, "").replace(/\./g, "").length;

    // Penalize wildcards
    const starCount = (pat.match(/\*/g) ?? []).length;
    const deepCount = (pat.match(/\*\*/g) ?? []).length;

    // Reward closeness: deeper references tend to be more specific
    const depthCloseness = Math.min(patSegs.length, pathSegs.length) * 10;

    return (
        segCountScore +
        nonWildChars * 5 +
        depthCloseness -
        starCount * 15 -
        deepCount * 200
    );
}

/* ─────────────────────────────────────────────────────────────
 * pickBest(map, path)
 * Returns the best matching key and its value
 * ───────────────────────────────────────────────────────────── */

export function pickBest<T>(
    map: Record<JsonWildcard, T> | undefined,
    path: JsonPath
): { pattern: JsonWildcard; value: T } | null {
    if (!map) return null;

    let best: { pattern: JsonWildcard; value: T; score: number } | null = null;

    for (const [pattern, value] of Object.entries(map)) {
        const s = scoreMatch(pattern, path);
        if (s < 0) continue;
        if (!best || s > best.score) best = { pattern, value, score: s };
    }

    return best ? { pattern: best.pattern, value: best.value } : null;
}

/**
 * Compatibility with the old `pickBestMatch(path, rules)` signature.
 * Returns the best matching value (or undefined).
 */
export function pickBestMatch<T>(
    path: JsonPath,
    rules: Array<[JsonWildcard, T]>
): T | undefined {
    let best: { score: number; value: T } | undefined;

    for (const [pattern, value] of rules) {
        const s = scoreMatch(pattern, path);
        if (s < 0) continue;
        if (!best || s > best.score) best = { score: s, value };
    }

    return best?.value;
}
```

---
#### 31


` File: packages/form-palette/src/lib/json-editor/layout.ts`  [↑ Back to top](#index)

```ts
// src/lib/json-editor/layout.ts
import type { JsonEditorFilters, JsonWildcard } from "./types";
import { matchSegment, pickBestMatch } from "./glob";
import { filterVisibleFieldPaths } from "./filters";

export type JsonEditorLayout = Record<JsonWildcard, Array<string | string[]>>;

export type LayoutRow = {
    /** parent path that owns these children */
    parent: string;
    /** row children (absolute paths) */
    fields: string[];
    /** optional hint for UI (grid/flex), you can extend later */
    kind: "row";
};

function joinPath(parent: string, child: string) {
    if (!parent) return child;
    if (!child) return parent;
    return parent + "." + child;
}

function uniq<T>(arr: T[]) {
    return Array.from(new Set(arr));
}

function sortStable(paths: string[]) {
    return [...paths].sort((a, b) => a.localeCompare(b));
}

/**
 * Expand a token into matching children:
 * - token can be exact key ("maxRetries") or pattern ("*api*")
 * - token can be a relative dotted path ("headers.Authorization") which becomes "parent.headers.Authorization"
 */
function matchChildrenForToken(
    parent: string,
    token: string,
    remaining: string[]
): string[] {
    const absoluteToken = joinPath(parent, token);

    // If token is a dotted child-path, treat it as an exact relative reference.
    if (token.includes(".")) {
        return remaining.includes(absoluteToken) ? [absoluteToken] : [];
    }

    // Otherwise token is a relative pattern against direct child keys
    const matches: string[] = [];
    const prefix = parent ? parent + "." : "";

    for (const p of remaining) {
        if (!p.startsWith(prefix)) continue;

        const rest = parent ? p.slice(prefix.length) : p;
        if (!rest || rest.includes(".")) continue; // not a direct child

        if (matchSegment(token, rest)) matches.push(p);
    }

    return sortStable(matches);
}

/**
 * Resolve a parent layout into ordered rows.
 *
 * Rules:
 * - layout[parentPattern] -> best match wins
 * - string token expands to ALL matching children (as separate rows)
 * - string[] row expands each token; if token matches multiple, it expands into multiple columns
 * - after processing layout rules, remaining children are auto-flowed (one per row)
 */
export function resolveLayoutForParent(opts: {
    parent: string; // e.g. "config"
    childPaths: string[]; // absolute paths of DIRECT children (recommended)
    layout?: JsonEditorLayout;
    filters?: JsonEditorFilters;
}): LayoutRow[] {
    const { parent, layout, filters } = opts;

    // visible children (field semantics)
    let remaining = filterVisibleFieldPaths(opts.childPaths, filters);
    remaining = sortStable(remaining);

    const rules = layout
        ? (Object.entries(layout) as Array<[string, Array<string | string[]>]>)
        : [];

    const spec = rules.length ? pickBestMatch(parent, rules) : undefined;

    const rows: LayoutRow[] = [];

    const take = (paths: string[]) => {
        const taken = new Set(paths);
        remaining = remaining.filter((p) => !taken.has(p));
    };

    if (spec?.length) {
        for (const entry of spec) {
            // 1) "key" => expands to matches; each match becomes its own row
            if (typeof entry === "string") {
                const matches = matchChildrenForToken(parent, entry, remaining);
                if (!matches.length) continue;

                for (const m of matches) {
                    rows.push({ parent, kind: "row", fields: [m] });
                }
                take(matches);
                continue;
            }

            // 2) ["a", "b"] => one row; each token can expand
            if (Array.isArray(entry)) {
                const cols: string[] = [];

                for (const token of entry) {
                    const matches = matchChildrenForToken(
                        parent,
                        token,
                        remaining
                    );
                    if (!matches.length) continue;
                    cols.push(...matches);
                }

                const uniqCols = uniq(cols);
                if (!uniqCols.length) continue;

                rows.push({ parent, kind: "row", fields: uniqCols });
                take(uniqCols);
            }
        }
    }

    // Auto-flow the rest (preserve sorted order)
    for (const p of remaining) {
        rows.push({ parent, kind: "row", fields: [p] });
    }

    return rows;
}
```

---
#### 32


` File: packages/form-palette/src/lib/json-editor/routes.ts`  [↑ Back to top](#index)

```ts
// src/lib/json-editor/routes.ts
import type * as React from "react";
import type {
    JsonEditorFilters,
    JsonEditorNavOptions,
    JsonObject,
    JsonPath,
    JsonRouteNode,
} from "./types";
import { lastSegment, pickBest } from "./glob";
import { isRouteAllowed } from "./filters";

function isObjectLike(v: unknown): v is Record<string, any> {
    return typeof v === "object" && v !== null && !Array.isArray(v);
}

function isPlainObject(v: unknown): v is JsonObject {
    return isObjectLike(v);
}

function resolveRouteLabel(
    path: JsonPath,
    nav?: JsonEditorNavOptions
): React.ReactNode {
    // wildcard labels win (best match)
    const hit = pickBest(nav?.routeLabels, path);
    if (hit) return hit.value;

    if (!path) return "Root";
    return lastSegment(path);
}

/**
 * buildJsonRoutes(value, navProps) → nav tree
 * - routes are derived from nested objects
 * - can optionally include object-items inside arrays as routes
 */
export function buildJsonRoutes(
    value: JsonObject | undefined,
    nav?: JsonEditorNavOptions,
    filters?: JsonEditorFilters
): JsonRouteNode[] {
    const rootObj: JsonObject = (value ?? {}) as JsonObject;

    const showRoot = nav?.showRoot ?? true;
    const maxDepth = nav?.maxDepth ?? Number.POSITIVE_INFINITY;
    const arrayRoutes = nav?.arrayRoutes ?? "none";

    const nodes: JsonRouteNode[] = [];

    const buildChildren = (
        obj: JsonObject,
        parentPath: JsonPath,
        depth: number
    ): JsonRouteNode[] => {
        if (depth >= maxDepth) return [];

        const out: JsonRouteNode[] = [];

        for (const [k, v] of Object.entries(obj)) {
            const nextPath = parentPath ? `${parentPath}.${k}` : k;

            // nested object => route
            if (isPlainObject(v)) {
                if (!isRouteAllowed(nextPath, filters)) continue;

                out.push({
                    path: nextPath,
                    key: k,
                    label: resolveRouteLabel(nextPath, nav),
                    children: buildChildren(v, nextPath, depth + 1),
                });
                continue;
            }

            // array of objects => optionally allow routes like "config.items.0"
            if (arrayRoutes === "objects" && Array.isArray(v)) {
                const anyObjIdx = (v as any[]).findIndex((x) =>
                    isPlainObject(x)
                );
                if (anyObjIdx === -1) continue;

                // route for the array itself? (treat as object page)
                if (!isRouteAllowed(nextPath, filters)) continue;

                const arrayNode: JsonRouteNode = {
                    path: nextPath,
                    key: k,
                    label: resolveRouteLabel(nextPath, nav),
                    children: [],
                };

                const children: JsonRouteNode[] = [];
                (v as any[]).forEach((item, idx) => {
                    if (!isPlainObject(item)) return;
                    const itemPath = `${nextPath}.${idx}`;
                    if (!isRouteAllowed(itemPath, filters)) return;

                    children.push({
                        path: itemPath,
                        key: String(idx),
                        label: resolveRouteLabel(itemPath, nav) ?? `#${idx}`,
                        children: buildChildren(item, itemPath, depth + 1),
                    });
                });

                arrayNode.children = children;
                out.push(arrayNode);
            }
        }

        // stable ordering (optional): alphabetical
        out.sort((a, b) => String(a.key).localeCompare(String(b.key)));
        return out;
    };

    if (showRoot) {
        if (isRouteAllowed("", filters)) {
            nodes.push({
                path: "",
                key: "",
                label: resolveRouteLabel("", nav),
                children: buildChildren(rootObj, "", 0),
            });
        } else {
            // If root is excluded, still expose its children as top-level pages
            nodes.push(...buildChildren(rootObj, "", 0));
        }
    } else {
        nodes.push(...buildChildren(rootObj, "", 0));
    }

    return nodes;
}
```

---
#### 33


` File: packages/form-palette/src/lib/json-editor/types.ts`  [↑ Back to top](#index)

```ts
// src/lib/json-editor/types.ts
import type * as React from "react";

/* ─────────────────────────────────────────────────────────────
 * JSON primitives
 * ───────────────────────────────────────────────────────────── */

export type JsonPrimitive = string | number | boolean | null;
// eslint-disable-next-line @typescript-eslint/ban-types
// @ts-ignore
export type JsonValue = JsonPrimitive | JsonObject | JsonValue[];
// @ts-ignore
export type JsonObject = Record<string, JsonValue>;

export type JsonPath = string; // "" | "config" | "config.apiEndpoint"
export type JsonWildcard = string;

/* ─────────────────────────────────────────────────────────────
 * Filters (public shape)
 * ───────────────────────────────────────────────────────────── */

export interface JsonEditorFilters {
    /** Hide entire object routes/pages (navigation + rendering) */
    excludeRoutes?: JsonWildcard[];
    includeRoutes?: JsonWildcard[];

    /** Hide specific fields (by full path or leaf/wild patterns) */
    excludeFields?: JsonWildcard[];
    includeFields?: JsonWildcard[];

    /**
     * If true, excluding "config" also excludes "config.**".
     * Default: true
     */
    excludeRouteSubtree?: boolean;
}

/* ─────────────────────────────────────────────────────────────
 * Layout (public shape)
 * ───────────────────────────────────────────────────────────── */

export type JsonEditorLayoutRow = string | string[];
export type JsonEditorLayoutMap = Record<JsonWildcard, JsonEditorLayoutRow[]>;

/* ─────────────────────────────────────────────────────────────
 * Navigation (routes derived from JSON)
 * ───────────────────────────────────────────────────────────── */

export type JsonEditorNavMode = "sidebar" | "tabs" | "drawer";

export interface JsonEditorNavOptions {
    mode?: JsonEditorNavMode;
    showRoot?: boolean;
    defaultRoute?: JsonPath;
    routeLabels?: Record<JsonWildcard, React.ReactNode>;
    maxDepth?: number;
    arrayRoutes?: "none" | "objects";
}

export interface JsonRouteNode {
    path: JsonPath;
    key: string; // last segment
    label: React.ReactNode;
    children: JsonRouteNode[];
}
```

---
#### 34


` File: packages/form-palette/src/lib/json-editor/utils.ts`  [↑ Back to top](#index)

```ts
// src/lib/json-editor/utils.ts
import type {
    JsonEditorLayoutMap,
    JsonEditorLayoutRow,
    JsonPath,
} from "./types";
import { pickBest as _pickBest } from "./glob";

export type {
    JsonPrimitive,
    JsonValue,
    JsonObject,
    JsonPath,
    JsonWildcard,
    JsonEditorNavMode,
    JsonEditorNavOptions,
    JsonEditorFilters,
    JsonEditorLayoutRow,
    JsonEditorLayoutMap,
    JsonRouteNode,
} from "./types";

export {
    splitPath,
    lastSegment,
    matchSegment,
    matchPath,
    scoreMatch,
    pickBest,
    pickBestMatch,
} from "./glob";

export {
    isRouteAllowed,
    isFieldAllowed,
    filterVisibleRoutes,
    filterVisibleFieldPaths,
    filterVisiblePaths,
} from "./filters";

export type { JsonEditorLayout, LayoutRow } from "./layout";
export { resolveLayoutForParent } from "./layout";

export { buildJsonRoutes } from "./routes";

/**
 * Backwards-compat: pickLayout(layoutMap, activePath) → rows (best match wins)
 */
export function pickLayout(
    layoutMap: JsonEditorLayoutMap | undefined,
    activePath: JsonPath
): JsonEditorLayoutRow[] | undefined {
    const hit = _pickBest(layoutMap, activePath);
    return hit?.value;
}
```

---
#### 35


` File: packages/form-palette/src/lib/register-global.ts`  [↑ Back to top](#index)

```ts
import type { CustomFileLoader, FileItem } from "@/presets/shadcn-variants/file";
import { PasswordDefinitionMap } from "@/presets/shadcn-variants/password";
import { PhoneCountry } from "@/presets/shadcn-variants/phone";

// 1. Define the shape of your global palette store
export interface PaletteRegistry {
   countries: PhoneCountry[];
   ruleDefinition: PasswordDefinitionMap;
   customLoader: CustomFileLoader;
   getCountries: () => Promise<PhoneCountry[]>;
   formatFileValue: (file: FileItem) => string | undefined;
   // You can add more keys here later, e.g.:
   // theme?: 'light' | 'dark';
   // locale?: string;
}

// 2. Extend the global Window interface to include your custom key
declare global {
   interface Window {
      "form-palette"?: Partial<PaletteRegistry>;
   }
}

/**
 * Registers a value to the global window['form-palette'] object.
 * Safe to call in SSR environments (it will just no-op).
 */
export function registerPaletteUtil<K extends keyof PaletteRegistry>(
   key: K,
   value: PaletteRegistry[K]
) {
   // SSR Safety check
   if (typeof window === "undefined") return;

   // Initialize the namespace if it doesn't exist
   if (!window["form-palette"]) {
      window["form-palette"] = {};
   }

   // Assign the value
   window["form-palette"][key] = value;
}

/**
 * Retrieves a value from the global window['form-palette'] object.
 * Returns the value if found, otherwise returns the optional defaultValue or undefined.
 */
export function getPaletteUtil<K extends keyof PaletteRegistry>(
   key: K,
   defaultValue?: PaletteRegistry[K]
): PaletteRegistry[K] | undefined {
   // SSR Safety check
   if (typeof window === "undefined") {
      return defaultValue;
   }

   const registry = window["form-palette"];

   // Return the specific key if it exists
   if (registry && key in registry) {
      return registry[key];
   }

   return defaultValue;
}
```

---
#### 36


` File: packages/form-palette/src/lib/utils.ts`  [↑ Back to top](#index)

```ts
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs));
}

export function toArray<T>(v: T | T[] | null | undefined): T[] {
    if (v == null) return [];
    return Array.isArray(v) ? v : [v];
}
```

---
#### 37


` File: packages/form-palette/src/schema/adapter.ts`  [↑ Back to top](#index)

```ts
// src/schema/adapter.ts
import { Page } from "@inertiajs/core";

import { AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * HTTP methods supported by the core adapter layer.
 *
 * This matches the legacy Method union from the old types.ts.
 */
export type Method = 'post' | 'get' | 'delete' | 'put' | 'patch';

/**
 * Lifecycle callbacks used by adapters to report events back to the core.
 *
 * @template Ok  Type of the "successful" response payload (e.g. AxiosResponse).
 * @template Err Type of the "error" payload (e.g. AxiosError, unknown).
 */
export interface AdapterCallbacks<Ok = unknown, Err = unknown> {
    /**
     * Called when the underlying request completes successfully.
     * The adapter decides what "success" means (HTTP 2xx, no exception, etc.).
     */
    onSuccess?(response: Ok): void;

    /**
     * Called when the underlying request fails.
     * Adapters should pass the most informative error shape they have.
     */
    onError?(error: Err, updateRef?: boolean): void;

    /**
     * Called at the end of the adapter lifecycle, whether success or error.
     * Useful for clearing loading states, unlocking buttons, etc.
     */
    onFinish?(): void;
}

/**
 * Result interface returned by an adapter.
 *
 * Generic evolution of the legacy AdapterResult:
 *
 *   type AdapterResult = {
 *     submit(options?: unknown): void;
 *     send<T = unknown>(): Promise<AxiosResponse<T>>;
 *     run(options?: unknown): void;
 *   };
 *
 * Differences:
 * - The success payload is generic (Ok) instead of hard-coded to AxiosResponse.
 * - send() always returns Promise<Ok>.
 * - run() may return either void or Promise<Ok>, depending on adapter.
 *
 * @template Ok Type of the "successful" response payload.
 */
export interface AdapterResult<Ok = unknown> {
    /**
     * Fire-and-forget trigger.
     *
     * Intended for flows where the caller does not care about the response
     * object itself (e.g. SPA navigation).
     *
     * @param options Optional adapter-specific options.
     */
    submit(options?: unknown): void;

    /**
     * Promise-based trigger.
     *
     * Intended for flows where the caller wants to await the response object.
     * Adapters should reject the promise when an error occurs.
     *
     * @param options Optional adapter-specific options.
     */
    send(options?: unknown): Promise<Ok>;

    /**
     * Convenience trigger.
     *
     * Adapters are free to implement this as:
     * - submit(options) (returning void), or
     * - send(options) (returning Promise<Ok>).
     *
     * Callers that need strict typing can prefer send();
     * callers that just need "do the thing" can use run().
     *
     * @param options Optional adapter-specific options.
     */
    run(options?: unknown): void | Promise<Ok>;
}

/**
 * Configuration passed from the core runtime to a concrete adapter factory.
 *
 * @template Body Type of the outbound payload (form values + extra data).
 * @template Ok   Type of the "successful" response payload.
 * @template Err  Type of the "error" payload.
 */
export interface AdapterConfig<Body = unknown, Ok = unknown, Err = unknown> {
    /**
     * Request body payload built by the core.
     *
     * Typically something like:
     *
     *   { ...formValues, ...extra }
     */
    data: Body;

    errorBag?: string;

    /**
     * Lifecycle callbacks provided by the core.
     *
     * The adapter should invoke these at the appropriate times; it must not
     * swallow errors without calling onError (when provided).
     */
    callbacks?: AdapterCallbacks<Ok, Err>;
}

/**
 * Factory function type for creating an adapter instance.
 *
 * Concrete implementations (Axios, Inertia, fetch, custom) can conform
 * to this signature. The core runtime only knows about this type and does
 * not depend on any adapter-specific details.
 *
 * @template Body Type of the outbound payload (form values + extra data).
 * @template Ok   Type of the "successful" response payload.
 * @template Err  Type of the "error" payload.
 */
export type AdapterFactory<
    Body = unknown,
    Ok = unknown,
    Err = unknown,
> = (config: AdapterConfig<Body, Ok, Err>) => AdapterResult<Ok>;

/**
 * Registry of adapter flavours.
 *
 * The library hard-codes a single built-in adapter flavour:
 *
 *   - 'local' → host-handled, no transport semantics.
 *               .send() resolves to `{ data: Body }`.
 *
 * Hosts can extend this interface via module augmentation to add
 * their own adapter flavours (e.g. 'axios', 'inertia', ...).
 */
export interface Adapters {
    local: {
        /**
         * Type of the value produced by adapter.send() for this adapter flavour.
         */
        ok: { data: unknown };

        /**
         * Type of the error value passed into callbacks.onError for this adapter.
         */
        err: unknown;
    };

    axios: {
        /**
         * What adapter.send() resolves with for Axios.
         */
        ok: AxiosResponse<unknown>;

        /**
         * What callbacks.onError receives for Axios.
         *
         * We pass the *payload* (e.g. response.data), not the raw AxiosError,
         * so Form Palette's autoErr branch can see `.errors`.
         */
        err: unknown;

        /**
         * Extra public props exposed on CoreProps when adapter="axios".
         *
         * These are set on the Core shell and then used by createAxiosAdapter.
         */
        props: {
            /**
             * Request URL for this form.
             * Required when using the axios adapter.
             */
            url: string;

            /**
             * HTTP method to use for this form.
             * Optional: the adapter/Core can still default to "post".
             */
            method?: Method;

            /**
             * Base Axios request config merged into every request.
             *
             * Useful for baseURL, headers, withCredentials, params,
             * timeout, etc. Per-call overrides still go through the
             * `options` parameter of submit/send/run.
             */
            config?: AxiosRequestConfig<any>;
        };
    };

    inertia: {
        /**
         * What adapter.send() resolves with for Inertia.
         * This is the Page object passed to onSuccess.
         */
        ok: Page<any>;

        /**
         * What callbacks.onError receives for Inertia.
         *
         * We shape this as `{ errors: ErrorBag }` so Form Palette's
         * autoErr branch can see `.errors`.
         */
        err: { errors: Record<string, string | string[]> } | unknown;

        /**
         * Extra public props exposed on CoreProps when adapter="inertia".
         */
        props: {
            /**
             * Target URL / route for the Inertia visit.
             */
            url: string;

            /**
             * HTTP method to use for the visit.
             */
            method?: Method;
        };
    };
}

export type AdapterProps<K extends AdapterKey> =
    Adapters[K] extends { props: infer P } ? P : {};
/**
 * Union of all adapter keys known to the core.
 *
 * Hosts can extend this union by augmenting the Adapters interface.
 */
export type AdapterKey = keyof Adapters;

/**
 * Helper: given an adapter key K, get its "ok" payload type.
 */
export type AdapterOk<K extends AdapterKey> = Adapters[K]['ok'];

/**
 * Helper: given an adapter key K, get its "error" payload type.
 */
export type AdapterError<K extends AdapterKey> = Adapters[K]['err'];

/**
 * Helper: what CoreProps.onSubmitted receives for adapter K.
 *
 * For now, this is the same as AdapterOk<K>. If a host wants a different
 * shape, they can wrap/transform in their own components.
 */
export type AdapterSubmit<K extends AdapterKey> = AdapterOk<K>;

/**
 * AdapterConfig specialised for a named adapter key K, using the
 * registry's ok/err types for that key.
 *
 * @template K    Adapter key.
 * @template Body Outbound payload type.
 */
export type NamedAdapterConfig<
    K extends AdapterKey,
    Body = unknown,
> = AdapterConfig<Body, AdapterOk<K>, AdapterError<K>> & AdapterProps<K>;

/**
 * AdapterFactory specialised for a named adapter key K.
 *
 * @template K    Adapter key.
 * @template Body Outbound payload type.
 */
export type NamedAdapterFactory<
    K extends AdapterKey,
    Body = unknown,
> = (config: NamedAdapterConfig<K, Body>) => AdapterResult<AdapterOk<K>>;
```

---
#### 38


` File: packages/form-palette/src/schema/core.ts`  [↑ Back to top](#index)

```ts
// src/schema/core.ts
// noinspection JSUnusedGlobalSymbols,GrazieInspection

import type React from "react";
import type { z } from "zod";

import type {
    Method,
    AdapterResult,
    AdapterKey,
    AdapterSubmit,
    AdapterProps,
} from "./adapter";
import type { ButtonRef, Field } from "./field";
import { FieldRegistry } from "@/core/registry/field-registry";

/**
 * Generic dictionary type used throughout the core.
 *
 * This matches the legacy Dict<T> from the old types.ts.
 */
export type Dict<T = unknown> = Record<string, T>;

/**
 * If a Zod schema is present, infer the values from that schema;
 * otherwise use the fallback V type. Ensured to be a Dict so it
 * can safely be used as CoreContext's generic argument.
 */
export type InferFromSchema<S, V extends Dict> = S extends z.ZodType
    ? z.infer<S> & Dict
    : V;

/**
 * Event object passed to onSubmit, matching the legacy SubmitEvent
 * but kept transport-agnostic. The host decides how route/method/xhr
 * are interpreted and which adapter is used.
 *
 * @template TValues Shape of the outbound data for this submit event.
 */
export type SubmitEvent<TValues extends Dict, K extends AdapterKey> = {
    /**
     * Prevent the default submit behavior.
     *
     * In practice this prevents the core from continuing with its
     * normal submit/prepare flow.
     */
    preventDefault(): void;

    /**
     * Mutate the outbound data just before it is used.
     *
     * The callback may return a new data object or mutate in-place.
     */
    editData(cb: (data: TValues) => TValues | void): void;

    /**
     * Override the config for this adapter submission only.
     *
     * The core itself does not enforce any semantics here; the host
     * is expected to interpret this when wiring submissions.
     */
    setConfig(props: Partial<AdapterProps<K>>): void;
    setConfig(key: keyof AdapterProps<K>, value: any): void;

    /**
     * The button that triggered this submit, if any.
     */
    button?: ButtonRef;

    /**
     * The current outbound data snapshot (after any internal merges).
     */
    readonly formData: TValues;

    /**
     * The core context associated with this submit event.
     */
    form: CoreContext<TValues>;

    /**
     * If set to false, the core will abort the submit flow after
     * this handler returns.
     */
    continue: boolean;
};

/**
 * Shared base props for the core runtime, matching the spirit of
 * the legacy BaseProps, but transport-agnostic.
 *
 * @template V Shape of the underlying value map (pre-schema).
 * @template S Optional Zod schema type.
 */
export type BaseProps<
    V extends Dict,
    S extends z.ZodType | undefined,
    K extends AdapterKey,
> = {
    /**
     * Field names that should be ignored when building diffs or snapshots.
     * Useful for excluding secrets like passwords from logs.
     */
    exceptions?: string[];

    /**
     * Whether the core should persist values to the provided valueBag.
     */
    persist?: boolean;

    /**
     * Optional logical name for the core instance.
     */
    name?: string;

    /**
     * If true, a button may be automatically marked as "active" when
     * certain changes occur.
     */
    activateButtonOnChange?: boolean;

    /**
     * Called whenever a field changes.
     *
     * current is the field that changed; options carries any
     * variant-specific metadata.
     */
    onChange?(
        form: CoreContext<InferFromSchema<S, V>>,
        current: Field,
        options: Dict,
    ): void;

    /**
     * Called when the overall values snapshot is considered "updated".
     */
    onUpdate?(values: InferFromSchema<S, V>): void;

    /**
     * If true, onChange may run before certain internal updates.
     */
    changeBefore?: boolean;

    /**
     * Optional ref to the core context instance, for imperative access.
     */
    formRef?: React.MutableRefObject<CoreContext<InferFromSchema<S, V>> | null>;

    /**
     * Initial value bag for hydration / persistence.
     */
    valueBag?: InferFromSchema<S, V>;

    /**
     * Optional hook used to transform a single value as it is being
     * persisted or fed into the core.
     */
    valueFeed?: <K extends keyof InferFromSchema<S, V>>(
        name: K,
        value: InferFromSchema<S, V>[K],
        form: CoreContext<InferFromSchema<S, V>>,
    ) => InferFromSchema<S, V>[K] | undefined;

    /**
     * Called at the end of certain flows (legacy "finish" hook).
     *
     * Receives the core context so you can read values, errors, etc.
     */
    onFinish?(form: CoreContext<InferFromSchema<S, V>>): void;

    /**
     * Called after the core initializes.
     */
    init?(form: CoreContext<InferFromSchema<S, V>>): void;

    /**
     * Intercepts the submit event before the core proceeds.
     *
     * You can:
     * - mutate data,
     * - change route/method/xhr flags,
     * - abort by setting e.continue = false.
     */
    onSubmit?<T extends Dict = InferFromSchema<S, V>>(
        e: SubmitEvent<T, K>,
    ): Promise<void> | void;

    /**
     * Optional Zod schema used for validation and value inference.
     */
    schema?: S;
};

/**
 * Public core props, adapter-centric.
 *
 * - The library defines a built-in 'local' adapter flavour.
 *   AdapterSubmit<'local'> is `{ data: unknown }`.
 * - Hosts can extend the Adapters interface (schema/adapter.ts) to add
 *   their own adapter flavours (axios, inertia, etc.) and then use
 *   those keys here.
 *
 * @template V Shape of the underlying value map (pre-schema).
 * @template S Optional Zod schema type.
 * @template K Adapter key; defaults to 'local'.
 */
export type CoreProps<
    V extends Dict,
    S extends z.ZodType | undefined,
    K extends AdapterKey = "local",
> = BaseProps<V, S, K> &
    AdapterProps<K> & {
        /**
         * Which adapter flavour this core instance should use.
         *
         * - 'local' (default) → library-defined local submission (no URL/method semantics).
         * - extended keys      → host-defined adapters via Adapters augmentation.
         */
        adapter?: K;

        /**
         * Called after a submission completes. The payload type is derived from
         * the selected adapter key via the adapter registry:
         *
         *   AdapterSubmit<'local'> → { data: unknown }
         *   AdapterSubmit<'axios'> → host-defined type, etc.
         */
        onSubmitted?(
            form: CoreContext<InferFromSchema<S, V>>,
            payload: AdapterSubmit<K>,
            resolve?: () => void,
        ): void | Promise<void>;
    };

/**
 * Backwards-compatible alias for legacy naming, if you want it.
 */
export type FormProps<
    V extends Dict,
    S extends z.ZodType | undefined,
    K extends AdapterKey = "local",
> = CoreProps<V, S, K>;

/**
 * Result of a submit operation: values + validity flag.
 */
export type ValuesResult<V extends Dict> = { values: V; valid: boolean };

/**
 * Query API for fields, similar to DOM helpers but scoped
 * to the current form instance.
 *
 * "id" here refers to the field's groupId.
 */
export interface InputStore {
    /** All registered inputs (with at least one identifier). */
    all(): Field[];

    /** All inputs that have a non-empty name. */
    getAllNamed(): Field[];

    /** All inputs that have a bindId. */
    getAllBound(): Field[];

    /** All inputs that have a groupId. */
    getAllGrouped(): Field[];

    /** First field matching an exact name. */
    getByName(name: string): Field | undefined;

    /** All fields matching an exact name. */
    getAllByName(name: string): Field[];

    /** First field with this groupId. */
    getById(id: string): Field | undefined;

    /** All fields with this groupId. */
    getAllById(id: string): Field[];

    /** First bound field with this bindId (prefers mounted fields). */
    getByBind(id: string): Field | undefined;

    /** All fields that share this bindId. */
    getAllByBind(id: string): Field[];
}

/**
 * Core runtime context, renamed from the legacy FormContext.
 *
 * @template V Shape of the values object produced by this core instance.
 */
export interface CoreContext<V extends Dict> {
    /**
     * Compute the current values snapshot from registered fields.
     */
    values(): V;

    /**
     * Run validation and return the values + validity flag.
     */
    submit(): ValuesResult<V>;

    /**
     * Lookup a field by its binding id.
     */
    getBind(id: string): Field | undefined;

    /**
     * Run validation across fields.
     *
     * @param report If true, fields should update their own error states.
     * @returns true if all fields are valid, false otherwise.
     */
    validate(report?: boolean): boolean;

    /**
     * Register a new field with the core.
     */
    addField(field: Field): void;

    /**
     * Generic internal bucket for arbitrary metadata.
     */
    bucket: Dict;

    /**
     * Set a single field error or map an error bag.
     */
    error(name: string, msg: string): void;
    error(bag: Record<string, string>): void;

    /**
     * Re-run button control logic (which button is active/disabled etc.).
     */
    controlButton(): void;

    /**
     * Prepare an adapter-backed request.
     *
     * This mirrors the legacy prepare method:
     * - Builds a payload from values + extra.
     * - May run validation / beforeSubmit hooks.
     * - Returns an adapter result or undefined if aborted.
     *
     * The concrete adapter wiring is the host's responsibility.
     */
    prepare(
        type: Method,
        route: string,
        extra?: Partial<V>,
        ignoreForm?: boolean,
        autoErr?: boolean,
    ): Promise<AdapterResult<any> | undefined>;

    /**
     * Persist values to a provided data object, optionally transforming
     * values via the feed function.
     */
    persist(
        data: Partial<V>,
        feed?: (name: string, value: unknown, original: unknown) => unknown,
    ): void;

    /**
     * Imperatively set a single value by field name.
     */
    setValue(name: string, value: unknown): void;

    /**
     * Kick off a submit flow using optional extra data.
     */
    go(data?: Partial<V>, ignoreForm?: boolean): void;

    /**
     * Reset specific inputs by name.
     */
    reset(inputs: string[]): void;

    /**
     * Register the current active button.
     */
    set button(v: ButtonRef);

    /**
     * Force a submit regardless of validation state.
     */
    forceSubmit(): Promise<void>;

    /**
     * All registered fields.
     */
    readonly fields: Field[];

    /**
     * Effective core props at runtime, excluding internal-only fields.
     *
     * Note: the adapter key parameter is erased here (set to any) because
     * the runtime does not need the specific key for structural typing;
     * hosts can still use more precise generics at the component level.
     */
    readonly props: Omit<
        CoreProps<V, z.ZodType | undefined, any>,
        "formRef" | "valueBag"
    >;

    /**
     * Mark a button as active by name.
     */
    setActiveButton(name: string): void;

    /**
     * Return uncaught messages (errors that could not be mapped to a field).
     *
     * Typically used by an error strip component.
     */

    getUncaught(): readonly string[];
    hasUncaughtErrors: number;
    /**
     * Field-query "DOM" for this form.
     *
     * Example:
     *   const email = form.inputs.getByName("email");
     *   const phoneFields = form.inputs.getAllById("phone-group");
     *   const bound = form.inputs.getByBind("shipping");
     */
    inputs: Omit<FieldRegistry, "add" | "remove">;

    /**
     * Checks if the form values have changed
     */
    isDirty(): boolean;
}
```

---
#### 39


` File: packages/form-palette/src/schema/field.ts`  [↑ Back to top](#index)

```ts
// src/schema/field.ts
// noinspection GrazieInspection

import type { RefObject } from "react";
import { VariantKey } from "@/schema/variant";

/**
 * Imperative handle for a submit button registered with the core.
 *
 * This mirrors the legacy `ButtonRef` interface, but is aligned with the
 * current CoreProvider implementation:
 *
 * - The core will try `setLoading(v)` / `setDisabled(v)` if available.
 * - Otherwise, it will fall back to setting `loading` / `disabled` props.
 */
export interface ButtonRef {
    /**
     * Logical name of the button.
     *
     * Used by the core runtime to track the "active" button
     * and to map behaviours to a specific action.
     */
    name: string;

    /**
     * Loading flag. The core may read or assign this directly if
     * no setter is provided.
     */
    loading?: boolean;

    /**
     * Disabled flag. The core may read or assign this directly if
     * no setter is provided.
     */
    disabled?: boolean;

    /**
     * Optional setter used by the core to toggle loading.
     */
    setLoading?(v: boolean): void;

    /**
     * Optional setter used by the core to toggle disabled state.
     */
    setDisabled?(v: boolean): void;
}

/**
 * Runtime representation of a single field registered with the core.
 *
 * This is a direct, type-safe evolution of the legacy `Field` interface
 * from the old `types.ts`, updated to match the new core + binder flow.
 */
export interface Field {
    /**
     * Primary field name, used in values, error bags, and schema mapping.
     *
     * May be omitted for purely bound/virtual fields that participate in
     * binder flows but are not directly part of the value bag.
     */
    name?: string;

    /**
     * Internal binding identifier.
     *
     * Used by "bound" helpers (observe-bound-field, wait-for-bound-field)
     * to locate shared/aliased fields without going through the name.
     */
    bindId?: string;

    /**
     * Optional explicit binding identifier.
     * Use to bind to a specific field in a nested object that has bindId
     */
    bind?: string;

    /**
     * Ref to the underlying DOM element used for focus/scroll operations.
     *
     * Implementations typically point this at the outer wrapper of the field.
     */
    ref?: RefObject<HTMLElement> | null;

    /**
     * Whether this field is required.
     *
     * Variant-level and schema-level validation may use this.
     */
    required?: boolean;

    /**
     * Current error message for the field.
     *
     * Undefined or empty string means "no error".
     */
    error?: string;

    /**
     * Current value of the field, as seen by the core runtime.
     *
     * For formatted inputs, this may be the formatted representation.
     */
    value?: unknown;

    /**
     * Initial/default value for the field.
     *
     * This is typically the "un-touched" value coming from props or
     * from a persisted value bag.
     */
    defaultValue?: unknown;

    /**
     * Original, unformatted value as first seen by the core.
     *
     * This allows callers to compare "what changed" relative to the
     * original snapshot, independent of any display formatting.
     */
    originalValue?: unknown;

    /**
     * Whether this field is currently performing an async operation
     * (e.g. remote validation).
     */
    loading?: boolean;

    /**
     * Optional group identifier used to group related fields together
     * (e.g. radio groups, segmented inputs).
     */
    groupId?: string;

    /**
     * Optional alias for this field.
     *
     * Aliases allow mapping server error bags or schema keys that do
     * not strictly match the `name` property.
     */
    alias?: string;

    /**
     * Marks this field as the "main" one in a group.
     *
     * Used by some variants/layouts to determine which field drives
     * overall group state.
     */
    main?: boolean;

    /**
     * If true, this field will be ignored when building values or
     * running certain validation flows.
     */
    ignore?: boolean;

    /**
     * Stable unique key (distinct from `name` and `bindId`).
     *
     * Used internally by registries and React lists.
     */
    key?: string;

    /**
     * Shared key for fields that share their value (e.g. custom views
     * over the same underlying data).
     *
     * This is used by the core when building nested objects, e.g.:
     *   shared = "profile", name = "first_name"
     *   ⇒ values.profile.first_name
     */
    shared?: string;

    // ─────────────────────────────────────────────────────────
    // Behaviour hooks (implemented by InputField / variants)
    // ─────────────────────────────────────────────────────────

    /**
     * Run validation for this field.
     *
     * @param report If true, the field should update its own error state;
     *               if false, it may simply return whether it is valid.
     * @returns `true` if the field is currently valid, `false` otherwise.
     */
    validate?(report?: boolean): boolean;

    /**
     * Optional hook used by the core or higher-level utilities to retrieve
     * the current value of the field.
     *
     * If omitted, the core will fall back to the `value` property.
     */
    getValue?(): unknown;

    /**
     * Optional hook used by the core or higher-level utilities to update
     * the current value of the field.
     *
     * If omitted, the core will fall back to mutating the `value` property.
     */
    setValue?(value: unknown): void;

    /**
     * Optional hook used by the core to reset the field back to its
     * default/original value.
     */
    reset?(): void;

    /**
     * Optional hook used by the core to set or clear the field error.
     *
     * If omitted, the core will fall back to assigning the `error` property.
     */
    setError?(message?: string): void;

    /**
     * Optional hook called whenever the field value changes.
     *
     * Used by binder utilities to propagate changes across bound fields.
     *
     * @param value   New value.
     * @param old     Previous value.
     * @param source  Source tag responsible for the change
     *                (e.g. "variant", "util", "paste", "programmatic").
     */
    onChange?(value: unknown, old: unknown, source: string): void;

    /**
     * Optional hook called whenever the field is submitted.
     * @param e
     */
    onSubmit?(e: unknown): any;
    variant: VariantKey
}
```

---
#### 40


` File: packages/form-palette/src/schema/input-field.ts`  [↑ Back to top](#index)

```ts
// src/schema/input-field.ts

import type { FieldSize, FieldDensity } from "@/variants/shared";

/**
 * Result type for validation hooks.
 *
 * Used by:
 * - variant modules (`validate`)
 * - per-field `onValidate` (InputField)
 */
export type ValidateResult =
    | boolean // false = invalid, true = OK
    | string // one error message
    | string[] // multiple messages (first is used for display)
    | null
    | void; // null/void treated as "OK"

/**
 * Placement of the main label relative to the field control.
 *
 * This is a macro layout decision: where the label block lives
 * compared to the input/control block.
 */
export type LabelPlacement = "top" | "left" | "right" | "hidden";

/**
 * Shared placement for helper slots relative to their *root*.
 *
 * Example:
 *  - "above" → above the label root or input root
 *  - "below" → below the label root or input root
 *  - "left"  → left of the label root or input root
 *  - "right" → right of the label root or input root
 *  - "hidden" → not rendered
 */
export type SlotPlacement = "left" | "right" | "above" | "below" | "hidden";

/**
 * Placement of the sublabel relative to its root block.
 */
export type SublabelPlacement = SlotPlacement;

/**
 * Placement for the longer description block.
 */
export type DescriptionPlacement = SlotPlacement;

/**
 * Placement for helper text (typically small, subtle text).
 */
export type HelpTextPlacement = SlotPlacement;

/**
 * Placement for explicit error text (visual error copy).
 */
export type ErrorTextPlacement = SlotPlacement;

/**
 * Registry of all logical "slots" a field can render.
 *
 * Hosts can extend this via declaration merging, e.g.:
 *
 *   declare module "@/schema/input-field" {
 *     interface FieldSlots {
 *       charCounter: true;
 *     }
 *   }
 */
export interface FieldSlots {
    /** The main label text. */
    label: true;
    /** Optional smaller label text. */
    sublabel: true;
    /** Longer, usually multi-line description. */
    description: true;
    /** Small helper text, usually subtle. */
    helpText: true;
    /** Error text (validation message) when present. */
    errorText: true;
    /** The actual control/input element. */
    input: true;
    /**tags */
    tags: true;
}

/**
 * Registry of logical "roots" / anchor blocks.
 *
 * Other slots are positioned relative to one of these.
 */
export interface FieldRoots {
    /** Label root block. */
    label: true;
    /** Input/control root block. */
    input: true;
}

export type FieldSlotId = keyof FieldSlots;
export type FieldRootId = keyof FieldRoots;

/**
 * Map of which root each *non-root* slot belongs to.
 *
 * Example:
 *   relativeRoots: {
 *     sublabel: "label",
 *     description: "input",
 *     helpText: "input",
 *     errorText: "input",
 *   }
 */
export type RelativeRootsMap = Partial<
    Record<
        Exclude<FieldSlotId, FieldRootId>, // non-root slots only
        FieldRootId
    >
>;

/**
 * Relative ordering of *non-root* slots per root.
 *
 * This is *not* about placement; it only decides "who comes first"
 * when multiple slots share the same:
 *   - root (label/input), and
 *   - placement (above/below/left/right)
 *
 * Example:
 *   ordering: {
 *     input: ["errorText", "description", "helpText"],
 *   }
 *
 * If description and helpText are both "below" the input, then the
 * above config means:
 *   - errorText (below input) first,
 *   - then description (below input),
 *   - then helpText (below input).
 */
export type FieldOrdering = Partial<
    Record<FieldRootId, Exclude<FieldSlotId, FieldRootId>[]>
>;

/**
 * Layout defaults for a field/variant.
 *
 * Variants can provide these as defaults; InputField merges them
 * with per-field overrides.
 *
 * The high-level placement props remain the main public API.
 * `relativeRoots` and `ordering` provide a lower-level layout graph
 * that InputField can use to render slots relative to "label" or
 * "input" in a predictable order.
 */
export interface FieldLayoutConfig {
    /**
     * Where to render the main label relative to the control.
     */
    labelPlacement?: LabelPlacement;

    /**
     * Where to render the sublabel relative to its root.
     */
    sublabelPlacement?: SublabelPlacement;

    /**
     * Where to render the description block relative to its root.
     */
    descriptionPlacement?: DescriptionPlacement;

    /**
     * Where to render helper text relative to its root.
     */
    helpTextPlacement?: HelpTextPlacement;

    /**
     * Where to render error text (if any) relative to its root.
     */
    errorTextPlacement?: ErrorTextPlacement;

    /**Where to render the tags (if any) relative to ites root */
    tagPlacement?: SlotPlacement;
    /**
     * Hint that the field should render inline with other controls.
     */
    inline?: boolean;

    /**
     * Hint that the field should stretch to the full available width.
     */
    fullWidth?: boolean;

    /**
     * Optional default size/density hints.
     *
     * These are advisory; variants/presets may override them.
     */
    defaultSize?: FieldSize;
    defaultDensity?: FieldDensity;

    /**
     * Which root each non-root slot is attached to.
     *
     * If omitted, InputField can infer reasonable defaults, e.g.:
     * - sublabel     → "label"
     * - description  → "input"
     * - helpText     → "input"
     * - errorText    → "input"
     */
    relativeRoots?: RelativeRootsMap;

    /**
     * Relative ordering of non-root slots per root.
     *
     * Used only when multiple slots share the same
     * root + placement combination.
     */
    ordering?: FieldOrdering;
}

/**
 * Effective layout for a field after merging:
 * - variant defaults, and
 * - per-field overrides.
 */
export interface EffectiveFieldLayout extends FieldLayoutConfig {
    /**
     * Concrete size/density after merging defaults + overrides.
     */
    size?: FieldSize;
    density?: FieldDensity;
}

/**
 * Context passed to a variant's layout resolver.
 *
 * - `defaults`: layout defaults defined by the variant module.
 * - `overrides`: only the layout keys explicitly set on <InputField />.
 * - `props`: the raw <InputField /> props for this field.
 *
 * The resolver MUST respect host overrides: if a key is present in
 * `overrides`, it should not change it.
 */
export interface LayoutResolveContext<T = unknown> {
    defaults: FieldLayoutConfig;
    overrides: Partial<FieldLayoutConfig>;
    props: T;
}

/**
 * Variant-level layout resolver.
 *
 * This allows variants to implement mapping rules such as:
 * - "if labelPlacement is left ⇒ inline=true, error below, etc."
 * while still allowing host overrides to win.
 *
 * Variants may also fill in `relativeRoots` and `ordering` to define
 * how slots are attached to "label" vs "input" and in what relative
 * order they should render.
 */
export type LayoutResolver<T = unknown> = (ctx: LayoutResolveContext<T>) => FieldLayoutConfig;
```

---
#### 41


` File: packages/form-palette/src/schema/variant.ts`  [↑ Back to top](#index)

```ts
// src/schema/variant.ts
// noinspection GrazieInspection

import type { ComponentType } from "react";

import type { Dict, CoreContext } from "@/schema/core";
import type { Field } from "@/schema/field";
import type {
    FieldLayoutConfig,
    LayoutResolver,
    ValidateResult,
} from "@/schema/input-field";
import type { VariantBaseProps } from "@/variants/shared";
import { ShadcnNumberVariantProps } from "@/presets/shadcn-variants/number";
import { ShadcnPhoneVariantProps } from "@/presets/shadcn-variants/phone";
import { ShadcnColorVariantProps } from "@/presets/shadcn-variants/color";
import { ShadcnPasswordVariantProps } from "@/presets/shadcn-variants/password";
import {
    ShadcnDateVariantProps,
} from "@/presets/shadcn-variants/date";
import { ShadcnChipsVariantProps } from "@/presets/shadcn-variants/chips";
import { ShadcnTextareaVariantProps } from "@/presets/shadcn-variants/textarea";
import { ShadcnToggleVariantProps } from "@/presets/shadcn-variants/toggle";
import { ShadcnRadioVariantProps } from "@/presets/shadcn-variants/radio";
import { CheckboxVariantPublicValue, ShadcnCheckboxVariantPublicProps } from "@/presets/shadcn-variants/checkbox";
import { ShadcnMultiSelectVariantProps } from "@/presets/shadcn-variants/multiselect";
import { SliderValue } from "@/variants/core/slider";
import { ShadcnSliderVariantProps } from "@/presets/shadcn-variants/slider";
import { KeyValueMap, ShadcnKeyValueVariantProps } from "@/presets/shadcn-variants/keyvalue";
import { ShadcnCustomVariantProps } from "@/presets/shadcn-variants/custom";
import { ShadcnTreeSelectVariantProps } from "@/presets/shadcn-variants/treeselect";
import { FileLike, ShadcnFileVariantProps } from "@/presets/shadcn-variants/file";
import { ShadcnTextVariantProps } from "@/presets/shadcn-variants/text";
import { SelectVariantProps } from "@/variants/core/select";
import { ShadcnToggleVariantProps as ShadcnToggleGroupVariantProps } from "@/presets/shadcn-variants/toggle-group";
import { ShadcnEditorVariantProps } from "@/presets/shadcn-variants/editor";
import { JsonObject } from "@/lib/json-editor/utils";
import { ShadcnJsonEditorProps } from "@/presets/shadcn-variants/json-editor/types";
import { ListerVariantProps } from "@/presets/shadcn-variants/lister/types";

/**
 * Helper type for a single variant registry entry.
 *
 * Keeps the shape consistent and easy to extend via declaration merging.
 */
export interface VariantEntry<TValue, TProps> {
    value: TValue;
    props: TProps;
}

/**
 * Base type-level variant registry.
 *
 * This is the **canonical mapping** used by:
 * - InputFieldProps<K>
 * - VariantModule<K>
 *
 * Hosts & presets extend it via declaration merging:
 *
 *   declare module "@/schema/variant" {
 *     interface Variants {
 *       select: VariantEntry<SelectValuePublic, SelectPropsPublic>;
 *     }
 *   }
 */
export interface Variants<H = unknown> {
    /**
     * Built-in "text" variant.
     *
     * Shadcn-based implementation lives in presets/shadcn-variants/text.tsx
     */
    text: VariantEntry<string | undefined, ShadcnTextVariantProps>;

    /**
     * Example scalar variant.
     *
     * You can repurpose this for "custom" or drop it later.
     */
    number: VariantEntry<number | undefined, ShadcnNumberVariantProps>;

    phone: VariantEntry<string | number | undefined, ShadcnPhoneVariantProps>;
    color: VariantEntry<string | undefined, ShadcnColorVariantProps>;
    password: VariantEntry<string | undefined, ShadcnPasswordVariantProps>;

    // Date is modeled as string for now (ISO/whatever your preset uses)
    date: VariantEntry<string | undefined, ShadcnDateVariantProps>;

    chips: VariantEntry<string[] | undefined, ShadcnChipsVariantProps>;
    textarea: VariantEntry<string | undefined, ShadcnTextareaVariantProps>;
    toggle: VariantEntry<boolean | undefined, ShadcnToggleVariantProps>;
    'toggle-group': VariantEntry<any | undefined, ShadcnToggleGroupVariantProps>

    radio: VariantEntry<unknown | undefined, ShadcnRadioVariantProps<unknown, H>>
    checkbox: VariantEntry<CheckboxVariantPublicValue, ShadcnCheckboxVariantPublicProps>
    select: VariantEntry<string | number | undefined, SelectVariantProps>
    'multi-select': VariantEntry<Array<string | number> | undefined, ShadcnMultiSelectVariantProps>,
    slider: VariantEntry<SliderValue, ShadcnSliderVariantProps>
    keyvalue: VariantEntry<KeyValueMap | undefined, ShadcnKeyValueVariantProps>
    custom: VariantEntry<unknown | undefined, ShadcnCustomVariantProps>,
    treeselect: VariantEntry<string | number | undefined, ShadcnTreeSelectVariantProps>,
    file: VariantEntry<FileLike, ShadcnFileVariantProps>
    editor: VariantEntry<string | undefined, ShadcnEditorVariantProps>
    'json-editor': VariantEntry<JsonObject | undefined, ShadcnJsonEditorProps>
    lister: VariantEntry<any | undefined, ListerVariantProps<any>>
}



/**
 * Union of all variant keys.
 */
export type VariantKey = keyof Variants;

/**
 * Value type for a given variant key.
 *
 * Strongly drives autocomplete:
 * - InputFieldProps<"text"> → TValue = string | undefined
 */
export type VariantValueFor<K extends VariantKey, H = unknown> = Variants<H>[K]["value"];

/**
 * Props type for a given variant key.
 *
 * Strongly drives autocomplete:
 * - InputFieldProps<"text"> → props = TextVariantProps
 */
export type VariantPropsFor<K extends VariantKey, H = unknown> = Variants<H>[K]["props"];

/**
 * Signature for variant-level validation functions.
 */
export type VariantValidateFn<TValue, TProps> = (
    value: TValue | undefined,
    ctx: {
        required?: boolean;
        props: TProps;
        field: Field;
        form: CoreContext<Dict>;
    }
) => ValidateResult;

/**
 * Layout defaults for a variant.
 *
 * This extends FieldLayoutConfig, so it automatically includes:
 * - placement props (labelPlacement, descriptionPlacement, etc.)
 * - layout hints (inline, fullWidth, defaultSize/density)
 * - layout graph (relativeRoots, ordering)
 */
export interface VariantLayoutDefaults extends FieldLayoutConfig { }

/**
 * Runtime module definition for a variant.
 *
 * IMPORTANT:
 * - This is **tied directly** to the registry:
 *     TValue = VariantValueFor<K>
 *     TProps = VariantPropsFor<K>
 *
 *   So if you change the entry in `Variants`, both:
 *     - <InputField variant="..." /> props
 *     - The Variant component in the module
 *   will see the updated types and IntelliSense matches everywhere.
 *
 * - For complex variants (select/multiselect):
 *   you model the relationship via unions in `Variants["select"]`.
 */
export interface VariantModule<K extends VariantKey = VariantKey> {
    /**
     * Unique key for this variant, e.g. "text", "number", "select".
     */
    variant: K;

    /**
     * React component that renders the control.
     *
     * It receives:
     * - VariantBaseProps<VariantValueFor<K>>
     * - VariantPropsFor<K>
     */
    Variant: ComponentType<
        VariantBaseProps<VariantValueFor<K>> & VariantPropsFor<K>
    >;

    /**
     * Optional validation logic specific to this variant.
     */
    validate?: VariantValidateFn<
        VariantValueFor<K>,
        VariantPropsFor<K>
    >;

    /**
     * Optional default layout hints for this variant.
     */
    defaults?: {
        layout?: VariantLayoutDefaults;
    };

    /**
     * Optional smart layout resolver.
     *
     * Must respect host overrides.
     */
    resolveLayout?: LayoutResolver<VariantPropsFor<K>>;

    /**
     * Optional metadata, useful for docs/inspectors.
     */
    meta?: {
        label?: string;
        description?: string;
        tags?: string[];
    };
}

/**
 * Convenience alias when you want to be explicit:
 *
 *   const textModule: VariantModuleFor<"text"> = { ... }
 */
export type VariantModuleFor<K extends VariantKey> = VariantModule<K>;
```

---
#### 42


` File: packages/form-palette/src/variants/core/checkbox.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/checkbox.ts

import type { VariantModuleFor } from "@/schema/variant";
import { ShadcnCheckboxVariant } from "@/presets/shadcn-variants/checkbox";
import type {
   ShadcnCheckboxVariantPublicProps,
   CheckboxVariantPublicValue,
} from "@/presets/shadcn-variants/checkbox";
import type { VariantBaseProps } from "@/variants/shared";
import { toggleLayoutDefaults } from "./toggle";

/**
 * Public props type you can import elsewhere:
 *
 *   import type { CheckboxVariantProps } from "@/variants/core/checkbox";
 */
export type CheckboxVariantProps = ShadcnCheckboxVariantPublicProps;

/**
 * Concrete Variant component type, if you need it:
 *
 *   VariantBaseProps<CheckboxVariantPublicValue> & CheckboxVariantProps
 */
type CheckboxVariantComponentProps =
   VariantBaseProps<CheckboxVariantPublicValue> & CheckboxVariantProps;

/**
 * Runtime module for the "checkbox" variant.
 *
 * This wires the Shadcn preset into the core registry with sensible defaults.
 */
export const checkboxModule: VariantModuleFor<"checkbox"> = {
   variant: "checkbox",

   // ShadcnCheckboxVariant is generic; we fix it to the public aliases
   // via this cast. At call sites you'll still get strong typing because
   // the registry types know the concrete value/props.
   Variant: ShadcnCheckboxVariant as unknown as React.ComponentType<CheckboxVariantComponentProps>,

   resolveLayout({ props }) {
      if (props.single) {
         return toggleLayoutDefaults
      }

      return {};
   },

   meta: {
      label: "Checkbox",
      description:
         "Single or group checkboxes with optional per-item tri-state support.",
      tags: ["checkbox", "group", "boolean", "tri-state"],
   },
};
```

---
#### 43


` File: packages/form-palette/src/variants/core/chips.tsx`  [↑ Back to top](#index)

```tsx
import ShadcnChipsVariant from "@/presets/shadcn-variants/chips";
import { VariantModuleFor } from "@/schema/variant";


export const chipVariant: VariantModuleFor<"chips"> = {
   variant: "chips",
   Variant: ShadcnChipsVariant as any,
   // Optional layout defaults – tweak as you like
   defaults: {
      layout: {
         fullWidth: true,
         // You can set defaultSize/defaultDensity here if you want:
         // defaultSize: "md",
         // defaultDensity: "normal",
      },
   },
   meta: {
      label: "Chips",
      description: "Chips input allowing multiple selections.",
      tags: ["chips", "multi-select", "tags"],
   },
}
```

---
#### 44


` File: packages/form-palette/src/variants/core/color.tsx`  [↑ Back to top](#index)

```tsx
// ———————————————————————————————
// VariantModule wiring

import { ShadcnColorVariant } from "@/presets/shadcn-variants/color";
import { VariantModule } from "@/schema/variant";

// ———————————————————————————————
export const ColorVariantModule: VariantModule<"color"> = {
   variant: "color",
   Variant: ShadcnColorVariant,
   meta: {
      label: "Phone",
      description: "Phone number input with country code and masking.",
      tags: ["phone", "tel", "contact"],
   },
};
```

---
#### 45


` File: packages/form-palette/src/variants/core/custom.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/custom.tsx

import type { VariantModule } from "@/schema/variant";
import { ShadcnCustomVariant } from "@/presets/shadcn-variants/custom";

/**
 * Core "custom" variant module.
 *
 * - Delegates all UI to ShadcnCustomVariant.
 * - No layout defaults, no built-in validation.
 * - Consumers can override layout via InputField props if needed.
 */
export const customVariant: VariantModule<"custom"> = {
   variant: "custom",
   Variant: ShadcnCustomVariant,
};

export default customVariant;
```

---
#### 46


` File: packages/form-palette/src/variants/core/date.tsx`  [↑ Back to top](#index)

```tsx
import ShadcnDateVariant from "@/presets/shadcn-variants/date";
import { VariantModuleFor } from "@/schema/variant";


export const dateVariant: VariantModuleFor<"date"> = {
   variant: "date",
   Variant: ShadcnDateVariant as any,

   // Optional layout defaults – tweak as you like
   defaults: {
      layout: {
         fullWidth: true,
         // You can set defaultSize/defaultDensity here if you want:
         // defaultSize: "md",
         // defaultDensity: "normal",
      },
   },

   meta: {
      label: "Date",
      description:
         "Date input with calendar picker.",
      tags: ["date", "calendar", "picker"],
   },
}
```

---
#### 47


` File: packages/form-palette/src/variants/core/editor.ts`  [↑ Back to top](#index)

```ts
import { VariantModule } from "@/schema/variant";
import { ShadcnEditorVariant } from "@/presets/shadcn-variants/editor";

export const shadcnEditorVariant: VariantModule<"editor"> = {
    variant: "editor",
    Variant: ShadcnEditorVariant,
    meta: {
        label: "Editor",
        description: "Toast UI Editor (vanilla @toast-ui/editor).",
        tags: ["editor", "rich-text", "markdown", "toast-ui"],
    },
};
```

---
#### 48


` File: packages/form-palette/src/variants/core/file.tsx`  [↑ Back to top](#index)

```tsx
import ShadcnFileVariant from "@/presets/shadcn-variants/file";
import { VariantModule } from "@/schema/variant";



export const fileManagerModule: VariantModule<'file'> = {
   Variant: ShadcnFileVariant as any,
   variant: 'file'
}
```

---
#### 49


` File: packages/form-palette/src/variants/core/json-editor.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/json-editor.tsx

import type { VariantModule } from "@/schema/variant";
import ShadcnJsonEditorVariant from "@/presets/shadcn-variants/json-editor";
import type { ShadcnJsonEditorProps } from "@/presets/shadcn-variants/json-editor/types";
import Ajv from "ajv";

const ajv = new Ajv({
    allErrors: true,
    strict: false,
});

/**
 * Core JSON Editor variant module.
 */
export const jsonEditorVariant: VariantModule<"json-editor"> = {
    variant: "json-editor",

    // Visual component: Shadcn-based JSON editor
    Variant: ShadcnJsonEditorVariant as any,

    // Validation logic
    validate(value, { props }) {
        const { schema } = props;
        let resolvedSchema = schema;

        // If schema is a string, try to parse it as JSON
        if (typeof schema === "string") {
            try {
                resolvedSchema = JSON.parse(schema);
            } catch (e) {
                // If it's not valid JSON, we can't use it for validation
                // It might be a schema ID/name, so we skip AJV validation here
                resolvedSchema = null;
            }
        }

        // Only try a validation if the schema property is provided (as an object)
        if (resolvedSchema && typeof resolvedSchema === "object") {
            try {
                const validate = ajv.compile(resolvedSchema);
                const valid = validate(value);

                if (!valid) {
                    // Return the first error message or a generic one
                    const error = validate.errors?.[0];
                    return error ? `${error.instancePath} ${error.message}`.trim() : "Invalid JSON structure";
                }
            } catch (e) {
                // Compilation error (e.g. invalid schema format)
                return `Schema Error: ${e instanceof Error ? e.message : String(e)}`;
            }
        }

        return true;
    },

    // Layout defaults for this variant
    defaults: {
        layout: {
            labelPlacement: "top",
            sublabelPlacement: "right",
            descriptionPlacement: "below",
            helpTextPlacement: "below",
            errorTextPlacement: "below",
            inline: false,
            fullWidth: true,
            defaultSize: "md",
            defaultDensity: "comfortable",
        },
    },

    meta: {
        label: "JSON Editor",
        description: "Advanced JSON editor with visual and raw modes",
        tags: ["json", "editor", "object", "array"],
    },
};

export default jsonEditorVariant;
```

---
#### 50


` File: packages/form-palette/src/variants/core/keyvalue.tsx`  [↑ Back to top](#index)

```tsx
import ShadcnKeyValueVariant from "@/presets/shadcn-variants/keyvalue";
import { VariantModule } from "@/schema/variant";


export const keyValueModule: VariantModule<'keyvalue'> = {
   variant: 'keyvalue',
   Variant: ShadcnKeyValueVariant,

   meta: {
      label: ''
   }
}
```

---
#### 51


` File: packages/form-palette/src/variants/core/lister.tsx`  [↑ Back to top](#index)

```tsx
import { VariantModule } from "@/schema/variant";
import ShadcnListerVariant from "@/presets/shadcn-variants/lister";

const module: VariantModule<"lister"> = {
    variant: "lister",
    Variant: ShadcnListerVariant,

    // Layout defaults for this variant
    defaults: {
        layout: {
            labelPlacement: "top",
            sublabelPlacement: "right",
            descriptionPlacement: "below",
            helpTextPlacement: "below",
            errorTextPlacement: "below",
            inline: false,
            fullWidth: true,
            defaultSize: "md",
            defaultDensity: "comfortable",
        },
    },

    meta: {
        label: "Lister",
        description:
            "Select/multi-select powered by the Lister runtime (popover body only).",
        tags: ["select", "multiselect", "popover", "lister"],
    },
};

export default module;
```

---
#### 52


` File: packages/form-palette/src/variants/core/multiselect.tsx`  [↑ Back to top](#index)

```tsx


// src/variants/multi-select.ts

import type { VariantModule } from "@/schema/variant";
import {
   ShadcnMultiSelectVariant,
   type ShadcnMultiSelectVariantProps,
} from "@/presets/shadcn-variants/multiselect";

export type MultiSelectValue = (string | number)[] | undefined;


/**
 * Variant module for "multi-select".
 *
 * No defaults / layout overrides here — layout is driven by InputField +
 * host overrides, same as your other variants.
 */
export const multiSelectVariantModule: VariantModule<"multi-select"> = {
   variant: "multi-select",
   Variant: ShadcnMultiSelectVariant,
   meta: {
      
   }
};

export default multiSelectVariantModule;
```

---
#### 53


` File: packages/form-palette/src/variants/core/number.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/text.tsx

import * as React from "react";

import type { Dict } from "@/schema/core";
import type { VariantModule } from "@/schema/variant";
import type { ValidateResult } from "@/schema/input-field";
import { ShadcnTextVariant } from "@/presets/shadcn-variants/text";
import type { ShadcnTextUiProps } from "@/presets/shadcn-variants/text";
import { ShadcnNumberVariant, ShadcnNumberVariantProps } from "@/presets/shadcn-variants/number";

/**
 * Text variant props (core layer).
 *
 * - Extends Dict so it can cleanly participate in the Variants registry.
 * - Extends the Shadcn UI props so the core variant can pass everything
 *   straight through to the underlying visual component.
 *
 * This is where we hang *semantic* flags that drive validation.
 */
export interface TextVariantProps extends Dict, ShadcnTextUiProps {
   /**
    * If true, the value will be trimmed before validation.
    * (Visual value is still whatever the user types; this is just for
    * validation semantics.)
    */
   trim?: boolean;

   /**
    * Minimum allowed string length (after optional trimming).
    */
   minLength?: number;

   /**
    * Maximum allowed string length (after optional trimming).
    */
   maxLength?: number;
}

/**
 * Simple validation helper for the text variant.
 */
function validateText(
   value: number | undefined,
   ctx: {
      required?: boolean;
      props: ShadcnNumberVariantProps;
   }
): ValidateResult {
   const { required, props } = ctx;
   const { minLength, maxLength } = props;

   const raw = (value ?? "") + "";
   const v = raw.trim();

   // required
   if (required && v.length === 0) {
      return "This field is required.";
   }

   // minLength
   if (typeof minLength === "number" && v.length > 0 && v.length < minLength) {
      return `Please enter at least ${minLength} characters.`;
   }

   // maxLength
   if (typeof maxLength === "number" && v.length > maxLength) {
      return `Please enter no more than ${maxLength} characters.`;
   }

   return true;
}

/**
 * Core text variant module.
 *
 * - Uses ShadcnTextVariant as the visual component.
 * - Adds simple length-based validation.
 * - Provides layout defaults for InputField to use.
 */
export const numberVariant: VariantModule<"number"> = {
   variant: "number",

   // Visual component: Shadcn-based text input
   Variant: ShadcnNumberVariant as any,

   // Validation logic (runs before/alongside per-field onValidate)
   validate(value, { required, props, field, form }) {
      // field + form are available if you need them later.
      return validateText(value, { required, props });
   },

   // Layout defaults for this variant
   defaults: {
      layout: {
         labelPlacement: "top",
         sublabelPlacement: "right",
         descriptionPlacement: "below",
         helpTextPlacement: "below",
         errorTextPlacement: "below",
         inline: false,
         fullWidth: true,
         defaultSize: "md",
         defaultDensity: "comfortable",
      },
   },

   meta: {
      label: "Number",
      description: "Single-line number input",
      tags: ["number", "input", "integer", "float"],
   },
};

export default numberVariant;
```

---
#### 54


` File: packages/form-palette/src/variants/core/password.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/password.tsx

import type { VariantModuleFor } from "@/schema/variant";
import { ShadcnPasswordVariant } from "@/presets/shadcn-variants/password";

/**
 * Core module for the "password" variant.
 *
 * - Uses the ShadcnPasswordVariant UI (Input + reveal toggle + strength meter).
 * - Value type is string | undefined (from Variants["password"].value).
 * - Props are ShadcnPasswordVariantProps (from Variants["password"].props).
 */
export const passwordVariant: VariantModuleFor<"password"> = {
   variant: "password",
   Variant: ShadcnPasswordVariant,

   // Optional layout defaults – tweak as you like
   defaults: {
      layout: {
         fullWidth: true,
         // You can set defaultSize/defaultDensity here if you want:
         // defaultSize: "md",
         // defaultDensity: "normal",
      },
   },

   meta: {
      label: "Password",
      description:
         "Password input with reveal toggle and optional strength meter.",
      tags: ["auth", "security", "password"],
   },
};

export default passwordVariant;
```

---
#### 55


` File: packages/form-palette/src/variants/core/phone.tsx`  [↑ Back to top](#index)

```tsx
// ———————————————————————————————
// VariantModule wiring

import { ShadcnPhoneVariant } from "@/presets/shadcn-variants/phone";
import { VariantModule } from "@/schema/variant";

// ———————————————————————————————
export const PhoneVariantModule: VariantModule<"phone"> = {
   variant: "phone",
   Variant: ShadcnPhoneVariant,
   meta: {
      label: "Phone",
      description: "Phone number input with country code and masking.",
      tags: ["phone", "tel", "contact"],
   },
};
```

---
#### 56


` File: packages/form-palette/src/variants/core/radio.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/radio.ts

import type { VariantModuleFor } from "@/schema/variant";
import { ShadcnRadioVariant } from "@/presets/shadcn-variants/radio";

/**
 * Built-in "radio" variant module.
 *
 * Uses the Shadcn-based implementation in presets/shadcn-variants/radio.tsx
 */
export const radioVariantModule: VariantModuleFor<"radio"> = {
   variant: "radio",
   // Note: registry-level typing uses unknown, but the component itself is generic.
   Variant: ShadcnRadioVariant as any,
   defaults: {
      layout: {
         // Standard stacked field layout; the smart renderer still
         // handles ordering/relative roots for helpers.
         labelPlacement: "top",
         sublabelPlacement: "right",
         descriptionPlacement: "below",
         helpTextPlacement: "below",
         errorTextPlacement: "below",
         inline: false,
         fullWidth: true,

         // Explicit layout hints
         defaultSize: "md",
         defaultDensity: "comfortable", // ← uses your FieldDensity union
      },
   },
   meta: {
      label: "Radio group",
      description:
         "Choose one option from a list of mutually exclusive choices.",
      tags: ["choice", "select", "exclusive", "radio"],
   },
};
```

---
#### 57


` File: packages/form-palette/src/variants/core/select.tsx`  [↑ Back to top](#index)

```tsx
import ShadcnSelectVariant, { ShadcnSelectVariantProps } from "@/presets/shadcn-variants/select";
import { VariantModuleFor } from "@/schema/variant";

export type SelectVariantProps = ShadcnSelectVariantProps;

export const selectModule: VariantModuleFor<"select"> = {
   variant: "select",
   Variant: ShadcnSelectVariant,

   meta: {
      label: "Select",
      description: "Single-value dropdown based on Shadcn Select.",
      tags: ["select", "dropdown", "single-value"],
   },
};
```

---
#### 58


` File: packages/form-palette/src/variants/core/slider.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/slider.ts

import type { ValidateResult } from "@/schema/input-field";
import type { ShadcnSliderVariantProps } from "@/presets/shadcn-variants/slider";
import { ShadcnSliderVariant } from "@/presets/shadcn-variants/slider";
import { VariantModule } from "@/schema/variant";

/**
 * Slider value type:
 * - `number | undefined` for now (single-value slider).
 *   If/when you add range support, this can be widened to [number, number].
 */
export type SliderValue = number | undefined;


/**
 * Basic validation:
 * - if required → must have a numeric value
 * - otherwise always OK
 */
function validateSlider(
   value: SliderValue,
   ctx: { required?: boolean }
): ValidateResult {
   if (ctx.required) {
      if (value === undefined || value === null) {
         return "Required.";
      }
      if (typeof value !== "number" || Number.isNaN(value)) {
         return "Invalid number.";
      }
   }

   // You could optionally enforce min/max here using ctx.props
   return true;
}

/**
 * Register the slider variant with the global registry.
 *
 * No layout defaults are provided here:
 * - layout (inline vs stacked, label placement, etc.) is controlled by
 *   the host via FieldLayoutConfig / InputField overrides instead.
 */
export default {
   variant: "slider",
   Variant: ShadcnSliderVariant,
   validate(value, ctx): ValidateResult {
      return validateSlider(value as SliderValue, {
         required: ctx.required,
      });
   },
} as VariantModule<'slider'>;

export type SliderVariantProps = ShadcnSliderVariantProps;
```

---
#### 59


` File: packages/form-palette/src/variants/core/text.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/text.tsx

import * as React from "react";

import type { Dict } from "@/schema/core";
import type { VariantModule } from "@/schema/variant";
import type { ValidateResult } from "@/schema/input-field";
import { ShadcnTextVariant } from "@/presets/shadcn-variants/text";
import type { ShadcnTextUiProps, ShadcnTextVariantProps } from "@/presets/shadcn-variants/text";

/**
 * Text variant props (core layer).
 *
 * - Extends Dict so it can cleanly participate in the Variants registry.
 * - Extends the Shadcn UI props so the core variant can pass everything
 *   straight through to the underlying visual component.
 *
 * This is where we hang *semantic* flags that drive validation.
 */
export interface TextVariantProps extends Dict, ShadcnTextUiProps {
    /**
     * If true, the value will be trimmed before validation.
     * (Visual value is still whatever the user types; this is just for
     * validation semantics.)
     */
    trim?: boolean;

    /**
     * Minimum allowed string length (after optional trimming).
     */
    minLength?: number;

    /**
     * Maximum allowed string length (after optional trimming).
     */
    maxLength?: number;
}

/**
 * Simple validation helper for the text variant.
 */
function validateText(
    value: string | undefined,
    ctx: {
        required?: boolean;
        props: ShadcnTextVariantProps & TextVariantProps;
    }
): ValidateResult {
    const { required, props } = ctx;
    const { trim, minLength, maxLength } = props;

    const raw = value ?? "";
    const v = trim ? raw.trim() : raw;

    // required
    if (required && v.length === 0) {
        return "This field is required.";
    }

    // minLength
    if (typeof minLength === "number" && v.length > 0 && v.length < minLength) {
        return `Please enter at least ${minLength} characters.`;
    }

    // maxLength
    if (typeof maxLength === "number" && v.length > maxLength) {
        return `Please enter no more than ${maxLength} characters.`;
    }

    return true;
}

/**
 * Core text variant module.
 *
 * - Uses ShadcnTextVariant as the visual component.
 * - Adds simple length-based validation.
 * - Provides layout defaults for InputField to use.
 */
export const textVariant: VariantModule<"text"> = {
    variant: "text",

    // Visual component: Shadcn-based text input
    Variant: ShadcnTextVariant,

    // Validation logic (runs before/alongside per-field onValidate)
    validate(value, { required, props, field, form }) {
        //@ts-ignore field + form are available if you need them later.
        return validateText(value, { required, props });
    },

    // Layout defaults for this variant
    defaults: {
        layout: {
            labelPlacement: "top",
            sublabelPlacement: "right",
            descriptionPlacement: "below",
            helpTextPlacement: "below",
            errorTextPlacement: "below",
            inline: false,
            fullWidth: true,
            defaultSize: "md",
            defaultDensity: "comfortable",
        },
    },

    meta: {
        label: "Text",
        description: "Single-line text input",
        tags: ["text", "input", "string"],
    },
};

export default textVariant;
```

---
#### 60


` File: packages/form-palette/src/variants/core/textarea.tsx`  [↑ Back to top](#index)

```tsx
import ShadcnTextareaVariant from "@/presets/shadcn-variants/textarea";
import { VariantModuleFor } from "@/schema/variant";


export const textareaVariant: VariantModuleFor<"textarea"> = {
   variant: "textarea",
   Variant: ShadcnTextareaVariant as any,
   // Optional layout defaults – tweak as you like
   defaults: {
      layout: {
         fullWidth: true,
         // You can set defaultSize/defaultDensity here if you want:
         // defaultSize: "md",
         // defaultDensity: "normal",
      },
   },
   meta: {
      label: "Textarea",
      description: "Multi-line text input area.",
      tags: ["text", "multiline", "comments", "notes"],
   },
}
```

---
#### 61


` File: packages/form-palette/src/variants/core/toggle-group.tsx`  [↑ Back to top](#index)

```tsx
// ———————————————————————————————
// VariantModule wiring

import { ShadcnToggleVariant } from "@/presets/shadcn-variants/toggle-group";
import { VariantModule } from "@/schema/variant";

// ———————————————————————————————
export const toggleGroupModule: VariantModule<"toggle-group"> = {
   variant: "toggle-group",
   Variant: ShadcnToggleVariant,
   meta: {
      label: "Toggle group",
      description: "Toggle group component buttons.",
      tags: ["buttons", "toggle"],
   },
};
```

---
#### 62


` File: packages/form-palette/src/variants/core/toggle.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/toggle.ts

import type { VariantModuleFor } from "@/schema/variant";
import type { FieldLayoutConfig } from "@/schema/input-field";
import ShadcnToggleVariant from "@/presets/shadcn-variants/toggle";

export const toggleLayoutDefaults: FieldLayoutConfig = {
   // Render label + control in a single row
   inline: true,

   // Semantically: label is to the "right" of the control for this variant.
   // (Your InputField can use this to decide macro-level positioning.)
   labelPlacement: "right",

   // Attach all helpers to the label root by default.
   // Sublabel will still use its own placement (default: "right"),
   // but it's logically anchored to the label block.
   relativeRoots: {
      sublabel: "label",
      description: "label",
      helpText: "label",
      errorText: "label",
   },

   fullWidth: false,

   // Within the label root, show error first, then description, then help,
   // then sublabel (all still respecting their individual placements).
   ordering: {
      label: ["errorText", "description", "helpText", "sublabel"],
      // For this variant we don't really use input-root helpers,
      // but we keep the key for completeness.
      input: [],
   },
};

export const ToggleVariantModule: VariantModuleFor<"toggle"> = {
   variant: "toggle",
   Variant: ShadcnToggleVariant as any,
   defaults: {
      layout: toggleLayoutDefaults,
   },
   meta: {
      label: "Toggle",
      description: "Boolean on/off switch",
      tags: ["boolean", "toggle", "switch"],
   },
};

export default ToggleVariantModule;
```

---
#### 63


` File: packages/form-palette/src/variants/core/treeselect.tsx`  [↑ Back to top](#index)

```tsx
import ShadcnTreeSelectVariant from "@/presets/shadcn-variants/treeselect";
import { VariantModule } from "@/schema/variant";



const treeselectModule: VariantModule<'treeselect'> = {
   variant: 'treeselect',
   Variant: ShadcnTreeSelectVariant as any
}

export default treeselectModule
```

---
#### 64


` File: packages/form-palette/src/variants/index.ts`  [↑ Back to top](#index)

```ts
// src/variants/index.ts

import {
    registerVariant as _register,
    getVariant as _get,
    listVariants as _list,
} from "@/variants/registry";
import type {
    VariantKey,
    VariantModule,
    VariantValueFor,
    VariantPropsFor,
} from "@/schema/variant";
import { textVariant } from "@/variants/core/text";
import { numberVariant } from "./core/number";
import { PhoneVariantModule } from "./core/phone";
import { ColorVariantModule } from "./core/color";
import passwordVariant from "./core/password";
import { dateVariant } from "./core/date";
import { chipVariant } from "./core/chips";
import { textareaVariant } from "./core/textarea";
import ToggleVariantModule from "./core/toggle";
import { radioVariantModule } from "./core/radio";
import { checkboxModule } from "./core/checkbox";
import { selectModule } from "./core/select";
import multiSelectVariantModule from "./core/multiselect";
import sliderModule from './core/slider'
import { keyValueModule } from "./core/keyvalue";
import customVariant from "./core/custom";
import treeselectModule from "./core/treeselect";
import { fileManagerModule } from "./core/file";
import { toggleGroupModule } from "./core/toggle-group";
import { shadcnEditorVariant } from "@/variants/core/editor";
import { jsonEditorVariant } from "./core/json-editor";
import listerVariant from "./core/lister";

export type { VariantKey, VariantModule, VariantValueFor, VariantPropsFor };
export {
    _register as registerVariant,
    _get as getVariant,
    _list as listVariants,
};
export { textVariant };


const variants = [
    textVariant,
    numberVariant,
    PhoneVariantModule,
    ColorVariantModule,
    passwordVariant,
    dateVariant,
    chipVariant,
    textareaVariant,
    ToggleVariantModule,
    radioVariantModule,
    checkboxModule,
    selectModule,
    multiSelectVariantModule,
    sliderModule,
    keyValueModule,
    customVariant,
    treeselectModule,
    fileManagerModule,
    toggleGroupModule,
    shadcnEditorVariant,
    jsonEditorVariant,
    listerVariant
]

/**
 * Register all core/built-in variants.
 *
 * Hosts can call this once at bootstrap:
 *
 *   import { registerCoreVariants } from "@timeax/form-palette/variants";
 *   registerCoreVariants();
 */
export function registerCoreVariants(): void {
    variants.forEach(item => _register(item as any))
}

registerCoreVariants();
```

---
#### 65


` File: packages/form-palette/src/variants/registry.ts`  [↑ Back to top](#index)

```ts
// src/variants/registry.ts

import type { VariantKey, VariantModule } from "@/schema/variant";

/**
 * Internal storage for registered variants.
 */
const registry = new Map<VariantKey, VariantModule<any>>();

/**
 * Register (or overwrite) a variant module.
 *
 * Typically called from presets, e.g.:
 *
 *   registerVariant(textVariant);
 *   registerVariant(numberVariant);
 */
export function registerVariant<K extends VariantKey>(
    module: VariantModule<K>
): void {
    registry.set(module.variant, module as VariantModule<any>);
}

/**
 * Look up a variant module by key.
 */
export function getVariant<K extends VariantKey>(
    key: K
): VariantModule<K> | undefined {
    return registry.get(key) as VariantModule<K> | undefined;
}

/**
 * List all registered variant modules.
 */
export function listVariants(): VariantModule<VariantKey>[] {
    return Array.from(registry.values()) as VariantModule<VariantKey>[];
}
```

---
#### 66


` File: packages/form-palette/src/variants/shared.ts`  [↑ Back to top](#index)

```ts
// src/variants/shared.ts

import React from "react";

/**
 * Size hint for field variants.
 *
 * Presets can interpret these however they like (font size, padding, etc.).
 */
export type FieldSize = "sm" | "md" | "lg";

/**
 * Density hint for field variants.
 *
 * - "compact"     → tight vertical spacing
 * - "comfortable" → default spacing
 * - "loose"       → extra breathing room
 */
export type FieldDensity = "compact" | "comfortable" | "loose";

/**
 * Logical source of a change event.
 *
 * Variants and utilities can tag changes to help the host reason
 * about where a value came from.
 */
export type ChangeSource =
    | "variant"
    | "paste"
    | "programmatic"
    | "util"
    | (string & {}); // allow custom tags

/**
 * Additional context passed along with value changes.
 */
export interface ChangeDetail<TMeta = unknown, TRaw = unknown> {
    /**
     * Logical source for this change.
     */
    source: ChangeSource;

    /**
     * Optional raw input that produced this value.
     *
     * Example: original keyboard input or pasted string.
     */
    raw?: TRaw;

    nativeEvent?: React.SyntheticEvent;
    /**
     * Variant-specific metadata (e.g. cursor position).
     */
    meta?: TMeta;
}

/**
 * Base props shared by all variant components.
 *
 * Each variant module will extend this with its own props type.
 */
export interface VariantBaseProps<TValue> {
    /**
     * Current logical value for this field.
     */
    value?: TValue | undefined;

    /**
     * Called whenever the variant wants to update the value.
     *
     * The detail payload describes where the change came from.
     */
    onValue?(value: TValue | undefined, detail?: ChangeDetail): void;

    /**
     * State flags.
     */
    disabled?: boolean;
    defaultValue?: any;
    readOnly?: boolean;
    required?: boolean;

    alias?: string;
    main?: boolean;
    /**
     * Current error message for this field, if any.
     */
    error?: string;

    /**
     * Size & density hints.
     *
     * Variants are free to ignore these, but presets (e.g. Shadcn)
     * will typically honour them.
     */
    size?: FieldSize;
    density?: FieldDensity;
}

export interface Extras {
    trailingIcons?: React.ReactNode[];
    leadingIcons?: React.ReactNode[];
    icon?: React.ReactNode;
    iconGap?: number;
    trailingIconSpacing?: number;
    leadingIconSpacing?: number;
    trailingControl?: React.ReactNode;
    leadingControl?: React.ReactNode;
    /**
     * Optional className applied to the container that wraps the leading control.
     * This does not affect the control node itself, only the wrapper div.
     */
    leadingControlClassName?: string;
    /**
     * Optional className applied to the container that wraps the trailing control.
     * This does not affect the control node itself, only the wrapper div.
     */
    trailingControlClassName?: string;
    px?: number;
    py?: number
    pb?: number;
    pe?: number;
    ps?: number;
}

export type ExtraFieldProps<Props> = Extras & Props;
```


---
*Generated with [Prodex](https://github.com/emxhive/prodex) — Codebase decoded.*
<!-- PRODEx v1.4.9 | 2025-12-30T01:27:36.158Z -->