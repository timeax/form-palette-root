# Index  L8-L23 

> Note for LLMs: `Lx-Ly` ranges refer to lines in this Prodex trace file, not the original source files.

*Generated by [Prodex](https://github.com/emxhive/prodex#readme)*

Included Source Files: 16
- [packages/form-palette/src/presets/lister/engine/details.ts](#1)  L26-L80
- [packages/form-palette/src/presets/lister/engine/extract.ts](#2)  L81-L203
- [packages/form-palette/src/presets/lister/engine/http.ts](#3)  L204-L274
- [packages/form-palette/src/presets/lister/engine/map.ts](#4)  L275-L326
- [packages/form-palette/src/presets/lister/engine/search.ts](#5)  L327-L574
- [packages/form-palette/src/presets/lister/engine/selection.ts](#6)  L575-L615
- [packages/form-palette/src/presets/lister/hooks/use-data.ts](#7)  L616-L1325
- [packages/form-palette/src/presets/lister/hooks/use-lister.ts](#8)  L1326-L1466
- [packages/form-palette/src/presets/lister/index.ts](#9)  L1467-L1480
- [packages/form-palette/src/presets/lister/lister-ui.tsx](#10)  L1481-L1870
- [packages/form-palette/src/presets/lister/provider.tsx](#11)  L1871-L3491
- [packages/form-palette/src/presets/lister/types.ts](#12)  L3492-L4210
- [packages/form-palette/src/presets/lister/ui/filter-ui.tsx](#13)  L4211-L4585
- [packages/form-palette/src/presets/lister/ui/search.tsx](#14)  L4586-L5034
- [packages/form-palette/src/presets/lister/utils/path.ts](#15)  L5035-L5070
- [packages/form-palette/src/presets/lister/utils/permissions.ts](#16)  L5071-L5116

---
---
#### 1


` File: packages/form-palette/src/presets/lister/engine/details.ts`  [↑ Back to top](#index)

```ts
// resources/js/context/lister/engine/details.ts

import type { ListerDetails, ListerId, ListerMode, ListerOption, ListerRawForMode, ListerValueForMode } from '../types';

function toArray<T>(v: T | T[] | null | undefined): T[] {
    if (v == null) return [];
    return Array.isArray(v) ? v : [v];
}

/**
 * Recommended ordering: preserve selection order (draftValue order).
 */
export function buildDetails<TRaw, TValue extends ListerId, TMeta, TMode extends ListerMode>(args: {
    mode: TMode;
    draftValue: ListerValueForMode<TValue, TMode>;
    optionsList: Array<ListerOption<TRaw, TValue, TMeta>>;
    action: ListerDetails<TRaw, TValue, TMeta, TMode>['action'];
}): ListerDetails<TRaw, TValue, TMeta, TMode> {
    const { mode, draftValue, optionsList, action } = args;

    const byValue = new Map<TValue, ListerOption<TRaw, TValue, TMeta>>();
    for (const opt of optionsList) byValue.set(opt.value, opt);

    if (mode === 'multiple') {
        const values = toArray(draftValue as TValue[]);
        const options = values.map((v) => byValue.get(v)).filter(Boolean) as Array<ListerOption<TRaw, TValue, TMeta>>;
        const raw = options.map((o) => o.raw).filter(Boolean) as TRaw[];

        return {
            action,
            options: options as any,
            raw: raw as ListerRawForMode<TRaw, TMode>,
        } as any;
    }

    // single
    const v = draftValue as TValue | null;
    const opt = v == null ? null : (byValue.get(v) ?? null);
    const raw = opt?.raw ?? null;

    return {
        action,
        options: opt as any,
        raw: raw as any,
    } as any;
}
```

---
#### 2


` File: packages/form-palette/src/presets/lister/engine/extract.ts`  [↑ Back to top](#index)

```ts
// resources/js/context/lister/engine/extract.ts

import type { Selector } from "../types";
import { getPath } from "../utils/path";

function typeOf(v: any): string {
    if (v === null) return "null";
    if (Array.isArray(v)) return "array";
    return typeof v;
}

function safeKeys(v: any, limit = 25): string[] {
    if (!v || typeof v !== "object" || Array.isArray(v)) return [];
    try {
        return Object.keys(v).slice(0, limit);
    } catch {
        return [];
    }
}

function preview(v: any): any {
    const t = typeOf(v);

    if (t === "array") {
        const arr = v as any[];
        return {
            type: "array",
            length: arr.length,
            firstType: arr.length ? typeOf(arr[0]) : "empty",
        };
    }

    if (t === "object") {
        return {
            type: "object",
            keys: safeKeys(v, 15),
        };
    }

    if (t === "string") {
        const s = String(v);
        return { type: "string", length: s.length, sample: s.slice(0, 80) };
    }

    return { type: t, value: v };
}

function makeExtractError(details: Record<string, any>): Error {
    const err = new Error("EXTRACT_NOT_ARRAY");
    // keep message stable for your existing errorCode mapping,
    // but attach rich diagnostics for host logging
    (err as any).details = details;
    return err;
}

export function extractArray<TRaw>(
    body: any,
    selector?: Selector<TRaw>,
): TRaw[] {
    // ─────────────────────────────────────────────
    // Selector path (contract: MUST return array)
    // ─────────────────────────────────────────────
    if (selector) {
        const extracted =
            typeof selector === "function"
                ? selector(body)
                : getPath(body, selector);

        if (!Array.isArray(extracted)) {
            throw makeExtractError({
                stage: "selector",
                selectorType: typeof selector,
                selector: typeof selector === "string" ? selector : "[fn]",
                body: preview(body),
                extracted: preview(extracted),
                bodyKeys: safeKeys(body),
                bodyData: preview(body?.data),
                bodyDataKeys: safeKeys(body?.data),
            });
        }

        return extracted as TRaw[];
    }

    // ─────────────────────────────────────────────
    // Default extraction (robust)
    // Supports:
    // - body is already an array
    // - Axios response: body.data
    // - Payload: body.data
    // - Axios + Payload: body.data.data
    // ─────────────────────────────────────────────

    if (Array.isArray(body)) return body as TRaw[];

    if (Array.isArray(body?.data)) return body.data as TRaw[];

    if (Array.isArray(body?.data?.data)) return body.data.data as TRaw[];

    // Optional extras (uncomment if you want):
    // if (Array.isArray(body?.results)) return body.results as TRaw[];
    // if (Array.isArray(body?.data?.results)) return body.data.results as TRaw[];

    throw makeExtractError({
        stage: "default",
        tried: ["body", "body.data", "body.data.data"],
        body: preview(body),
        bodyKeys: safeKeys(body),
        bodyData: preview(body?.data),
        bodyDataKeys: safeKeys(body?.data),
        bodyDataData: preview(body?.data?.data),
        bodyDataDataKeys: safeKeys(body?.data?.data),
    });
}
```

---
#### 3


` File: packages/form-palette/src/presets/lister/engine/http.ts`  [↑ Back to top](#index)

```ts
// resources/js/context/lister/engine/http.ts

type HttpReq = {
    endpoint: string;
    method: "GET" | "POST";
    params?: any;
    body?: any;
    headers?: any;
};

export type ListerHttpClient = (req: HttpReq) => Promise<any>;

export function defaultHttpClient(): ListerHttpClient {
    // Prefer window.axios (your app convention), but fall back to importing axios if available.
    // This avoids throwing just because window.axios isn't wired yet.
    const w = window as any;

    // Cache the resolved client so we don't re-check on every request.
    let client: any = w?.axios ?? null;

    async function resolveAxios(): Promise<any> {
        if (client) return client;

        // 1) If window.axios appears later (e.g. after bootstrap), pick it up.
        if (w?.axios) {
            client = w.axios;
            return client;
        }

        // 2) Try to lazy-load axios (works in ESM/Vite/webpack environments where axios is installed)
        try {
            const mod: any = await import("axios");
            client = mod?.default ?? mod;
            return client;
        } catch {
            // ignore — we’ll throw below with a clear message
        }

        throw new Error(
            "Axios client not found. Ensure axios is installed and either (1) expose it as window.axios or (2) allow ESM import('axios') in this build.",
        );
    }

    return async (req) => {
        const ax = await resolveAxios();
        const method = (req.method ?? "GET").toUpperCase();

        if (method === "GET") {
            const res = await ax.get(req.endpoint, {
                params: req.params,
                headers: req.headers,
            });
            return res?.data;
        }

        const res = await ax.post(req.endpoint, req.body ?? {}, {
            params: req.params,
            headers: req.headers,
        });
        return res?.data;
    };
}
```

---
#### 4


` File: packages/form-palette/src/presets/lister/engine/map.ts`  [↑ Back to top](#index)

```ts
// resources/js/context/lister/engine/map.ts

import type { ListerId, ListerMapping, ListerOption, Resolver } from '../types';
import { getPath } from '../utils/path';

export function resolveWith<TOut, TRaw, TCtx>(resolver: Resolver<TOut, TRaw, TCtx>, raw: TRaw, ctx: TCtx): TOut {
    if (typeof resolver === 'function') return resolver(raw, ctx);
    return getPath(raw, resolver) as TOut;
}

export function mapOptions<TRaw, TValue extends ListerId, TMeta, TCtx>(
    rawList: TRaw[],
    mapping: ListerMapping<TRaw, TValue, TMeta, TCtx>,
    ctx: TCtx,
): Array<ListerOption<TRaw, TValue, TMeta>> {
    const opts: Array<ListerOption<TRaw, TValue, TMeta>> = [];

    for (const raw of rawList) {
        const value = resolveWith(mapping.optionValue, raw, ctx);

        const label =
            mapping.optionLabel != null
                ? resolveWith(mapping.optionLabel, raw, ctx)
                : // default label: raw.label ?? String(value)
                  ((raw as any)?.label ?? String(value));

        const option: ListerOption<TRaw, TValue, TMeta> = {
            value,
            label,
            raw, // ✅ v0.1: always attach raw by default
        };

        if (mapping.optionIcon) option.icon = resolveWith(mapping.optionIcon, raw, ctx);
        if (mapping.optionDescription) option.description = resolveWith(mapping.optionDescription, raw, ctx);
        if (mapping.optionDisabled) option.disabled = Boolean(resolveWith(mapping.optionDisabled, raw, ctx));
        if (mapping.optionGroup) option.group = resolveWith(mapping.optionGroup, raw, ctx);
        if (mapping.optionMeta) option.meta = resolveWith(mapping.optionMeta, raw, ctx);

        opts.push(option);
    }

    return opts;
}
```

---
#### 5


` File: packages/form-palette/src/presets/lister/engine/search.ts`  [↑ Back to top](#index)

```ts
// resources/js/context/lister/engine/search.ts

import type { ListerId, ListerOption, ListerSearchPayload } from "../types";

type AnyObj = Record<string, any>;

function optionText<TRaw, TValue extends ListerId, TMeta>(
    o: ListerOption<TRaw, TValue, TMeta>,
): string {
    const l = o.label;
    if (typeof l === "string") return l;
    if (typeof l === "number") return String(l);

    const rl = (o.raw as any)?.label;
    if (typeof rl === "string") return rl;

    return String(o.value);
}

function getPath(obj: any, path: string): any {
    if (!obj || !path) return undefined;
    if (!path.includes(".")) return (obj as any)[path];

    let cur = obj;
    for (const part of path.split(".")) {
        if (cur == null) return undefined;
        cur = cur[part];
    }
    return cur;
}

function toText(v: any): string {
    if (v == null) return "";
    if (typeof v === "string") return v;
    if (typeof v === "number" || typeof v === "boolean") return String(v);
    return "";
}

function collectAllText(
    obj: any,
    out: string[],
    depth = 2,
    budget = { n: 80 },
) {
    if (obj == null || budget.n <= 0) return;

    const t = typeof obj;

    if (t === "string" || t === "number" || t === "boolean") {
        out.push(String(obj));
        budget.n -= 1;
        return;
    }

    if (depth <= 0) return;

    if (Array.isArray(obj)) {
        for (const x of obj) collectAllText(x, out, depth - 1, budget);
        return;
    }

    if (t === "object") {
        for (const k of Object.keys(obj)) {
            collectAllText(obj[k], out, depth - 1, budget);
            if (budget.n <= 0) break;
        }
    }
}

function matchQueryInText(q: string, text: string): boolean {
    if (!q) return true;
    return text.toLowerCase().includes(q);
}

// inside resources/js/context/lister/engine/search.ts

function buildSearchTextForKeys(
    raw: any,
    keys: Array<string | number>,
): string {
    const parts: string[] = [];

    for (const k of keys) {
        const key = String(k); // ✅ supports number ids
        const v = getPath(raw, key);
        if (v == null) continue;

        if (Array.isArray(v)) {
            for (const x of v) {
                const s = toText(x);
                if (s) parts.push(s);
            }
            continue;
        }

        const s = toText(v);
        if (s) parts.push(s);
    }

    return parts.join(" ");
}

function matchesSearch(
    raw: any,
    q: string,
    search?: ListerSearchPayload,
): boolean {
    if (!q) return true;

    if (search?.searchAll) {
        return matchQueryInText(q, buildSearchTextAll(raw));
    }

    if (Array.isArray(search?.searchOnly) && search.searchOnly.length) {
        return matchQueryInText(
            q,
            buildSearchTextForKeys(raw, search.searchOnly),
        );
    }

    if (typeof search?.subject === "string" && search.subject) {
        return matchQueryInText(
            q,
            buildSearchTextForKeys(raw, [search.subject]),
        );
    }

    return matchQueryInText(q, buildSearchTextAll(raw));
}

function buildSearchTextAll(raw: any): string {
    const parts: string[] = [];
    collectAllText(raw, parts, 2);
    return parts.join(" ");
}

function isEmptyFilterValue(v: any): boolean {
    if (v === undefined || v === null) return true;
    if (typeof v === "string" && v.trim() === "") return true;
    return Array.isArray(v) && v.length === 0;
}

function matchesFilters(raw: AnyObj, filters?: AnyObj): boolean {
    if (!filters) return true;

    for (const key of Object.keys(filters)) {
        // ignore reserved-ish keys if they appear
        if (
            key === "search" ||
            key === "subject" ||
            key === "searchAll" ||
            key === "searchOnly"
        ) {
            continue;
        }

        const fv = filters[key];
        if (isEmptyFilterValue(fv)) continue;

        const rv = getPath(raw, key);

        // array filter => "any-of"
        if (Array.isArray(fv)) {
            if (Array.isArray(rv)) {
                const ok = rv.some((x) => fv.includes(x));
                if (!ok) return false;
            } else {
                if (!fv.includes(rv)) return false;
            }
            continue;
        }

        // scalar filter
        if (Array.isArray(rv)) {
            if (!rv.includes(fv)) return false;
            continue;
        }

        // basic equality (stringified)
        if (String(rv) !== String(fv)) return false;
    }

    return true;
}

/**
 * Local equivalent of remote filtering:
 * - filters (effective filters)
 * - + search payload (subject/all/only)
 *
 * You can override everything by providing:
 * - (filtersSpec as any).local(rawList, ctx) => rawList
 * - (searchSpec as any).local(rawList, ctx) => rawList
 */
export function filterRawListLocal<TRaw>(
    rawList: TRaw[],
    query: string,
    search?: ListerSearchPayload,
    filters?: any,
    opts?: { searchSpec?: any; filtersSpec?: any },
): TRaw[] {
    let list = Array.isArray(rawList) ? rawList : [];

    const ctx = { query, search, filters };

    const filtersLocal = opts?.filtersSpec && (opts.filtersSpec as any).local;
    if (typeof filtersLocal === "function") {
        const out = filtersLocal(list, ctx);
        if (Array.isArray(out)) list = out;
    } else {
        list = list.filter((r: any) =>
            matchesFilters(r as any, filters as any),
        );
    }

    const q = (query ?? "").trim().toLowerCase();
    if (!q) return list;

    const searchLocal = opts?.searchSpec && (opts.searchSpec as any).local;
    if (typeof searchLocal === "function") {
        const out = searchLocal(list, ctx);
        if (Array.isArray(out)) return out;
    }

    return list.filter((r: any) => matchesSearch(r, q, search));
}

/**
 * Backwards-compatible (kept), still useful for quick “label contains”
 * in places where you DON'T have rawList + payload.
 */
export function filterOptionsLocal<TRaw, TValue extends ListerId, TMeta>(
    options: Array<ListerOption<TRaw, TValue, TMeta>>,
    query: string,
): Array<ListerOption<TRaw, TValue, TMeta>> {
    const q = (query ?? "").trim().toLowerCase();
    if (!q) return options;
    return options.filter((o) => optionText(o).toLowerCase().includes(q));
}
```

---
#### 6


` File: packages/form-palette/src/presets/lister/engine/selection.ts`  [↑ Back to top](#index)

```ts
// resources/js/context/lister/engine/selection.ts

import type { ListerChangeEvent, ListerId, ListerMode, ListerValueForMode } from '../types';

export function makeChangeEvent(): ListerChangeEvent {
    let prevented = false;
    return {
        get defaultPrevented() {
            return prevented;
        },
        preventDefault() {
            prevented = true;
        },
    };
}

export function computeNextDraft<TValue extends ListerId, TMode extends ListerMode>(
    mode: TMode,
    draftValue: ListerValueForMode<TValue, TMode>,
    clicked: TValue,
): { nextDraft: ListerValueForMode<TValue, TMode>; action: 'select' | 'deselect' } {
    if (mode === 'multiple') {
        const arr = (draftValue as TValue[]) ?? [];
        const has = arr.includes(clicked);
        const next = has ? arr.filter((v) => v !== clicked) : [...arr, clicked];
        return { nextDraft: next as any, action: has ? 'deselect' : 'select' };
    }

    const cur = draftValue as TValue | null;
    if (cur === clicked) return { nextDraft: null as any, action: 'deselect' }; // ✅ toggle off
    return { nextDraft: clicked as any, action: 'select' };
}
```

---
#### 7


` File: packages/form-palette/src/presets/lister/hooks/use-data.ts`  [↑ Back to top](#index)

```ts
// packages/form-palette/src/presets/lister/hooks/use-data.ts

import * as React from "react";
import { Ctx, buildSearchPayloadFromTarget } from "@/presets/lister";
import { makeInlineDef } from "@/presets/shadcn-variants/lister/patch";

import type {
    ListerSearchMode,
    ListerSearchPayload,
    ListerSearchTarget,
} from "@/presets/lister/types";

/**
 * Minimal selector contract (matches extractArray contract used by lister)
 * - function: (body) => array
 * - string: path selector
 */
export type DataSelector<T> = ((body: any) => T[]) | string;

export type DataSearchConfig = {
    default?: string;
};

export type DataBuildRequestCtx<TFilters> = {
    filters?: TFilters;
    query: string;
    cursor: any;
};

export type DataBuildRequestResult = {
    params?: any;
    body?: any;
    headers?: any;
};

export type DataKey = string | number;

export type DataSelectionMode = "none" | "single" | "multiple";

export type DataSelectionKey<TItem> =
    | keyof TItem
    | string
    | ((item: TItem) => DataKey | null | undefined);

export type DataSelectionConfig<TItem> = {
    mode?: Exclude<DataSelectionMode, "none">;
    /**
     * How to resolve the ID for an item.
     * - string/ keyof: item[key]
     * - function: (item) => id
     * Defaults to: item.id ?? item.value
     */
    key?: DataSelectionKey<TItem>;
    /**
     * If "missing", selection IDs that don't exist in the *latest fetched list* are removed.
     * Default: "never" (recommended; avoids wiping selection on remote searches).
     */
    prune?: "never" | "missing";
};

export type UseDataOptions<TItem = any, TFilters = Record<string, any>> = {
    id?: string;

    endpoint: string;
    method?: "GET" | "POST";

    selector?: DataSelector<TItem>;

    /**
     * Passed through into the inline def source.buildRequest (same signature as provider)
     */
    buildRequest?: (
        ctx: DataBuildRequestCtx<TFilters>,
    ) => DataBuildRequestResult;

    /**
     * Minimal search config (default subject column).
     */
    search?: DataSearchConfig;

    /**
     * Raw filters object
     */
    filters?: TFilters;

    initial?: TItem[];

    enabled?: boolean;
    fetchOnMount?: boolean;

    searchMode?: ListerSearchMode;
    debounceMs?: number;

    autoFetchOnFilterChange?: boolean;

    /**
     * Optional selection support (by stable item key)
     */
    selection?: DataSelectionConfig<TItem>;
};

export type UseDataResult<TItem = any, TFilters = Record<string, any>> = {
    id?: string;

    data: TItem[];
    visible: TItem[];

    loading: boolean;
    error: any;

    query: string;
    setQuery: (q: string) => void;

    searchMode: ListerSearchMode;
    setSearchMode: (m: ListerSearchMode) => void;

    searchTarget?: ListerSearchTarget;
    setSearchTarget: (t: ListerSearchTarget) => void;

    filters?: TFilters;
    setFilters: (next: TFilters | undefined) => void;
    patchFilters: (patch: Partial<TFilters>) => void;
    clearFilters: () => void;

    // selection
    selectionMode: DataSelectionMode;
    selectedIds: DataKey | DataKey[] | null;
    selected: TItem | TItem[] | null;

    select: (id: DataKey | DataKey[]) => void;
    deselect: (id: DataKey | DataKey[]) => void;
    toggle: (id: DataKey) => void;
    clearSelection: () => void;
    isSelected: (id: DataKey) => boolean;
    getSelection: () => TItem | TItem[] | null;

    refresh: () => void;

    fetch: (override?: {
        query?: string;
        filters?: TFilters;
        searchTarget?: ListerSearchTarget;
    }) => Promise<TItem[]>;
};

function defaultSearchTarget(
    search?: DataSearchConfig,
): ListerSearchTarget | undefined {
    const def = search?.default;
    return def ? { mode: "subject", subject: def, only: null } : undefined;
}

function isKey(x: any): x is DataKey {
    return typeof x === "string" || typeof x === "number";
}

function stringifyForSearch(v: any): string {
    if (v == null) return "";
    if (typeof v === "string") return v;
    if (
        typeof v === "number" ||
        typeof v === "boolean" ||
        typeof v === "bigint"
    ) {
        return String(v);
    }
    if (v instanceof Date) {
        return Number.isNaN(v.getTime()) ? "" : v.toISOString();
    }
    if (Array.isArray(v)) {
        return v.map(stringifyForSearch).join(" ");
    }
    if (typeof v === "object") {
        try {
            return JSON.stringify(v);
        } catch {
            return String(v);
        }
    }
    return String(v);
}

export function useData<TItem = any, TFilters = Record<string, any>>(
    opts: UseDataOptions<TItem, TFilters>,
): UseDataResult<TItem, TFilters> {
    const ctx = React.useContext(Ctx);
    if (!ctx) throw new Error("useData must be used within <ListerProvider />");

    const enabled = opts.enabled ?? true;
    const debounceMs = opts.debounceMs ?? 300;

    const [data, setData] = React.useState<TItem[]>(() => opts.initial ?? []);
    const [loading, setLoading] = React.useState(false);
    const [error, setError] = React.useState<any>(undefined);

    const dataRef = React.useRef<TItem[]>(data);
    React.useEffect(() => {
        dataRef.current = data;
    }, [data]);

    const [query, _setQuery] = React.useState("");
    const [searchMode, _setSearchMode] = React.useState<ListerSearchMode>(
        opts.searchMode ?? "remote",
    );

    const [searchTarget, _setSearchTarget] = React.useState<
        ListerSearchTarget | undefined
    >(() => defaultSearchTarget(opts.search));

    const [filters, _setFilters] = React.useState<TFilters | undefined>(
        opts.filters,
    );

    // selection config
    const selectionMode: DataSelectionMode = opts.selection?.mode ?? "none";
    const selectionPrune = opts.selection?.prune ?? "never";

    const getItemKey = React.useMemo(() => {
        const key = opts.selection?.key;

        // default: item.id ?? item.value
        if (!key) {
            return (item: any): DataKey | null => {
                const v = item?.id ?? item?.value;
                return isKey(v) ? v : null;
            };
        }

        if (typeof key === "function") {
            return (item: TItem): DataKey | null => {
                const v = key(item);
                return isKey(v) ? v : null;
            };
        }

        // string/ keyof
        return (item: any): DataKey | null => {
            const v = item?.[key as any];
            return isKey(v) ? v : null;
        };
    }, [opts.selection?.key]);

    /**
     * IMPORTANT:
     * Keep internal selection state as an array ALWAYS.
     * This avoids TS union issues (DataKey | DataKey[] | null) in setState callbacks.
     */
    const [selectedIdsArr, setSelectedIdsArr] = React.useState<DataKey[]>([]);

    // cache id -> latest known item (so selection can return objects even after list changes)
    const selectedCacheRef = React.useRef<Map<DataKey, TItem>>(new Map());

    // last-request-wins
    const reqIdRef = React.useRef(0);

    // debounce timer (remote/hybrid typing)
    const timerRef = React.useRef<any>(null);

    // avoid effect double-fetch
    const didMountRef = React.useRef(false);

    // prevent mode switch immediate-fetch from also triggering the debounce effect fetch
    const skipNextModeEffectRef = React.useRef(false);

    React.useEffect(() => {
        return () => {
            if (timerRef.current) clearTimeout(timerRef.current);
        };
    }, []);

    // ✅ inline def built from minimal inputs
    const inlineDef = React.useMemo(() => {
        return makeInlineDef({
            id: opts.id,
            endpoint: opts.endpoint,
            method: (opts.method ?? "GET") as any,
            selector: opts.selector,
            buildRequest: opts.buildRequest,
            search: opts.search,
        } as any);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        opts.id,
        opts.endpoint,
        opts.method,
        opts.selector,
        opts.buildRequest,
        opts.search,
    ]);

    const dataById = React.useMemo(() => {
        const map = new Map<DataKey, TItem>();
        if (selectionMode === "none") return map;

        for (const item of data) {
            const k = getItemKey(item);
            if (k == null) continue;
            map.set(k, item);
        }
        return map;
    }, [data, getItemKey, selectionMode]);

    const normalizeIds = React.useCallback((v: DataKey | DataKey[]) => {
        return Array.isArray(v) ? v : [v];
    }, []);

    const commitSelectedCache = React.useCallback(
        (list: TItem[]) => {
            if (selectionMode === "none") return;

            for (const item of list) {
                const k = getItemKey(item);
                if (k == null) continue;
                selectedCacheRef.current.set(k, item);
            }
        },
        [getItemKey, selectionMode],
    );

    /**
     * Fetch from provider using same semantics as Lister:
     * - payload derived from searchTarget (or override)
     * - filters passed through buildRequest/params
     */
    const fetchImpl = React.useCallback(
        async (override?: {
            query?: string;
            filters?: TFilters;
            searchTarget?: ListerSearchTarget;
            search?: ListerSearchPayload;
        }): Promise<TItem[]> => {
            if (!enabled) return dataRef.current;

            const q = override?.query ?? query;
            const f = override?.filters ?? filters;
            const t = override?.searchTarget ?? searchTarget;

            const myReq = ++reqIdRef.current;

            setLoading(true);
            setError(undefined);

            try {
                const payload: ListerSearchPayload | undefined =
                    override?.search ?? buildSearchPayloadFromTarget(t);

                const res = await ctx.apiFetchAny(inlineDef as any, f, {
                    query: q,
                    search: payload,
                });

                const list = (res?.rawList ?? res?.raw ?? []) as TItem[];

                // last-request-wins (DON'T update state if stale)
                if (reqIdRef.current !== myReq) return list;

                // cache items for selection lookup (latest request only)
                commitSelectedCache(list);

                // optional prune (latest request only)
                if (selectionMode !== "none" && selectionPrune === "missing") {
                    const nextIds = new Set<DataKey>();
                    for (const item of list) {
                        const k = getItemKey(item);
                        if (k != null) nextIds.add(k);
                    }
                    setSelectedIdsArr((prev) =>
                        prev.filter((x) => nextIds.has(x)),
                    );
                }

                setData(list);
                setLoading(false);
                return list;
            } catch (e: any) {
                if (reqIdRef.current !== myReq) return dataRef.current;
                setError(e);
                setLoading(false);
                return dataRef.current;
            }
        },
        [
            enabled,
            query,
            filters,
            searchTarget,
            ctx,
            inlineDef,
            commitSelectedCache,
            selectionMode,
            selectionPrune,
            getItemKey,
        ],
    );

    const refresh = React.useCallback(() => {
        void fetchImpl();
    }, [fetchImpl]);

    const setQuery = React.useCallback((q: string) => _setQuery(q), []);

    /**
     * Mode switch semantics:
     * - switching to local: fetch a "base list" once (query "", no search payload)
     * - switching to remote/hybrid: immediate fetch (skip next debounced effect fetch)
     */
    const setSearchMode = React.useCallback(
        (m: ListerSearchMode) => {
            if (timerRef.current) clearTimeout(timerRef.current);

            if (m === "remote" || m === "hybrid") {
                skipNextModeEffectRef.current = true;
                _setSearchMode(m);
                void fetchImpl();
                return;
            }

            _setSearchMode(m);

            if (m === "local") {
                void fetchImpl({
                    query: "",
                    search: undefined,
                });
            }
        },
        [fetchImpl],
    );

    const setSearchTarget = React.useCallback((t: ListerSearchTarget) => {
        _setSearchTarget(t);
        // debounced fetch is handled by the query/searchTarget effect
    }, []);

    const setFilters = React.useCallback(
        (next: TFilters | undefined) => _setFilters(next),
        [],
    );

    const patchFilters = React.useCallback((patch: Partial<TFilters>) => {
        _setFilters((prev) => ({
            ...(prev ?? ({} as any)),
            ...(patch as any),
        }));
    }, []);

    const clearFilters = React.useCallback(() => _setFilters(undefined), []);

    const fetchOnMount = opts.fetchOnMount ?? !opts.initial;

    React.useEffect(() => {
        if (!enabled) return;
        if (!fetchOnMount) return;
        void fetchImpl();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    /**
     * Debounced fetch on query/searchTarget changes (remote/hybrid only)
     */
    React.useEffect(() => {
        if (!enabled) return;

        if (!didMountRef.current) {
            didMountRef.current = true;
            return;
        }

        if (searchMode !== "remote" && searchMode !== "hybrid") return;

        if (skipNextModeEffectRef.current) {
            skipNextModeEffectRef.current = false;
            return;
        }

        if (timerRef.current) clearTimeout(timerRef.current);

        timerRef.current = setTimeout(() => {
            void fetchImpl();
        }, debounceMs);

        return () => {
            if (timerRef.current) clearTimeout(timerRef.current);
        };
    }, [debounceMs, enabled, fetchImpl, query, searchMode, searchTarget]);

    /**
     * Filter changes:
     * - auto fetch in remote/hybrid
     * - local mode doesn't need fetch; filtering is client-side over base dataset
     */
    React.useEffect(() => {
        if (!enabled) return;
        if (opts.autoFetchOnFilterChange === false) return;
        if (!didMountRef.current) return;

        if (searchMode !== "remote" && searchMode !== "hybrid") return;

        void fetchImpl();
    }, [enabled, fetchImpl, filters, opts.autoFetchOnFilterChange, searchMode]);

    /**
     * Visible list (local/hybrid):
     * Uses provider payload shape:
     * - subject => search only that field
     * - searchAll => search stringify
     * - searchOnly => restrict to IDs
     */
    const visible = React.useMemo(() => {
        if (searchMode !== "local" && searchMode !== "hybrid") return data;

        const payload = buildSearchPayloadFromTarget(searchTarget);
        let list = data;

        // apply "only" restriction (if provided)
        if (payload?.searchOnly && payload.searchOnly.length) {
            const allow = new Set(payload.searchOnly as any[]);
            list = list.filter((item) => {
                const k = getItemKey(item);
                return k != null && allow.has(k as any);
            });
        }

        const q = query.trim();
        if (!q) return list;

        const ql = q.toLowerCase();

        // subject search
        if (payload?.subject) {
            const key = payload.subject;
            return list.filter((item: any) =>
                String(item?.[key] ?? "")
                    .toLowerCase()
                    .includes(ql),
            );
        }

        // all / fallback
        return list.filter((item: any) =>
            stringifyForSearch(item).toLowerCase().includes(ql),
        );
    }, [data, getItemKey, query, searchMode, searchTarget]);

    // ─────────────────────────────────────────────
    // Selection API (internal array, derived outward shape)
    // ─────────────────────────────────────────────

    const selectedIds: DataKey | DataKey[] | null = React.useMemo(() => {
        if (selectionMode === "none") return null;
        if (selectionMode === "single") return selectedIdsArr[0] ?? null;
        return selectedIdsArr;
    }, [selectionMode, selectedIdsArr]);

    const isSelected = React.useCallback(
        (id: DataKey) => {
            if (selectionMode === "none") return false;
            return selectedIdsArr.includes(id);
        },
        [selectedIdsArr, selectionMode],
    );

    const clearSelection = React.useCallback(() => {
        if (selectionMode === "none") return;
        setSelectedIdsArr([]);
    }, [selectionMode]);

    const select = React.useCallback(
        (idOrIds: DataKey | DataKey[]) => {
            if (selectionMode === "none") return;

            const ids = normalizeIds(idOrIds).filter(isKey);
            if (!ids.length) return;

            // hydrate cache if we already have the object
            for (const id of ids) {
                const hit = dataById.get(id);
                if (hit) selectedCacheRef.current.set(id, hit);
            }

            if (selectionMode === "single") {
                setSelectedIdsArr([ids[0]]);
                return;
            }

            setSelectedIdsArr((prev) => {
                const set = new Set<DataKey>(prev);
                for (const id of ids) set.add(id);
                return Array.from(set);
            });
        },
        [dataById, normalizeIds, selectionMode],
    );

    const deselect = React.useCallback(
        (idOrIds: DataKey | DataKey[]) => {
            if (selectionMode === "none") return;

            const ids = new Set(normalizeIds(idOrIds).filter(isKey));
            if (!ids.size) return;

            setSelectedIdsArr((prev) => {
                const next = prev.filter((x) => !ids.has(x));
                if (selectionMode === "single") return next.slice(0, 1);
                return next;
            });
        },
        [normalizeIds, selectionMode],
    );

    const toggle = React.useCallback(
        (id: DataKey) => {
            if (selectionMode === "none") return;

            const hit = dataById.get(id);
            if (hit) selectedCacheRef.current.set(id, hit);

            if (selectionMode === "single") {
                setSelectedIdsArr((prev) => (prev[0] === id ? [] : [id]));
                return;
            }

            setSelectedIdsArr((prev) => {
                const set = new Set<DataKey>(prev);
                if (set.has(id)) set.delete(id);
                else set.add(id);
                return Array.from(set);
            });
        },
        [dataById, selectionMode],
    );

    const selected = React.useMemo((): TItem | TItem[] | null => {
        if (selectionMode === "none") return null;

        if (selectionMode === "single") {
            const id = selectedIdsArr[0];
            if (id == null) return null;
            return dataById.get(id) ?? selectedCacheRef.current.get(id) ?? null;
        }

        const out: TItem[] = [];
        for (const id of selectedIdsArr) {
            const item =
                dataById.get(id) ?? selectedCacheRef.current.get(id) ?? null;
            if (item) out.push(item);
        }
        return out;
    }, [dataById, selectedIdsArr, selectionMode]);

    const getSelection = React.useCallback(() => selected, [selected]);

    // keep internal array shape aligned with mode
    React.useEffect(() => {
        if (selectionMode === "none") {
            setSelectedIdsArr([]);
            return;
        }
        if (selectionMode === "single") {
            setSelectedIdsArr((prev) => (prev.length ? [prev[0]] : []));
        }
    }, [selectionMode]);

    return {
        id: opts.id,

        data,
        visible,

        loading,
        error,

        query,
        setQuery,

        searchMode,
        setSearchMode,

        searchTarget,
        setSearchTarget,

        filters,
        setFilters,
        patchFilters,
        clearFilters,

        selectionMode,
        selectedIds,
        selected,

        select,
        deselect,
        toggle,
        clearSelection,
        isSelected,
        getSelection,

        refresh,
        fetch: fetchImpl,
    };
}
```

---
#### 8


` File: packages/form-palette/src/presets/lister/hooks/use-lister.ts`  [↑ Back to top](#index)

```ts
import {
    AnyDef,
    AnyState,
    Ctx,
    ListerApi,
    ListerFilterCtx,
    ListerId,
    ListerSearchMode,
    ListerSearchPayload,
    ListerSearchTarget,
    ListerSessionId,
    ListerStoreState,
    PresetMap,
} from "@/presets/lister";
import * as React from "react";

export function useLister<P extends PresetMap>(): {
    api: ListerApi<P>;
    store: ListerStoreState;
    /** active session convenience (can be undefined if none open) */
    state: AnyState | undefined;
    actions: {
        focus(id: ListerSessionId): void;
        dispose(id: ListerSessionId): void;

        apply(id: ListerSessionId): void;
        cancel(id: ListerSessionId): void;
        close(id: ListerSessionId): void;

        toggle(id: ListerSessionId, value: ListerId): void;
        select(id: ListerSessionId, value: ListerId): void;
        deselect(id: ListerSessionId, value: ListerId): void;
        clear(id: ListerSessionId): void;

        setQuery(id: ListerSessionId, q: string): void;
        setSearchMode(id: ListerSessionId, mode: ListerSearchMode): void;
        setSearchTarget(id: ListerSessionId, target: ListerSearchTarget): void;

        searchLocal: {
            (id: ListerSessionId, q: string): void;
            (
                id: ListerSessionId,
                q: string,
                payload?: ListerSearchPayload,
            ): void;
        };

        searchRemote: {
            (id: ListerSessionId, q: string): void;
            (
                id: ListerSessionId,
                q: string,
                payload?: ListerSearchPayload,
            ): void;
        };

        refresh(id: ListerSessionId): void;
        setPosition(
            id: ListerSessionId,
            pos: { x: number; y: number } | null,
        ): void;

        /** Filters (non-UI logic) */
        getFilterCtx<TFilters>(id: ListerSessionId): ListerFilterCtx<TFilters>;
        applyFilterOption(id: ListerSessionId, optionId: string | number): void;

        registerPreset(kind: string, def: AnyDef): void;
        getPreset(kind: string): AnyDef | undefined;

        getVisibleOptions(id: ListerSessionId): any[];
    };
} {
    const ctx = React.useContext(Ctx);
    if (!ctx)
        throw new Error("useLister must be used within <ListerProvider />");

    const api = React.useMemo(() => {
        const fetch = ((kindOrDef: any, filters?: any, opts?: any) =>
            ctx.apiFetchAny(kindOrDef, filters, opts)) as ListerApi<P>["fetch"];
        const open = ((kindOrDef: any, filters?: any, opts?: any) =>
            ctx.apiOpenAny(kindOrDef, filters, opts)) as ListerApi<P>["open"];

        return {
            fetch,
            open,
            registerPreset: (kind: string, def: AnyDef) =>
                ctx.registerPreset(kind, def),
            getPreset: (kind: string) => ctx.getPreset(kind),
        } satisfies ListerApi<P>;
    }, [ctx]);

    const active = ctx.store.activeId
        ? (ctx.store.sessions[ctx.store.activeId] as AnyState | undefined)
        : undefined;

    return {
        api,
        store: ctx.store,
        state: active,
        actions: {
            focus: ctx.focus,
            dispose: ctx.dispose,

            apply: ctx.apply,
            cancel: ctx.cancel,
            close: ctx.close,

            toggle: ctx.toggle,
            select: ctx.select,
            deselect: ctx.deselect,
            clear: ctx.clear,

            setQuery: ctx.setQuery,
            setSearchMode: ctx.setSearchMode,
            setSearchTarget: ctx.setSearchTarget,

            searchLocal: ctx.searchLocal,
            searchRemote: ctx.searchRemote,

            refresh: ctx.refresh,
            setPosition: ctx.setPosition,

            getFilterCtx: ctx.getFilterCtx,
            applyFilterOption: ctx.applyFilterOption,

            registerPreset: ctx.registerPreset,
            getPreset: ctx.getPreset,

            getVisibleOptions: ctx.getVisibleOptions,
        },
    };
}
```

---
#### 9


` File: packages/form-palette/src/presets/lister/index.ts`  [↑ Back to top](#index)

```ts
export * from "./provider";
export * from "./lister-ui";
export * from "./types";
export * from "./hooks/use-lister";
export * from "./hooks/use-data";
```

---
#### 10


` File: packages/form-palette/src/presets/lister/lister-ui.tsx`  [↑ Back to top](#index)

```tsx
// resources/js/context/lister/lister-ui.tsx

import * as React from "react";

import type {
    ListerId,
    ListerMode,
    ListerOption,
    ListerSessionId,
    ListerStoreState,
} from "./types";
import { useLister } from ".";

import { Popover, PopoverContent, PopoverTrigger } from "@/presets/ui/popover";
import { ScrollArea } from "@/presets/ui/scroll-area";
import { Separator } from "@/presets/ui/separator";
import { Button } from "@/presets/ui/button";
import { cn } from "@/lib/utils";

import {
    Check,
    GripVertical,
    RefreshCw,
    X,

} from "lucide-react";
import { SearchBar } from "./ui/search";

type AnyPresetMap = any;

export function ListerUI() {
    const { store } = useLister<AnyPresetMap>();
    if (!store.order.length) return null;

    return (
        <>
            {store.order.map((id) => (
                <ListerSessionPopover key={String(id)} id={id} store={store} />
            ))}
        </>
    );
}

function ListerSessionPopover(props: {
    id: ListerSessionId;
    store: ListerStoreState;
}) {
    const { id, store } = props;
    const { actions } = useLister<AnyPresetMap>();

    const session = store.sessions[id] as any;
    if (!session?.isOpen) return null;

    const isActive = store.activeId === id;
    const title = session.title ?? session.kind ?? "Select";
    const showRefresh = !!session.showRefresh;

    const fixed = session.position
        ? {
              position: "fixed" as const,
              left: session.position.x,
              top: session.position.y,
              zIndex: 1000 + store.order.indexOf(id),
          }
        : {
              position: "fixed" as const,
              right: 24,
              bottom: 24 + store.order.indexOf(id) * 12,
              zIndex: 1000 + store.order.indexOf(id),
          };

    const onOpenChange = (open: boolean) => {
        if (open) {
            actions.focus(id);
            return;
        }
        actions.close(id);
    };

    return (
        <div style={fixed}>
            <Popover open={true} onOpenChange={onOpenChange}>
                <PopoverTrigger asChild>
                    <button
                        type="button"
                        onMouseDown={() => actions.focus(id)}
                        aria-hidden
                        className="hidden"
                    />
                </PopoverTrigger>

                <PopoverContent
                    align="start"
                    side="bottom"
                    className={cn(
                        "w-105 overflow-hidden rounded-lg border bg-background p-0 shadow-lg",
                        isActive && "ring-2 ring-primary/30",
                    )}
                    onOpenAutoFocus={(e) => e.preventDefault()}
                    onPointerDownOutside={() => actions.focus(id)}
                    onFocusOutside={() => actions.focus(id)}
                >
                    <HeaderBar
                        id={id}
                        title={title}
                        loading={!!session.loading}
                        refreshing={!!session.refreshing}
                        showRefresh={showRefresh}
                        draggable={!!session.draggable}
                        onRefresh={() => actions.refresh(id)}
                        onClose={() => actions.close(id)}
                    />

                    <Separator />

                    <SearchBar id={id} store={store} />

                    <Separator />

                    <OptionList id={id} />

                    <Separator />

                    <FooterBar
                        id={id}
                        mode={session.mode as ListerMode}
                        confirm={!!session.confirm}
                        onClear={() => actions.clear(id)}
                        onCancel={() => actions.cancel(id)}
                        onApply={() => actions.apply(id)}
                    />
                </PopoverContent>
            </Popover>
        </div>
    );
}

export function HeaderBar(props: {
    id: ListerSessionId;
    title: string;
    loading: boolean;
    refreshing: boolean;
    showRefresh: boolean;
    draggable: boolean;
    onRefresh(): void;
    onClose(): void;
}) {
    const { actions } = useLister<AnyPresetMap>();

    return (
        <div
            className="flex items-center justify-between gap-2 px-3 py-2"
            onMouseDown={() => actions.focus(props.id)}
        >
            <div className="flex min-w-0 items-center gap-2">
                {props.draggable && (
                    <GripVertical className="h-4 w-4 shrink-0 opacity-60" />
                )}
                <div className="min-w-0">
                    <div className="truncate text-sm font-medium">
                        {props.title}
                    </div>
                    <div className="text-xs opacity-60">
                        {props.loading
                            ? "Loading…"
                            : props.refreshing
                              ? "Refreshing…"
                              : " "}
                    </div>
                </div>
            </div>

            <div className="flex items-center gap-1">
                {props.showRefresh && (
                    <Button
                        type="button"
                        size="sm"
                        variant={"ghost"}
                        onClick={props.onRefresh}
                        disabled={props.loading || props.refreshing}
                    >
                        <RefreshCw className="h-4 w-4" />
                    </Button>
                )}

                <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={props.onClose}
                >
                    <X className="h-4 w-4" />
                </Button>
            </div>
        </div>
    );
}

/**
 * Search bar + trailing controls:
 * - Search mode toggle (remote/local/hybrid)
 * - Filters treeselect (button mode)
 *
 * Notes:
 * - We bind search mode to session.searchMode and update via actions.setSearchMode(id, mode)
 * - Filters use session.filtersSpec?.options and session.selectedFilterValues
 * - On change, we diff and call actions.applyFilterOption(id, value) for both add/remove
 */
export { SearchBar } from "./ui/search";

export function OptionList(props: { id: ListerSessionId; className?: string }) {
    const { store, actions } = useLister<AnyPresetMap>();
    const s = store.sessions[props.id] as any;

    const options: Array<ListerOption<any, any, any>> =
        actions.getVisibleOptions(props.id) as any[];

    const draft = s?.draftValue;
    const isMulti = s?.mode === "multiple";

    const isSelected = (value: ListerId) => {
        if (isMulti) return Array.isArray(draft) && draft.includes(value);
        return draft === value;
    };

    return (
        <ScrollArea className={cn("max-h-85", props.className)}>
            <div className="p-1 space-y-1">
                {s?.errorCode ? (
                    <div className="px-3 py-4 text-sm opacity-70">
                        Error: {String(s.errorCode)}
                    </div>
                ) : s?.loading && !s?.optionsList?.length ? (
                    <div className="px-3 py-4 text-sm opacity-70">Loading…</div>
                ) : options.length === 0 ? (
                    <div className="px-3 py-4 text-sm opacity-70">
                        No results
                    </div>
                ) : (
                    options.map((opt) => {
                        const selected = isSelected(opt.value as any);
                        const disabled = !!opt.disabled;

                        const onClick = () => {
                            if (disabled) return;
                            actions.toggle(props.id, opt.value as any);
                        };

                        if (typeof s?.renderOption === "function") {
                            return (
                                <div
                                    key={String(opt.value)}
                                    className="px-1 py-1"
                                >
                                    {s.renderOption({
                                        option: opt,
                                        state: {
                                            selected,
                                            active: store.activeId === props.id,
                                            mode: s.mode,
                                        },
                                        actions: {
                                            toggle: () =>
                                                actions.toggle(
                                                    props.id,
                                                    opt.value,
                                                ),
                                            select: () =>
                                                actions.select(
                                                    props.id,
                                                    opt.value,
                                                ),
                                            deselect: () =>
                                                actions.deselect(
                                                    props.id,
                                                    opt.value,
                                                ),
                                        },
                                        ctx: {
                                            query: s.query,
                                            filters:
                                                s.effectiveFilters ?? s.filters,
                                        },
                                    })}
                                </div>
                            );
                        }

                        return (
                            <button
                                key={String(opt.value)}
                                type="button"
                                onMouseDown={() => actions.focus(props.id)}
                                onClick={onClick}
                                disabled={disabled}
                                className={cn(
                                    "flex w-full items-start gap-2 rounded-sm px-3 py-2 text-left",
                                    "transition hover:bg-muted/60",
                                    selected && "bg-muted",
                                    disabled && "cursor-not-allowed opacity-50",
                                )}
                            >
                                <div className="mt-0.5 flex h-5 w-5 shrink-0 items-center justify-center">
                                    {selected ? (
                                        <Check className="h-4 w-4" />
                                    ) : (
                                        <span className="h-4 w-4" />
                                    )}
                                </div>

                                <div className="min-w-0 flex-1">
                                    <div className="truncate text-sm font-medium">
                                        {opt.label ?? String(opt.value)}
                                    </div>
                                    {opt.description ? (
                                        <div className="line-clamp-2 text-xs opacity-70">
                                            {opt.description}
                                        </div>
                                    ) : null}
                                </div>

                                {opt.group ? (
                                    <div className="shrink-0 text-xs opacity-50">
                                        {opt.group}
                                    </div>
                                ) : null}
                            </button>
                        );
                    })
                )}
            </div>
        </ScrollArea>
    );
}

export function FooterBar(props: {
    id: ListerSessionId;
    mode: ListerMode;
    confirm: boolean;
    onClear(): void;
    onCancel(): void;
    onApply(): void;
}) {
    const { actions } = useLister<AnyPresetMap>();

    const showConfirm = props.mode === "multiple" ? true : props.confirm;

    return (
        <div
            className="flex items-center justify-between gap-2 px-3 py-2"
            onMouseDown={() => actions.focus(props.id)}
        >
            <Button
                type="button"
                variant="ghost"
                size="sm"
                onClick={props.onClear}
            >
                Clear
            </Button>

            {showConfirm ? (
                <div className="flex items-center gap-2">
                    <Button
                        type="button"
                        variant="ghost"
                        size="sm"
                        onClick={props.onCancel}
                    >
                        Cancel
                    </Button>
                    <Button type="button" size="sm" onClick={props.onApply}>
                        Apply
                    </Button>
                </div>
            ) : (
                <div className="text-xs opacity-60">Click an item to apply</div>
            )}
        </div>
    );
}
```

---
#### 11


` File: packages/form-palette/src/presets/lister/provider.tsx`  [↑ Back to top](#index)

```tsx
// resources/js/context/lister/lister-context.tsx
// noinspection GrazieInspection,SpellCheckingInspection

import * as React from "react";

import type {
    ListerDefinition,
    ListerFilterCtx,
    ListerFilterOption,
    ListerFilterSpec,
    ListerId,
    ListerLogCode,
    ListerMode,
    ListerOpenResult,
    ListerProviderHost,
    ListerRuntimeState,
    ListerSearchMode,
    ListerSearchPayload,
    ListerSearchTarget,
    ListerSessionId,
    ListerStoreState,
    PresetMap,
} from "./types";

import { buildDetails } from "./engine/details";
import { extractArray } from "./engine/extract";
import { defaultHttpClient, type ListerHttpClient } from "./engine/http";
import { mapOptions } from "./engine/map";
import { filterRawListLocal } from "./engine/search";
import { computeNextDraft, makeChangeEvent } from "./engine/selection";
import { evaluatePermissions } from "./utils/permissions";

export type AnyDef = ListerDefinition<any, any, any, any>;

/**
 * IMPORTANT:
 * Your types file may not yet include these runtime-only fields (searchSpec/searchTarget).
 * Without widening here, TS2353 will fire when we create session objects containing them.
 *
 * This keeps compilation green while you finish syncing the types.
 */
// add this extra field
export type AnyState = ListerRuntimeState<any, any, any, any, any> & {
    searchSpec?: any;
    searchTarget?: any;
    searchPayload?: any; // ✅ NEW (payload override)
    ownerKey?: string;
};

export type InternalContextValue = {
    host: ListerProviderHost;
    http: ListerHttpClient;

    // mutable preset registry
    presetsRef: React.RefObject<PresetMap>;

    store: ListerStoreState;

    // fetch
    apiFetchAny: (
        kindOrDef: string | AnyDef,
        filters?: any,
        opts?: any,
    ) => Promise<any>;

    // open
    apiOpenAny: (
        kindOrDef: string | AnyDef,
        filters?: any,
        opts?: any,
    ) => Promise<any>;

    // session lifecycle
    focus(id: ListerSessionId): void;
    dispose(id: ListerSessionId): void;

    // finalize (per session)
    apply(id: ListerSessionId): void;
    cancel(id: ListerSessionId): void;
    close(id: ListerSessionId): void;

    // selection (per session)
    toggle(id: ListerSessionId, value: ListerId): void;
    select(id: ListerSessionId, value: ListerId): void;
    deselect(id: ListerSessionId, value: ListerId): void;
    clear(id: ListerSessionId): void;

    // search (per session)
    setQuery(id: ListerSessionId, q: string): void;
    setSearchMode(id: ListerSessionId, mode: ListerSearchMode): void;

    /**
     * Persist the user's current search target (subject/all/only)
     * so all searches (local/remote/hybrid) can include it.
     */
    setSearchTarget(id: ListerSessionId, target: ListerSearchTarget): void;

    /**
     * Backwards compatible signatures:
     * - existing calls still work: searchRemote(id, q)
     * - new calls can optionally override payload: searchRemote(id, q, payload)
     *
     * If payload is omitted, implementation should read from session.searchTarget.
     */
    searchLocal: {
        (id: ListerSessionId, q: string): void;
        (id: ListerSessionId, q: string, payload?: ListerSearchPayload): void;
    };

    searchRemote: {
        (id: ListerSessionId, q: string): void;
        (id: ListerSessionId, q: string, payload?: ListerSearchPayload): void;
    };

    refresh(id: ListerSessionId): void;
    setPosition(
        id: ListerSessionId,
        pos: { x: number; y: number } | null,
    ): void;

    /** Filters (non-UI logic; per session) */
    getFilterCtx<TFilters>(id: ListerSessionId): ListerFilterCtx<TFilters>;

    /**
     * NEW semantics:
     * - `optionId` is the UI identifier of the filter option (NOT the db value)
     * - `selectedFilterValues` tracks selected option ids (for UI checkmarks/badge)
     */
    applyFilterOption(id: ListerSessionId, optionId: string | number): void;

    registerPreset(kind: string, def: AnyDef): void;
    getPreset(kind: string): AnyDef | undefined;

    /** Derived list for UI later (local/hybrid filtering) */
    getVisibleOptions(id: ListerSessionId): any[];
};

export const Ctx = React.createContext<InternalContextValue | null>(null);

function anchorToPos(anchor: any): { x: number; y: number } | null {
    if (!anchor) return null;
    if (typeof anchor === "object") {
        if (typeof anchor.x === "number" && typeof anchor.y === "number")
            return { x: anchor.x, y: anchor.y };
        if (
            typeof anchor.clientX === "number" &&
            typeof anchor.clientY === "number"
        )
            return { x: anchor.clientX, y: anchor.clientY };
    }
    return null;
}

function makeSessionId(): string {
    const anyCrypto = (globalThis as any)?.crypto;
    if (anyCrypto?.randomUUID) return anyCrypto.randomUUID();
    return `lister_${Date.now()}_${Math.random().toString(16).slice(2)}`;
}

function shallowMerge<T extends object>(
    base: T | undefined,
    patch: Partial<T>,
): T {
    return { ...(base ?? ({} as T)), ...(patch ?? {}) } as T;
}

/* ─────────────────────────────────────────────
 * Filter option resolution helpers
 * ───────────────────────────────────────────── */

export type ResolvedFilterNode<TFilters> = {
    option: ListerFilterOption<TFilters>;
    id: string; // UI id (PATH id, e.g. "email_domain.email_gmail")
    kind?: string; // "group" | "value" | "input" (host-defined)
    disabled?: boolean;
    bindKey?: string; // resolved (inherited or explicit)
    dbValue?: any; // value to push into ctx under bindKey
    apply?: {
        key?: string;
        mode?: "replace" | "merge" | "unset";
        toggleable?: boolean;
        value?: any;
    };
};

function getOptId<TFilters>(
    opt: ListerFilterOption<TFilters>,
): string | number {
    const anyOpt = opt as any;
    // preferred: explicit id
    if (anyOpt?.id != null) return anyOpt.id;
    // fallback: legacy `value` used as id
    return anyOpt?.value;
}

function getOptKind<TFilters>(
    opt: ListerFilterOption<TFilters>,
): string | undefined {
    return (opt as any)?.kind;
}

function getOptDisabled<TFilters>(opt: ListerFilterOption<TFilters>): boolean {
    return !!(opt as any)?.disabled;
}
function getOptApply<TFilters>(
    opt: ListerFilterOption<TFilters>,
): ResolvedFilterNode<TFilters>["apply"] | undefined {
    const anyOpt = opt as any;
    if (!anyOpt?.apply) return undefined;
    return {
        key: anyOpt.apply.key,
        mode: anyOpt.apply.mode,
        toggleable: anyOpt.apply.toggleable,
        value: anyOpt.apply.value,
    };
}

function getOptDbValue<TFilters>(opt: ListerFilterOption<TFilters>): any {
    const anyOpt = opt as any;
    // In the new model, "value" nodes can store their DB value separately;
    // we support a few shapes without forcing you to lock one down here.
    if (anyOpt?.dbValue !== undefined) return anyOpt.dbValue;
    if (anyOpt?.apply?.value !== undefined) return anyOpt.apply.value;
    // if you kept `value` as the db value on "value" nodes, use it
    return anyOpt?.value;
}
function hasExplicitId<TFilters>(opt: ListerFilterOption<TFilters>): boolean {
    return (opt as any)?.id != null;
}

/**
 * Node id resolution:
 * - If opt.id exists => use it AS-IS (canonical, not prefixed).
 * - Else => build a path id from the fallback (value) and prefix with parent path.
 *
 * This avoids breaking options that provide explicit ids while still supporting
 * stable path ids for options that don't.
 */
function getNodeId<TFilters>(
    opt: ListerFilterOption<TFilters>,
    parentNodeId?: string,
): string {
    // explicit id is canonical (do not prefix)
    if (hasExplicitId(opt)) return String((opt as any).id);

    // fallback id (legacy): value (or whatever getOptId returns)
    const base = String(getOptId(opt));
    return parentNodeId ? `${parentNodeId}.${base}` : base;
}

/**
 * Build an index for quick lookups by option id, while also resolving inherited bindKey.
 * - group nodes can set bindKey, inherited by children
 * - value nodes inherit bindKey unless they override it
 */
function indexFilterOptions<TFilters>(
    options: Array<ListerFilterOption<TFilters>>,
): Record<string, ResolvedFilterNode<TFilters>> {
    const out: Record<string, ResolvedFilterNode<TFilters>> = {};

    const walk = (
        list: Array<ListerFilterOption<TFilters>>,
        inheritedBindKey?: string,
        parentNodeId?: string,
    ) => {
        for (const opt of list) {
            const nodeId = getNodeId(opt, parentNodeId);
            const kind = getOptKind(opt);
            const disabled = getOptDisabled(opt);

            // resolve bindKey:
            // explicit bindKey on node wins, else inherit from parent
            const localBindKey = (opt as any)?.bindKey as string | undefined;
            const resolvedBindKey = localBindKey ?? inheritedBindKey;

            const apply = getOptApply(opt);

            // for "value" nodes, this is the payload value we will set under bindKey
            const dbValue = getOptDbValue(opt);

            out[nodeId] = {
                option: opt,
                id: nodeId,
                kind,
                disabled,
                bindKey: resolvedBindKey ?? apply?.key,
                dbValue,
                apply,
            };

            const children = (opt as any)?.children as
                | Array<ListerFilterOption<TFilters>>
                | undefined;

            if (Array.isArray(children) && children.length) {
                // Only pass parentNodeId forward if THIS node was not explicitly-id'd.
                // Because explicit ids are canonical + global; children without ids
                // should still get stable path ids when parent has no explicit id.
                const nextParentId = hasExplicitId(opt) ? parentNodeId : nodeId;
                walk(children, resolvedBindKey, nextParentId);
            }
        }
    };

    walk(options, undefined, undefined);
    return out;
}
function initialStoreState(): ListerStoreState {
    return { order: [], activeId: undefined, sessions: {} };
}

function initialSessionState(sessionId: ListerSessionId): AnyState {
    return {
        sessionId,
        createdAt: Date.now(),

        isOpen: false,
        mode: "single",
        confirm: false as any,

        draggable: true,
        position: null,
        hasMoved: false,

        searchMode: "remote",
        query: "",

        // runtime-only (widened in AnyState)
        searchSpec: undefined,
        searchTarget: undefined,
        ownerKey: undefined,

        loading: false,
        refreshing: false,

        rawList: [],
        optionsList: [],

        draftValue: null,
        initialDraftValue: null,

        refreshMode: "preserve-selection",

        // filters
        filtersSpec: undefined,
        filtersPatch: {},
        effectiveFilters: undefined,

        // IMPORTANT: these are now OPTION IDS (not db values)
        selectedFilterValues: [],
        searchPayload: undefined,
    };
}

export function buildSearchPayloadFromTarget(
    target?: ListerSearchTarget | null,
): ListerSearchPayload | undefined {
    if (!target) return undefined;

    if (target.mode === "all") return { searchAll: true };

    if (target.mode === "subject") {
        const subject = target.subject ?? undefined;
        return subject ? { subject } : undefined;
    }

    if (target.mode === "only") {
        const only = Array.isArray(target.only)
            ? target.only.filter((v) => v !== null && v !== undefined) // ✅ keep 0
            : undefined;

        return only && only.length ? { searchOnly: only } : undefined;
    }

    return undefined;
}

export function ListerProvider(props: {
    host: ListerProviderHost;
    presets?: PresetMap;
    http?: ListerHttpClient;
    /** provider-side debounce for remote search (default 300ms) */
    remoteDebounceMs?: number;
    children: React.ReactNode;
}) {
    const http = props.http ?? defaultHttpClient();

    // allow runtime registration + initial presets
    const presetsRef = React.useRef<PresetMap>({ ...(props.presets ?? {}) });

    const [store, _setStore] = React.useState<ListerStoreState>(() =>
        initialStoreState(),
    );
    const storeRef = React.useRef<ListerStoreState>(store);

    const setStore = React.useCallback(
        (updater: (prev: ListerStoreState) => ListerStoreState) => {
            _setStore((prev) => {
                const next = updater(prev);
                storeRef.current = next;
                return next;
            });
        },
        [],
    );

    // per-session latest-request-wins
    const reqIdBySessionRef = React.useRef<Record<string, number>>({});

    // per-session remote-search debounce timers
    const timerBySessionRef = React.useRef<Record<string, any>>({});

    /**
     * Find an existing session for this input instance (ownerKey),
     * so we can REUSE it across popover open/close and keep filters persistent.
     */
    const findSessionIdByOwnerKey = React.useCallback((ownerKey?: string) => {
        if (!ownerKey) return undefined;
        const sessions = storeRef.current.sessions as Record<string, AnyState>;
        for (const id of Object.keys(sessions)) {
            const s = sessions[id];
            if (s && (s as any).ownerKey === ownerKey) return id as any;
        }
        return undefined;
    }, []);

    const debounceMs = props.remoteDebounceMs ?? 300;

    const getSession = React.useCallback(
        (id: ListerSessionId): AnyState | undefined => {
            return storeRef.current.sessions[id] as AnyState | undefined;
        },
        [],
    );

    const patchSession = React.useCallback(
        (id: ListerSessionId, patch: Partial<AnyState>) => {
            setStore((s) => {
                const prev = s.sessions[id] as AnyState | undefined;
                if (!prev) return s;
                return {
                    ...s,
                    sessions: {
                        ...s.sessions,
                        [id]: { ...prev, ...patch } as AnyState,
                    },
                };
            });
        },
        [setStore],
    );

    const updateSession = React.useCallback(
        (id: ListerSessionId, fn: (prev: AnyState) => AnyState) => {
            setStore((s) => {
                const prev = s.sessions[id] as AnyState | undefined;
                if (!prev) return s;
                return {
                    ...s,
                    sessions: {
                        ...s.sessions,
                        [id]: fn(prev),
                    },
                };
            });
        },
        [setStore],
    );

    const clearSessionRefs = React.useCallback((id: ListerSessionId) => {
        if (timerBySessionRef.current[id]) {
            clearTimeout(timerBySessionRef.current[id]);
            delete timerBySessionRef.current[id];
        }
        delete reqIdBySessionRef.current[id];
    }, []);

    const focus = React.useCallback(
        (id: ListerSessionId) => {
            setStore((s) => {
                if (!s.sessions[id]) return s;
                const nextOrder = s.order.filter((x) => x !== id);
                nextOrder.push(id);
                return { ...s, order: nextOrder, activeId: id };
            });
        },
        [setStore],
    );

    const dispose = React.useCallback(
        (id: ListerSessionId) => {
            clearSessionRefs(id);
            setStore((s) => {
                if (!s.sessions[id]) return s;
                const nextSessions = { ...s.sessions };
                delete nextSessions[id];
                const nextOrder = s.order.filter((x) => x !== id);
                const nextActive =
                    s.activeId === id
                        ? nextOrder[nextOrder.length - 1]
                        : s.activeId;
                return {
                    ...s,
                    sessions: nextSessions,
                    order: nextOrder,
                    activeId: nextActive,
                };
            });
        },
        [clearSessionRefs, setStore],
    );

    const resolveAndDispose = React.useCallback(
        (id: ListerSessionId, result: any) => {
            const resolve = (
                storeRef.current.sessions[id] as AnyState | undefined
            )?._resolve;
            const s = storeRef.current.sessions[id] as AnyState | undefined;

            // Always clear timers/req tracking when a "dialog" completes.
            clearSessionRefs(id);

            // ✅ PERSISTENT sessions (ownerKey) must NOT be disposed.
            // They should simply close and keep filtersPatch/selectedFilterValues.
            if (s?.ownerKey) {
                patchSession(id, {
                    isOpen: false,
                    loading: false,
                    refreshing: false,
                    errorCode: undefined,
                    _resolve: undefined as any,
                });
                resolve?.(result);
                return;
            }

            // Default: ephemeral session lifecycle
            dispose(id);
            resolve?.(result);
        },
        [clearSessionRefs, dispose, patchSession],
    );

    const computeEffectiveFilters = React.useCallback(
        <TFilters,>(
            base: TFilters | undefined,
            patch: Partial<TFilters>,
            spec?: ListerFilterSpec<TFilters>,
        ): TFilters => {
            const merger =
                spec?.merge ?? ((b: any, p: any) => shallowMerge(b, p));
            return merger(base, patch);
        },
        [],
    );

    const reconcileDraftAfterFetch = React.useCallback(
        (id: ListerSessionId, nextOptions: any[]) => {
            updateSession(id, (s) => {
                let draft = s.draftValue;

                if (s.refreshMode === "clear-all") {
                    draft = s.mode === "multiple" ? [] : null;
                } else if (s.refreshMode === "clear-missing") {
                    const values = new Set(nextOptions.map((o) => o.value));
                    if (s.mode === "multiple") {
                        const arr = Array.isArray(draft) ? draft : [];
                        draft = arr.filter((v: any) => values.has(v));
                    } else {
                        if (draft != null && !values.has(draft as any))
                            draft = null;
                    }
                }

                return { ...s, draftValue: draft } as AnyState;
            });
        },
        [updateSession],
    );

    const registerPreset = React.useCallback((kind: string, def: AnyDef) => {
        presetsRef.current = { ...presetsRef.current, [kind]: def };
    }, []);

    const getPreset = React.useCallback((kind: string) => {
        return presetsRef.current?.[kind];
    }, []);

    const performFetch = React.useCallback(
        async (
            def: AnyDef,
            filters?: any,
            opts?: { query?: string; search?: ListerSearchPayload },
        ) => {
            const query = opts?.query ?? "";
            const search = opts?.search;

            const src = def.source;
            const method = (src.method ?? "GET") as "GET" | "POST";

            const built = src.buildRequest?.({
                filters,
                query,
                cursor: null,
            });

            const baseParams = built?.params ?? {
                ...(filters ?? {}),
                search: query,
            };
            const params = search ? { ...baseParams, ...search } : baseParams;

            const body = built?.body ?? {};
            const headers = built?.headers;

            const responseBody = await http({
                endpoint: src.endpoint,
                method,
                params,
                body,
                headers,
            });

            const rawList = extractArray<any>(responseBody, def.selector);
            const ctx = { query, filters };
            const optionsList = mapOptions<any, any, any, any>(
                rawList,
                def.mapping as any,
                ctx,
            );

            return {
                rawList,
                optionsList,
            };
        },
        [http],
    );

    const checkPermissions = React.useCallback(
        (
            kindOrDef: string | AnyDef,
            def: AnyDef,
            filters: any,
            permissions?: string[],
        ) => {
            const pctx = {
                kind: typeof kindOrDef === "string" ? kindOrDef : def.id,
                endpoint: def.source.endpoint,
                filters,
            };

            if (!evaluatePermissions(props.host, permissions, pctx)) {
                props.host.log({
                    level: "warning",
                    code: "lister.access_denied",
                    message: "Access denied.",
                    details: { permissions, pctx },
                });
                throw new Error("lister.access_denied");
            }
        },
        [props.host],
    );

    const apiFetchAny = React.useCallback(
        async (kindOrDef: string | AnyDef, filters?: any, opts?: any) => {
            const def: AnyDef | undefined =
                typeof kindOrDef === "string"
                    ? getPreset(kindOrDef)
                    : kindOrDef;

            if (!def) {
                props.host.log({
                    level: "error",
                    code: "lister.unknown_error",
                    message: "Lister definition not found.",
                    details: { kindOrDef },
                });
                throw new Error("lister.unknown_error");
            }

            checkPermissions(kindOrDef, def, filters, opts?.permissions);

            const { rawList, optionsList } = await performFetch(
                def,
                filters,
                opts,
            );

            return {
                rawList,
                optionsList,
                // for public api compatibility
                raw: rawList,
                options: optionsList,
            };
        },
        [checkPermissions, getPreset, performFetch, props.host],
    );

    const fetchAndHydrate = React.useCallback(
        async (
            id: ListerSessionId,
            reason: "open" | "search" | "refresh" | "filters",
            override?: {
                filters?: any;
                query?: string;
                search?: ListerSearchPayload;
            },
        ) => {
            const s0 = getSession(id);
            if (!s0?.definition) return;

            const myReq = (reqIdBySessionRef.current[id] ?? 0) + 1;
            reqIdBySessionRef.current[id] = myReq;

            const query = override?.query ?? s0.query;
            const filters =
                override?.filters ?? s0.effectiveFilters ?? s0.filters;

            // ✅ search resolution order:
            // 1) explicit override passed to fetchAndHydrate
            // 2) session-level payload override (from searchLocal/searchRemote)
            // 3) derived from current searchTarget
            const hasSearchOverride =
                !!override &&
                Object.prototype.hasOwnProperty.call(override, "search");

            const search: ListerSearchPayload | undefined = hasSearchOverride
                ? override!.search
                : ((s0 as any).searchPayload ??
                  buildSearchPayloadFromTarget((s0 as any).searchTarget));

            patchSession(id, {
                errorCode: undefined,
                loading: reason !== "refresh",
                refreshing: reason === "refresh",
            });

            try {
                const s = getSession(id);
                if (!s?.definition) return;

                const { rawList, optionsList } = await performFetch(
                    s.definition,
                    filters,
                    { query, search },
                );

                // stale response ignored
                if (reqIdBySessionRef.current[id] !== myReq) return;
                if (!getSession(id)) return;

                patchSession(id, {
                    rawList,
                    optionsList,
                    loading: false,
                    refreshing: false,
                });

                reconcileDraftAfterFetch(id, optionsList);
            } catch (err: any) {
                const code: ListerLogCode =
                    err?.message === "EXTRACT_NOT_ARRAY"
                        ? "lister.extract_not_array"
                        : "lister.fetch_failed";

                const s = getSession(id);

                props.host.log({
                    level: "error",
                    code,
                    message:
                        code === "lister.extract_not_array"
                            ? "Lister selector did not return an array."
                            : "Lister request failed.",
                    details: {
                        sessionId: id,
                        kind: s?.kind,
                        endpoint: s?.definition?.source?.endpoint,
                        query,
                        filters,
                        search,
                    },
                });

                patchSession(id, {
                    loading: false,
                    refreshing: false,
                    errorCode: code,
                });
            }
        },
        [
            getSession,
            patchSession,
            performFetch,
            props.host,
            reconcileDraftAfterFetch,
        ],
    );
    const getFilterCtx = React.useCallback(
        <TFilters,>(id: ListerSessionId): ListerFilterCtx<TFilters> => {
            const refresh = () => {
                const s = getSession(id);
                if (!s) return;
                fetchAndHydrate(id, "filters", {
                    filters: s.effectiveFilters ?? s.filters,
                    query: s.query,
                });
            };

            const get = (key: any) => {
                const s = getSession(id) as any;
                const cur = (s?.effectiveFilters ?? s?.filters) as any;
                return cur?.[key];
            };

            const commitPatch = (
                updater: (prev: Partial<TFilters>) => Partial<TFilters>,
            ) => {
                let nextEffective: any;
                let shouldFetch = true;

                updateSession(id, (s: any) => {
                    const spec: ListerFilterSpec<TFilters> | undefined =
                        s.filtersSpec;
                    const base: TFilters | undefined = s.filters;

                    const nextPatch = updater(
                        (s.filtersPatch ?? {}) as Partial<TFilters>,
                    );
                    nextEffective = computeEffectiveFilters<TFilters>(
                        base,
                        nextPatch,
                        spec,
                    );

                    // ✅ local mode = don’t fetch (unless you want to override this behavior)
                    shouldFetch =
                        spec?.autoFetch !== false && s.searchMode !== "local";

                    return {
                        ...s,
                        filtersPatch: nextPatch,
                        effectiveFilters: nextEffective,
                    };
                });

                if (shouldFetch)
                    queueMicrotask(() =>
                        fetchAndHydrate(id, "filters", {
                            filters: nextEffective,
                        }),
                    );
            };

            const s = getSession(id);

            return {
                base: s?.filters as any as TFilters | undefined,
                patch: ((s?.filtersPatch as any) ?? {}) as Partial<TFilters>,
                effective: (s?.effectiveFilters ?? s?.filters) as any as
                    | TFilters
                    | undefined,

                set(key: any, value: any) {
                    commitPatch((p) => ({ ...(p as any), [key]: value }));
                },

                merge(patch: any) {
                    commitPatch((p) => ({ ...(p as any), ...(patch as any) }));
                },

                unset(key: any) {
                    commitPatch((p) => {
                        const next = { ...(p as any) };
                        delete next[key];
                        return next;
                    });
                },

                clear() {
                    commitPatch(() => ({}) as any);
                },

                refresh,

                get: get as any,
            };
        },
        [computeEffectiveFilters, fetchAndHydrate, getSession, updateSession],
    );

    /**
     * NEW apply logic:
     * - expects `optionId` (UI id) — not db value
     * - resolves bindKey (inherit from group parent if needed)
     * - keeps UI selection tracker as option ids
     * - recomputes ctx value for the bindKey from all selected ids for that key
     */
    const applyFilterOption = React.useCallback(
        (id: ListerSessionId, optionId: string | number) => {
            const s = getSession(id);
            const spec: ListerFilterSpec<any> | undefined = s?.filtersSpec;

            if (!s || !spec?.options?.length) return;

            const index = indexFilterOptions<any>(
                spec.options as Array<ListerFilterOption<any>>,
            );

            const node = index[String(optionId)];
            // console.log(index, node, optionId);

            if (!node || node.disabled) return;

            // Only "value" nodes (or nodes with apply) are clickable.
            // (Inputs mutate ctx directly via ctx.set/merge/unset.)
            const isValueKind = node.kind === "value";
            const hasApply = !!node.apply;

            if (!isValueKind && !hasApply) return;

            const ctx = getFilterCtx<any>(id);

            const key = (node.bindKey ?? node.apply?.key) as string | undefined;
            if (!key) return;

            const mode = (node.apply?.mode ?? "replace") as
                | "replace"
                | "merge"
                | "unset";

            const toggleable = node.apply?.toggleable ?? true;

            const prevSelected: Array<string | number> = Array.isArray(
                s.selectedFilterValues,
            )
                ? [...(s.selectedFilterValues as any)]
                : [];

            // ✅ IMPORTANT: selection is tracked by optionId (the UI id)
            const isSelected = prevSelected.includes(optionId);

            // remove from selection?
            const shouldRemove = mode === "unset" || (toggleable && isSelected);

            const nextSelected = shouldRemove
                ? prevSelected.filter((x) => x !== optionId)
                : isSelected
                  ? prevSelected
                  : [...prevSelected, optionId];

            // ✅ store UI selection ids
            patchSession(id, { selectedFilterValues: nextSelected });

            // recompute effective value(s) for THIS key based on all selected ids
            const valuesForKey: any[] = [];
            for (const sid of nextSelected) {
                const n = index[String(sid)];
                if (!n || n.disabled) continue;

                const nKey = (n.bindKey ?? n.apply?.key) as string | undefined;
                if (!nKey || nKey !== key) continue;

                // db value: apply.value overrides, else node.dbValue
                const v =
                    n.apply && n.apply.value !== undefined
                        ? n.apply.value
                        : n.dbValue;

                // ignore undefined values
                if (v === undefined) continue;

                valuesForKey.push(v);
            }

            // no more values for this key => unset
            if (!valuesForKey.length) {
                ctx.unset(key as any);
                return;
            }

            // normalize:
            // - 1 value => scalar
            // - 2+ values => array
            const nextVal =
                valuesForKey.length === 1 ? valuesForKey[0] : valuesForKey;

            if (mode === "merge") ctx.merge({ [key]: nextVal } as any);
            else ctx.set(key as any, nextVal);
        },
        [getFilterCtx, getSession, patchSession],
    );

    const apiOpenAny = React.useCallback(
        async (kindOrDef: string | AnyDef, filters?: any, opts?: any) => {
            const mode: ListerMode = opts?.mode ?? "single";

            try {
                const def: AnyDef | undefined =
                    typeof kindOrDef === "string"
                        ? getPreset(kindOrDef)
                        : (kindOrDef as AnyDef);

                if (!def) {
                    props.host.log({
                        level: "error",
                        code: "lister.unknown_error",
                        message: "Lister definition not found.",
                        details: { kindOrDef },
                    });
                    return;
                }

                const confirm =
                    mode === "multiple" ? true : (opts?.confirm ?? false);

                checkPermissions(kindOrDef, def, filters, opts?.permissions);

                const ownerKey = opts?.ownerKey as string | undefined;

                // ✅ Reuse an existing session for this ownerKey (popover reopen)
                const reusedId = findSessionIdByOwnerKey(ownerKey);
                const sessionId = reusedId ?? makeSessionId();
                const prev = reusedId
                    ? (getSession(sessionId) as AnyState)
                    : undefined;

                const initialDraft =
                    opts?.defaultValue ?? (mode === "multiple" ? [] : null);
                const pos = anchorToPos(opts?.anchor);

                // filters: persist patch + selection if session is reused
                const filtersSpec =
                    (opts?.filtersSpec as ListerFilterSpec<any> | undefined) ??
                    (prev?.filtersSpec as any);

                const filtersPatch = (prev?.filtersPatch as any) ?? {};
                const resolvedSearchMode: ListerSearchMode =
                    (opts?.searchMode as ListerSearchMode | undefined) ??
                    (prev?.searchMode as ListerSearchMode | undefined) ??
                    "remote";

                const selectedFilterValues =
                    (prev?.selectedFilterValues as any[]) ?? [];

                const effectiveFilters = computeEffectiveFilters(
                    filters,
                    filtersPatch,
                    filtersSpec,
                );

                // derive search config from definition
                const searchSpec = def?.search;

                // searchTarget: persist if reused, else default from searchSpec.default
                const defaultCol = (searchSpec as any)?.default as
                    | string
                    | undefined;
                const defaultSearchTarget: ListerSearchTarget | undefined =
                    defaultCol
                        ? { mode: "subject", subject: defaultCol, only: null }
                        : undefined;
                const searchTarget =
                    (prev?.searchTarget as any) ?? defaultSearchTarget;

                // query: persist if reused unless caller forces initialQuery
                const initialQuery =
                    (opts?.initialQuery as string | undefined) ??
                    (prev?.query as any) ??
                    "";

                // Fetch using *effectiveFilters* and *searchTarget*
                const searchPayload: ListerSearchPayload | undefined =
                    (prev as any)?.searchPayload ??
                    buildSearchPayloadFromTarget(searchTarget);
                const { rawList, optionsList } = await performFetch(
                    def,
                    effectiveFilters,
                    { query: initialQuery, search: searchPayload },
                );

                return await new Promise<ListerOpenResult<any, any, any, any>>(
                    (resolve) => {
                        const base = initialSessionState(sessionId);

                        const nextSession: AnyState = {
                            ...(prev ? { ...(prev as any) } : base),
                            isOpen: true,

                            kind:
                                typeof kindOrDef === "string"
                                    ? kindOrDef
                                    : undefined,
                            definition: def,
                            filters,
                            permissions: opts?.permissions,

                            ownerKey,

                            mode: mode as any,
                            confirm: confirm as any,
                            title: opts?.title,

                            draggable: opts?.draggable ?? true,
                            position: pos,
                            hasMoved: false,

                            searchMode: resolvedSearchMode,
                            query: initialQuery,

                            searchSpec,
                            searchTarget,

                            showRefresh: opts?.showRefresh ?? false,
                            refreshMode:
                                opts?.refreshMode ?? "preserve-selection",

                            // filters
                            filtersSpec,
                            filtersPatch,
                            effectiveFilters,
                            selectedFilterValues,

                            // store callbacks for later UI + logic
                            onChange: opts?.onChange,
                            renderOption: opts?.renderOption,

                            loading: false,
                            refreshing: false,
                            errorCode: undefined,

                            rawList,
                            optionsList,

                            draftValue: initialDraft,
                            initialDraftValue: initialDraft,

                            _resolve: resolve as any,
                        };

                        setStore((s) => ({
                            ...s,
                            sessions: {
                                ...s.sessions,
                                [sessionId]: nextSession,
                            },
                            order: [
                                ...s.order.filter((x) => x !== sessionId),
                                sessionId,
                            ],
                            activeId: sessionId,
                        }));

                        queueMicrotask(() =>
                            reconcileDraftAfterFetch(sessionId, optionsList),
                        );
                    },
                );
            } catch (err: any) {
                return {
                    reason:
                        err?.message === "lister.access_denied"
                            ? "denied"
                            : "error",
                    value: mode === "multiple" ? [] : null,
                    details: {
                        options: mode === "multiple" ? [] : null,
                        raw: mode === "multiple" ? [] : null,
                        action:
                            err?.message === "lister.access_denied"
                                ? "denied"
                                : "error",
                        errorCode: err?.message,
                    },
                };
            }
        },
        [
            computeEffectiveFilters,
            getPreset,
            findSessionIdByOwnerKey,
            getSession,
            performFetch,
            checkPermissions,
            reconcileDraftAfterFetch,
            setStore,
        ],
    );

    const apply = React.useCallback(
        (id: ListerSessionId) => {
            const s = getSession(id);
            if (!s?.isOpen) return;

            const details = buildDetails({
                mode: s.mode as any,
                draftValue: s.draftValue as any,
                optionsList: s.optionsList as any,
                action: "init",
            });

            resolveAndDispose(id, {
                reason: "apply",
                value: s.draftValue,
                details: {
                    options: (details as any).options,
                    raw: (details as any).raw,
                    action: "apply",
                    sessionId: id,
                },
            });
        },
        [getSession, resolveAndDispose],
    );

    const cancel = React.useCallback(
        (id: ListerSessionId) => {
            const s = getSession(id);
            if (!s?.isOpen) return;

            const details = buildDetails({
                mode: s.mode as any,
                draftValue: s.initialDraftValue as any,
                optionsList: s.optionsList as any,
                action: "init",
            });

            resolveAndDispose(id, {
                reason: "cancel",
                value: s.initialDraftValue,
                details: {
                    options: (details as any).options,
                    raw: (details as any).raw,
                    action: "cancel",
                    sessionId: id,
                },
            });
        },
        [getSession, resolveAndDispose],
    );

    const close = React.useCallback(
        (id: ListerSessionId) => {
            const s = getSession(id);
            if (!s?.isOpen) return;

            const details = buildDetails({
                mode: s.mode as any,
                draftValue: s.initialDraftValue as any,
                optionsList: s.optionsList as any,
                action: "init",
            });

            resolveAndDispose(id, {
                reason: "close",
                value: s.initialDraftValue,
                details: {
                    options: (details as any).options,
                    raw: (details as any).raw,
                    action: "close",
                    sessionId: id,
                },
            });
        },
        [getSession, resolveAndDispose],
    );

    const commitDraft = React.useCallback(
        (
            id: ListerSessionId,
            nextDraft: any,
            action: "select" | "deselect" | "clear" | "init",
        ) => {
            const s = getSession(id);
            if (!s) return;

            const e = makeChangeEvent();

            const details = buildDetails({
                mode: s.mode as any,
                draftValue: nextDraft,
                optionsList: s.optionsList as any,
                action,
            });

            s.onChange?.(nextDraft, details as any, e as any);
            if (e.defaultPrevented) return;

            patchSession(id, { draftValue: nextDraft });
        },
        [getSession, patchSession],
    );

    const select = React.useCallback(
        (id: ListerSessionId, value: ListerId) => {
            const s = getSession(id);
            if (!s?.isOpen) return;

            if (s.mode === "multiple") {
                const arr = Array.isArray(s.draftValue) ? s.draftValue : [];
                if (arr.includes(value)) return;
                commitDraft(id, [...arr, value], "select");
                return;
            }

            if (s.draftValue === value) return;
            commitDraft(id, value, "select");

            if (s.mode === "single" && !s.confirm)
                queueMicrotask(() => apply(id));
        },
        [apply, commitDraft, getSession],
    );

    const deselect = React.useCallback(
        (id: ListerSessionId, value: ListerId) => {
            const s = getSession(id);
            if (!s?.isOpen) return;

            if (s.mode === "multiple") {
                const arr = Array.isArray(s.draftValue) ? s.draftValue : [];
                if (!arr.includes(value)) return;
                commitDraft(
                    id,
                    arr.filter((v: any) => v !== value),
                    "deselect",
                );
                return;
            }

            if (s.draftValue !== value) return;
            commitDraft(id, null, "deselect");

            if (s.mode === "single" && !s.confirm)
                queueMicrotask(() => apply(id));
        },
        [apply, commitDraft, getSession],
    );

    const toggle = React.useCallback(
        (id: ListerSessionId, value: ListerId) => {
            const s = getSession(id);
            if (!s?.isOpen) return;

            const { nextDraft, action } = computeNextDraft(
                s.mode as any,
                s.draftValue as any,
                value as any,
            );
            commitDraft(id, nextDraft, action);

            if (s.mode === "single" && !s.confirm)
                queueMicrotask(() => apply(id));
        },
        [apply, commitDraft, getSession],
    );

    const clear = React.useCallback(
        (id: ListerSessionId) => {
            const s = getSession(id);
            if (!s?.isOpen) return;

            const nextDraft = s.mode === "multiple" ? [] : null;
            commitDraft(id, nextDraft, "clear");

            if (s.mode === "single" && !s.confirm)
                queueMicrotask(() => apply(id));
        },
        [apply, commitDraft, getSession],
    );

    const setQuery = React.useCallback(
        (id: ListerSessionId, q: string) => {
            patchSession(id, { query: q });
        },
        [patchSession],
    );

    const setSearchMode = React.useCallback(
        (id: ListerSessionId, mode: ListerSearchMode) => {
            const s = getSession(id);
            if (!s) return;

            const prevMode = s.searchMode;
            patchSession(id, { searchMode: mode });

            if (prevMode === mode) return;

            // ✅ when entering local: fetch a base dataset (no query + no search payload)
            // then local UI applies current query/payload/filters via getVisibleOptions()
            if (mode === "local") {
                fetchAndHydrate(id, "refresh", {
                    filters: s.effectiveFilters ?? s.filters,
                    query: "", // base fetch (unsearched)
                    search: undefined, // force NO search payload
                });
            }
        },
        [fetchAndHydrate, getSession, patchSession],
    );

    const scheduleRemoteFetch = React.useCallback(
        (
            id: ListerSessionId,
            q: string,
            payloadOverride?: ListerSearchPayload,
        ) => {
            if (timerBySessionRef.current[id])
                clearTimeout(timerBySessionRef.current[id]);

            timerBySessionRef.current[id] = setTimeout(() => {
                const s = getSession(id);

                // ✅ same precedence everywhere:
                // payloadOverride > session.searchPayload > derived from searchTarget
                const search: ListerSearchPayload | undefined =
                    payloadOverride ??
                    (s as any)?.searchPayload ??
                    buildSearchPayloadFromTarget((s as any)?.searchTarget);

                fetchAndHydrate(id, "search", { query: q, search });
            }, debounceMs);
        },
        [debounceMs, fetchAndHydrate, getSession],
    );

    const setSearchTarget = React.useCallback(
        (id: ListerSessionId, target: ListerSearchTarget) => {
            patchSession(id, {
                searchTarget: target,
                searchPayload: undefined,
            }); // ✅ clear override

            const s = getSession(id);
            const mode = s?.searchMode ?? "remote";
            const q = s?.query ?? "";
            const payload = buildSearchPayloadFromTarget(target);

            if (mode === "remote" || mode === "hybrid")
                scheduleRemoteFetch(id, q, payload);
        },
        [getSession, patchSession, scheduleRemoteFetch],
    );

    const searchLocalImpl = React.useCallback(
        (id: ListerSessionId, q: string, payload?: ListerSearchPayload) => {
            // ✅ store payload override so local UI respects it
            patchSession(id, { query: q, searchPayload: payload });

            const s = getSession(id);
            if (!s) return;

            if (s.searchMode === "hybrid") {
                scheduleRemoteFetch(id, q, payload);
            }
        },
        [getSession, patchSession, scheduleRemoteFetch],
    );

    const searchRemoteImpl = React.useCallback(
        (id: ListerSessionId, q: string, payload?: ListerSearchPayload) => {
            // ✅ keep payload override in session too
            patchSession(id, { query: q, searchPayload: payload });
            scheduleRemoteFetch(id, q, payload);
        },
        [patchSession, scheduleRemoteFetch],
    );

    const searchLocal = searchLocalImpl as InternalContextValue["searchLocal"];
    const searchRemote =
        searchRemoteImpl as InternalContextValue["searchRemote"];

    const refresh = React.useCallback(
        (id: ListerSessionId) => {
            fetchAndHydrate(id, "refresh");
        },
        [fetchAndHydrate],
    );

    const setPosition = React.useCallback(
        (id: ListerSessionId, pos: { x: number; y: number } | null) => {
            updateSession(
                id,
                (s) =>
                    ({
                        ...s,
                        position: pos,
                        hasMoved: pos ? true : s.hasMoved,
                    }) as AnyState,
            );
        },
        [updateSession],
    );

    const getVisibleOptions = React.useCallback(
        (id: ListerSessionId) => {
            const s = getSession(id);
            if (!s) return [];

            // remote mode: show fetched options as-is
            if (s.searchMode === "remote") return s.optionsList;

            const def = s.definition as AnyDef | undefined;
            if (!def) return [];

            const filters = s.effectiveFilters ?? s.filters;

            // ✅ payload: explicit override wins, else derive from searchTarget
            const payload: ListerSearchPayload | undefined =
                (s as any).searchPayload ??
                buildSearchPayloadFromTarget((s as any)?.searchTarget);

            // ✅ local “equivalent” filtering: filters + payload + query
            const visibleRaw = filterRawListLocal(
                (s.rawList ?? []) as any[],
                s.query,
                payload,
                filters,
                {
                    searchSpec: (s as any).searchSpec ?? def.search,
                    filtersSpec: (s as any).filtersSpec,
                },
            );

            // ✅ IMPORTANT: remap with CURRENT ctx (mirrors remote)
            const mapCtx = { query: s.query, filters };
            return mapOptions<any, any, any, any>(
                visibleRaw,
                def.mapping as any,
                mapCtx,
            );
        },
        [getSession],
    );

    const value: InternalContextValue = React.useMemo(
        () => ({
            host: props.host,
            http,
            presetsRef,

            store,

            apiFetchAny,
            apiOpenAny,

            focus,
            dispose,

            apply,
            cancel,
            close,

            toggle,
            select,
            deselect,
            clear,

            setQuery,
            setSearchMode,
            setSearchTarget,

            searchLocal,
            searchRemote,

            refresh,
            setPosition,

            getFilterCtx,
            applyFilterOption,

            registerPreset,
            getPreset,

            getVisibleOptions,
        }),
        [
            apiFetchAny,
            apiOpenAny,
            apply,
            applyFilterOption,
            cancel,
            clear,
            close,
            deselect,
            dispose,
            focus,
            getFilterCtx,
            getPreset,
            getVisibleOptions,
            http,
            props.host,
            refresh,
            registerPreset,
            searchLocal,
            searchRemote,
            select,
            setPosition,
            setQuery,
            setSearchMode,
            setSearchTarget,
            store,
            toggle,
        ],
    );

    return <Ctx.Provider value={value}>{props.children}</Ctx.Provider>;
}
```

---
#### 12


` File: packages/form-palette/src/presets/lister/types.ts`  [↑ Back to top](#index)

```ts
// -- resources/js/context/lister/types.ts

/* ============================================================================
 * Lister Spec v0.1 — FULL TYPES (Generics-first, mode-aware, multi-session)
 * - Extracted result MUST be an array; default selector is body.data
 * - Strong typing for: value, defaultValue, details.raw, filters, presets
 * - details.raw is TRaw | null in single mode, TRaw[] in multiple mode
 * - onChange is sync + preventDefault()
 * - Apply always for multiple; optional for single via confirm
 * - Filters: TreeSelect-native options (supports render by default)
 * - Provider supports MULTIPLE simultaneous popover sessions
 * ============================================================================ */

import { VariantKey, VariantPropsFor } from "@/schema/variant";

export type ListerId = string | number;

export type ListerMode = "single" | "multiple";
export type ListerSearchMode = "local" | "remote" | "hybrid";
export type ListerOpenReason =
    | "apply"
    | "cancel"
    | "close"
    | "denied"
    | "error";

export type ListerSessionId = string;

/** Extraction selector:
 * - string form is runtime-only (dot-path); not type-checked
 * - function form is typed and must return an array
 */
export type Selector<TRaw> = string | ((body: any) => TRaw[]);

/** Resolver:
 * - string form is runtime-only (dot-path relative to raw item)
 * - function form is fully typed
 */
export type Resolver<TOut, TRaw, TCtx = any> =
    | string
    | ((raw: TRaw, ctx: TCtx) => TOut);

export type OpenAnchor =
    | { x: number; y: number }
    | { clientX: number; clientY: number }
    | any;

export type ListerChangeEvent = {
    preventDefault(): void;
    defaultPrevented: boolean;
};

/* ─────────────────────────────────────────────
 * Logging + permissions (host-implemented)
 * ───────────────────────────────────────────── */

export type ListerLogLevel = "info" | "success" | "warning" | "error";

export type ListerLogCode =
    | "lister.access_denied"
    | "lister.fetch_failed"
    | "lister.extract_not_array"
    | "lister.mapping_failed"
    | "lister.unknown_error";

export type ListerLogEntry = {
    level: ListerLogLevel;
    code: ListerLogCode;
    message: string;
    details?: Record<string, unknown>;
    ui?: {
        mode?: "toast" | "banner" | "dialog";
        group?: string;
        autoCloseMs?: number | null;
    };
};

export type ListerPermissionCtx = {
    kind?: string;
    endpoint?: string;
    filters?: any;
    sessionId?: ListerSessionId;
};

export interface ListerProviderHost {
    /** Host decides permission logic. Mandatory permissions end with '!' */
    can: (permissions: string[], ctx: ListerPermissionCtx) => boolean;

    /** Host decides notification/diagnostic surface */
    log: (entry: ListerLogEntry) => void;
}

/* ─────────────────────────────────────────────
 * Option + mapping (typed)
 * ───────────────────────────────────────────── */

export type ListerOption<TRaw, TValue extends ListerId, TMeta = unknown> = {
    value: TValue;
    label: any; // string | ReactNode (UI layer)
    icon?: any;
    description?: any;
    disabled?: boolean;
    group?: string;
    meta?: TMeta;

    /** optional raw passthrough (implementation choice) */
    raw?: TRaw;
};

export type ListerMapping<
    TRaw,
    TValue extends ListerId,
    TMeta = unknown,
    TCtx = any,
> = {
    optionValue: Resolver<TValue, TRaw, TCtx>; // required

    /** default: raw.label ?? String(value) */
    optionLabel?: Resolver<any, TRaw, TCtx>;

    optionIcon?: Resolver<any, TRaw, TCtx>;
    optionDescription?: Resolver<any, TRaw, TCtx>;
    optionDisabled?: Resolver<boolean, TRaw, TCtx>;
    optionGroup?: Resolver<string, TRaw, TCtx>;
    optionMeta?: Resolver<TMeta, TRaw, TCtx>;
};

/* ─────────────────────────────────────────────
 * Source + definition (typed)
 * ───────────────────────────────────────────── */

export type ListerSource<TFilters = unknown> = {
    endpoint: string;
    method?: "GET" | "POST";

    /** Optional custom mapping of filters/query/cursor into request params/body/headers */
    buildRequest?: (args: {
        filters?: TFilters;
        query?: string;
        cursor?: string | null;
    }) => { params?: any; body?: any; headers?: any };
};

export type ListerSearchSpec<TColumn extends string = string> = {
    /**
     * Columns the UI can offer as "Subject" (search in one column).
     * Example: ["name", "email", "status"]
     */
    subjects?: readonly TColumn[];

    /**
     * Columns the UI can offer as "Search only" (search across multiple columns).
     * Example: ["name", "email"]
     */
    only?: readonly TColumn[];

    /**
     * Allow user to type a column name that isn't in `subjects`.
     * (Your backend still decides whether to accept/reject it.)
     */
    allowCustomSubject?: boolean;

    /**
     * Allow user to add custom column names to the multi-field "only" list.
     * Useful if you want advanced users to target niche columns.
     */
    allowCustomOnly?: boolean;

    /**
     * Whether the UI can show a "Search all" option.
     * (Semantics depend on your backend: usually "all text columns".)
     */
    allowAll?: boolean;

    /**
     * Optional UI hints (totally optional, but nice for button labels/placeholders).
     */
    ui?: {
        placeholder?: string; // e.g. "Search…"
        subjectLabel?: string; // e.g. "In"
        allLabel?: string; // e.g. "All columns"
        onlyLabel?: string; // e.g. "Only"
        customSubjectLabel?: string; // e.g. "Custom column"
    };

    default?: string;
};

export type ListerDefinition<
    TRaw,
    TValue extends ListerId,
    TFilters = unknown,
    TMeta = unknown,
    TCtx = any,
    TSearchColumn extends string = string,
> = {
    /** optional stable id used by presets */
    id?: string;

    source: ListerSource<TFilters>;

    /** If missing: default extraction uses body.data (runtime). Must produce an array. */
    selector?: Selector<TRaw>;

    /** How raw item maps into selectable option */
    mapping: ListerMapping<TRaw, TValue, TMeta, TCtx>;

    /**
     * Search configuration:
     * - defines which columns are searchable (subject + multi-field)
     * - optionally allows custom column names (advanced mode)
     */
    search?: ListerSearchSpec<TSearchColumn>;
};

/* ─────────────────────────────────────────────
 * Filters (TreeSelect-native; render supported by option item)
 * ───────────────────────────────────────────── */

export type ListerFilterApplyMode = "replace" | "merge" | "unset";

export type ListerFilterApply<TFilters, K extends keyof TFilters & string> = {
    key: K;
    mode?: ListerFilterApplyMode; // default "replace"
    value?: TFilters[K];
    toggleable?: boolean;

    /** optional: clicking cycles through these states */
    cycle?: Array<
        | { mode: "unset" }
        | { mode: "replace"; value: TFilters[K] }
        | { mode: "merge"; value: Partial<TFilters> } // optional if you ever want it
    >;
};

export type ListerFilterCtx<TFilters> = {
    /** base filters passed to open() */
    base: TFilters | undefined;

    /** only what filter controls changed */
    patch: Partial<TFilters>;

    /** base + patch (merged) */
    effective: TFilters | undefined;

    set<K extends keyof TFilters & string>(key: K, value: TFilters[K]): void;
    merge(patch: Partial<TFilters>): void;
    unset<K extends keyof TFilters & string>(key: K): void;
    clear(): void;

    /** triggers refetch using current effective filters */
    refresh(): void;

    /** reads from effective (base overridden by patch) */
    get<K extends keyof TFilters & string>(key: K): TFilters[K] | undefined;
};

export type ListerFilterBindKey<TFilters> = keyof TFilters & string;

/**
 * OPTIONAL inline input filter config
 * (value comes from the input; not from option.value)
 */
export type ListerFilterInput<TFilters> = {
    /** If omitted, falls back to option.bindKey (or parent bindKey). */
    bindKey?: ListerFilterBindKey<TFilters>;

    variant: VariantKey;
    props?: VariantPropsFor<any>;

    mode?: "replace" | "merge"; // default "replace"
    unsetOnEmpty?: boolean;
};

type FilterNodeBase<TFilters> = {
    /**
     * UI identity (must be unique in the tree)
     * Example: "status", "status.active", "pricing.minMax"
     */
    id: string | number;

    label?: any;
    icon?: any;
    description?: any;
    disabled?: boolean;

    /**
     * Column/reference key (DB filter key).
     * Example: "status"
     *
     * Typically set on a group node and inherited by children.
     */
    bindKey?: ListerFilterBindKey<TFilters>;

    /**
     * Optional custom render (advanced).
     * (Still works, but now you can also use kind="input" for most cases.)
     */
    render?: (args: {
        option: ListerFilterOption<TFilters>;
        ctx: ListerFilterCtx<TFilters>;
        state: { open: boolean; selected: boolean };
        actions: { close(): void };
    }) => any;
};

export type ListerFilterGroupOption<TFilters> = FilterNodeBase<TFilters> & {
    kind: "group";
    children: Array<ListerFilterOption<TFilters>>;
    apply?: never;
    input?: never;
    value?: never;
};

export type ListerFilterValueOption<
    TFilters,
    TValue = string | number,
> = FilterNodeBase<TFilters> & {
    kind: "value";

    /**
     * Actual DB value. Example: "active"
     * (NOT "status.active")
     */
    value: TValue;

    /**
     * Optional: clicking this item applies/unapplies it.
     * If apply.value is omitted => defaults to option.value
     */
    apply?: ListerFilterApply<TFilters, any>;

    children?: never;
    input?: never;
};

export type ListerFilterInputOption<TFilters> = FilterNodeBase<TFilters> & {
    kind: "input";

    /**
     * Value comes from the input; binds to bindKey (option.bindKey or input.bindKey).
     */
    input: ListerFilterInput<TFilters>;

    children?: never;
    apply?: never;
    value?: never;
};

export type ListerFilterOption<TFilters> =
    | ListerFilterGroupOption<TFilters>
    | ListerFilterValueOption<TFilters>
    | ListerFilterInputOption<TFilters>;

export type ListerFilterSpec<TFilters> = {
    /** TreeSelect options */
    options: Array<ListerFilterOption<TFilters>>;

    /** Merge base + patch into effective */
    merge?: (base: TFilters | undefined, patch: Partial<TFilters>) => TFilters;

    /** Default: true. If true, any ctx.set/merge/unset triggers a fetch */
    autoFetch?: boolean;
};

/* ─────────────────────────────────────────────
 * Mode-dependent helpers (typed)
 * ───────────────────────────────────────────── */

export type ListerValueForMode<
    TValue extends ListerId,
    TMode extends ListerMode,
> = TMode extends "multiple" ? TValue[] : TValue | null;

export type ListerRawForMode<
    TRaw,
    TMode extends ListerMode,
> = TMode extends "multiple" ? TRaw[] : TRaw | null;

export type ListerOptionsForMode<
    TRaw,
    TValue extends ListerId,
    TMeta,
    TMode extends ListerMode,
> = TMode extends "multiple"
    ? Array<ListerOption<TRaw, TValue, TMeta>>
    : ListerOption<TRaw, TValue, TMeta> | null;

/* ─────────────────────────────────────────────
 * Details (typed; raw is mode-dependent)
 * ───────────────────────────────────────────── */

export type ListerDetails<
    TRaw,
    TValue extends ListerId,
    TMeta,
    TMode extends ListerMode,
> = {
    /** Selected mapped options (array in multiple, single option/null in single) */
    options: ListerOptionsForMode<TRaw, TValue, TMeta, TMode>;

    /** Selected raw backend item(s) (array only in multiple mode) */
    raw: ListerRawForMode<TRaw, TMode>;

    /** Live change semantic while open */
    action: "select" | "deselect" | "clear" | "init";
};

/* ─────────────────────────────────────────────
 * Open options + result (typed)
 * ───────────────────────────────────────────── */

export type ListerOpenOptions<
    TRaw,
    TValue extends ListerId,
    TFilters,
    TMeta,
    TMode extends ListerMode = "single",
> = {
    /** Mode defaults to "single" */
    mode?: TMode;

    /** Single-mode only: if true => Apply/Cancel UI, draft selection until Apply */
    confirm?: TMode extends "single" ? boolean : never;

    /** Initial selection when opened (draft seed) */
    defaultValue?: ListerValueForMode<TValue, TMode>;

    /** Permission entries; mandatory end with '!' */
    permissions?: string[];

    /** Search behaviour */
    searchMode?: ListerSearchMode;
    initialQuery?: string;

    /** UI */
    title?: string;
    draggable?: boolean;
    anchor?: OpenAnchor;

    /** Refresh */
    showRefresh?: boolean;
    refreshMode?: "preserve-selection" | "clear-missing" | "clear-all";

    /** Filters control (TreeSelect-native options; render supported) */
    filtersSpec?: ListerFilterSpec<TFilters>;

    /** Custom row renderer */
    renderOption?: (args: {
        option: ListerOption<TRaw, TValue, TMeta>;
        state: { selected: boolean; active: boolean; mode: TMode };
        actions: { toggle(): void; select(): void; deselect(): void };
        ctx: { query?: string; filters?: TFilters };
    }) => any;

    /** Live change hook (sync + veto) */
    onChange?: (
        value: ListerValueForMode<TValue, TMode>,
        details: ListerDetails<TRaw, TValue, TMeta, TMode>,
        e: ListerChangeEvent,
    ) => void;
};

export type ListerOpenResult<
    TRaw,
    TValue extends ListerId,
    TMeta,
    TMode extends ListerMode,
> = {
    reason: ListerOpenReason;
    value: ListerValueForMode<TValue, TMode>;
    details: {
        options: ListerOptionsForMode<TRaw, TValue, TMeta, TMode>;
        raw: ListerRawForMode<TRaw, TMode>;
        action: "apply" | "cancel" | "close" | "denied" | "error";
        errorCode?: string;
        /** Useful in multi-session UI: which popover resolved */
        sessionId?: ListerSessionId;
    };
};

/* ─────────────────────────────────────────────
 * Presets typing (autocomplete for open("orders"...))
 * ───────────────────────────────────────────── */

export type PresetMap = Record<
    string,
    ListerDefinition<any, any, any, any, any>
>;

export type PresetRaw<P extends PresetMap, K extends keyof P> =
    P[K] extends ListerDefinition<infer R, any, any, any, any> ? R : never;

export type PresetValue<P extends PresetMap, K extends keyof P> =
    P[K] extends ListerDefinition<any, infer V, any, any, any> ? V : never;

export type PresetFilters<P extends PresetMap, K extends keyof P> =
    P[K] extends ListerDefinition<any, any, infer F, any, any> ? F : never;

export type PresetMeta<P extends PresetMap, K extends keyof P> =
    P[K] extends ListerDefinition<any, any, any, infer M, any> ? M : never;

/* ─────────────────────────────────────────────
 * Public API (typed overloads)
 * ───────────────────────────────────────────── */

export interface ListerApi<P extends PresetMap> {
    /** Fetch data without opening session */
    fetch<K extends keyof P>(
        kind: K,
        filters?: PresetFilters<P, K>,
        opts?: { query?: string },
    ): Promise<{
        raw: PresetRaw<P, K>[];
        options: Array<
            ListerOption<PresetRaw<P, K>, PresetValue<P, K>, PresetMeta<P, K>>
        >;
    }>;

    /** Fetch data without opening session (custom definition) */
    fetch<TRaw, TValue extends ListerId, TFilters = unknown, TMeta = unknown>(
        def: ListerDefinition<TRaw, TValue, TFilters, TMeta>,
        filters?: TFilters,
        opts?: { query?: string },
    ): Promise<{
        raw: TRaw[];
        options: Array<ListerOption<TRaw, TValue, TMeta>>;
    }>;

    /** Open via preset kind */
    open<K extends keyof P, TMode extends ListerMode = "single">(
        kind: K,
        filters?: PresetFilters<P, K>,
        opts?: ListerOpenOptions<
            PresetRaw<P, K>,
            PresetValue<P, K>,
            PresetFilters<P, K>,
            PresetMeta<P, K>,
            TMode
        > & { mode?: TMode },
    ): Promise<
        ListerOpenResult<
            PresetRaw<P, K>,
            PresetValue<P, K>,
            PresetMeta<P, K>,
            TMode
        >
    >;

    /** Open via custom definition */
    open<
        TRaw,
        TValue extends ListerId,
        TFilters = unknown,
        TMeta = unknown,
        TMode extends ListerMode = "single",
    >(
        def: ListerDefinition<TRaw, TValue, TFilters, TMeta>,
        filters?: TFilters,
        opts?: ListerOpenOptions<TRaw, TValue, TFilters, TMeta, TMode> & {
            mode?: TMode;
        },
    ): Promise<ListerOpenResult<TRaw, TValue, TMeta, TMode>>;

    /** Optional preset registry helpers */
    registerPreset?: (
        kind: string,
        def: ListerDefinition<any, any, any, any, any>,
    ) => void;
    getPreset?: (
        kind: string,
    ) => ListerDefinition<any, any, any, any, any> | undefined;
}

/* ─────────────────────────────────────────────
 * Session/Runtime state (multi-session)
 * ───────────────────────────────────────────── */

export type ListerSessionState<
    TRaw,
    TValue extends ListerId,
    TFilters,
    TMeta,
    TMode extends ListerMode,
> = {
    // identity
    sessionId: ListerSessionId;
    createdAt: number;

    // session identity
    isOpen: boolean;
    kind?: string;
    definition?: ListerDefinition<TRaw, TValue, TFilters, TMeta>;
    filters?: TFilters; // base filters passed to open()

    // permissions (for diagnostics)
    permissions?: string[];

    // ui config
    mode: TMode;
    confirm: TMode extends "single" ? boolean : true; // multiple always behaves as confirm=true
    title?: string;

    // positioning
    draggable: boolean;
    position: { x: number; y: number } | null; // null = "use default placement"
    hasMoved: boolean; // becomes true after dragging

    // search
    searchMode: ListerSearchMode; // default "remote"
    query: string;

    // loading/error
    loading: boolean;
    refreshing: boolean;
    errorCode?: ListerLogCode | string;

    // data (latest fetched/mapped)
    rawList: TRaw[]; // the extracted array
    optionsList: Array<ListerOption<TRaw, TValue, TMeta>>;

    // selection (draft)
    draftValue: ListerValueForMode<TValue, TMode>;

    // refresh reconciliation
    refreshMode: "preserve-selection" | "clear-missing" | "clear-all";

    // finalization promise handlers (internal)
    _resolve?: (result: ListerOpenResult<TRaw, TValue, TMeta, TMode>) => void;
};

export type ListerRuntimeState<
    TRaw,
    TValue extends ListerId,
    TFilters,
    TMeta,
    TMode extends ListerMode,
> = ListerSessionState<TRaw, TValue, TFilters, TMeta, TMode> & {
    /** Used to revert on cancel/close (recommended behaviour) */
    initialDraftValue: ListerValueForMode<TValue, TMode>;

    /** Stored from open() opts for later UI + provider logic */
    onChange?: (
        value: ListerValueForMode<TValue, TMode>,
        details: ListerDetails<TRaw, TValue, TMeta, TMode>,
        e: ListerChangeEvent,
    ) => void;

    /** UI hook for later */
    renderOption?: ListerOpenOptions<
        TRaw,
        TValue,
        TFilters,
        TMeta,
        TMode
    >["renderOption"];

    /** UI flag for later */
    showRefresh?: boolean;

    /** Filters config + runtime patch/effective (provider-owned) */
    filtersSpec?: ListerFilterSpec<TFilters>;
    filtersPatch?: Partial<TFilters>;
    effectiveFilters?: TFilters;

    /** Optional UI convenience */
    selectedFilterValues?: Array<string | number>;

    /* ─────────────────────────────────────────────
     * Search (provider-owned)
     * ───────────────────────────────────────────── */

    /** Derived from def.search (used for UI to render subjects/only/all rules) */
    searchSpec?: ListerSearchSpec<string>;

    /** Persisted user selection (subject/all/only) */
    searchTarget?: ListerSearchTarget;
};

export type ListerStoreState = {
    /** rendering order (last = topmost) */
    order: ListerSessionId[];

    /** active/focused session */
    activeId?: ListerSessionId;

    /** sessions registry */
    sessions: Record<
        ListerSessionId,
        ListerRuntimeState<any, any, any, any, any>
    >;
};

export type ListerSearchTarget = {
    /**
     * "all"    => backend receives `searchAll=true`
     * "subject"=> backend receives `subject=<col>`
     * "only"   => backend receives `searchOnly=[...]`
     */
    mode: "all" | "subject" | "only";

    subject?: string | null; // for mode="subject"
    only?: Array<string | number> | null; // for mode="only"
};

export type ListerSearchPayload = {
    subject?: string;
    searchAll?: boolean;
    searchOnly?: Array<string | number>;
};
```

---
#### 13


` File: packages/form-palette/src/presets/lister/ui/filter-ui.tsx`  [↑ Back to top](#index)

```tsx
// packages/form-palette/src/presets/lister/ui/filter-ui.tsx

import * as React from "react";
import { Button } from "@/presets/ui/button";
import { Popover, PopoverContent, PopoverTrigger } from "@/presets/ui/popover";
import { InputField } from "@/input/input-field";

import { Check, ChevronRight, Filter, X } from "lucide-react";

import type {
    ListerFilterCtx,
    ListerFilterOption,
    ListerSessionId,
    ListerStoreState,
} from "@/presets/lister/types";

import { useLister } from "@/presets/lister";
import type { VariantKey, VariantPropsFor } from "@/schema/variant";

type AnyPresetMap = any;

type FilterValue = string | number;

function asArray<T>(v: any): T[] {
    if (v == null) return [];
    return Array.isArray(v) ? (v as T[]) : ([v] as T[]);
}

function isEmptyValue(v: any) {
    if (v == null) return true;
    if (typeof v === "string") return v.trim() === "";
    if (Array.isArray(v)) return v.length === 0;
    return false;
}

function extractValueFromInputFieldEvent(e: any) {
    if (e && typeof e === "object" && "value" in e) return (e as any).value;
    return e;
}

/**
 * IMPORTANT:
 * Must match provider indexing:
 * provider uses opt.id ?? opt.value as the optionId
 */
function getOptionId(opt: any): FilterValue {
    if (opt?.id != null) return opt.id as FilterValue;
    if (opt?.value != null) return opt.value as FilterValue;
    return String(opt?.label ?? "node");
}

export function ListerFiltersButton<TFilters>(props: {
    id: ListerSessionId;

    /** kept for compatibility, but we use live store from useLister() */
    store: ListerStoreState;

    icon?: React.ReactNode;
    buttonProps?: Partial<React.ComponentProps<typeof Button>>;
}) {
    const { id } = props;

    // ✅ live store/actions
    const { actions, store } = useLister<AnyPresetMap>();

    const session = store.sessions[id] as any;

    const spec = session?.filtersSpec as
        | undefined
        | { options: Array<ListerFilterOption<TFilters>> };

    const options = (spec?.options ?? []) as Array<
        ListerFilterOption<TFilters>
    >;
    const hasFilters = options.length > 0;

    if (!hasFilters) return null;

    const ctx = actions.getFilterCtx<TFilters>(id);

    const [openGroups, setOpenGroups] = React.useState<Record<string, boolean>>(
        {},
    );

    const toggleGroup = (key: string) => {
        setOpenGroups((m) => ({ ...m, [key]: !m[key] }));
    };

    const selectedIds = asArray<FilterValue>(session?.selectedFilterValues);

    const appliedCount = React.useMemo(() => {
        const patch = (session?.filtersPatch ?? {}) as Record<string, any>;
        return Object.keys(patch).length;
    }, [session?.filtersPatch]);

    return (
        <Popover>
            <PopoverTrigger asChild>
                <Button
                    type="button"
                    variant="link"
                    title="Filters"
                    className="relative px-1! pr-2! cursor-pointer"
                    {...(props.buttonProps as any)}
                >
                    {props.icon ?? <Filter className="size-3" />}

                    {appliedCount > 0 ? (
                        <span
                            className={[
                                "absolute right-1 top-1",
                                "min-w-3 h-3 px-1",
                                "rounded-full",
                                "bg-primary text-primary-foreground",
                                "text-[9px] leading-4",
                                "flex items-center justify-center",
                            ].join(" ")}
                            aria-label={`${appliedCount} filters applied`}
                        >
                            {appliedCount}
                        </span>
                    ) : null}
                </Button>
            </PopoverTrigger>

            <PopoverContent align="end" className="w-90 p-3">
                <div className="flex items-center justify-between">
                    <div className="text-sm font-medium">Filters</div>
                    <div className="text-xs opacity-60">
                        Tap outside to close
                    </div>
                </div>

                <div className="mt-3 space-y-1">
                    {options.map((opt) => {
                        const nodeId = getOptionId(opt as any);
                        return (
                            <FilterNode
                                key={String(nodeId)}
                                nodeId={nodeId}
                                option={opt}
                                ctx={ctx}
                                selectedIds={selectedIds}
                                openGroups={openGroups}
                                onToggleGroup={toggleGroup}
                                onApply={(optionId) =>
                                    actions.applyFilterOption(id, optionId)
                                }
                            />
                        );
                    })}
                </div>

                <div className="mt-3 flex items-center justify-end gap-2">
                    <Button
                        type="button"
                        size="sm"
                        variant="ghost"
                        onClick={() => ctx.clear()}
                        title="Clear filter values"
                    >
                        <X className="h-4 w-4" />
                        <span className="ml-1">Clear</span>
                    </Button>
                </div>
            </PopoverContent>
        </Popover>
    );
}

function FilterNode<TFilters>(props: {
    nodeId: FilterValue;

    option: ListerFilterOption<TFilters>;
    ctx: ListerFilterCtx<TFilters>;

    selectedIds: Array<FilterValue>;

    openGroups: Record<string, boolean>;
    onToggleGroup: (key: string) => void;

    onApply: (optionId: FilterValue) => void;

    depth?: number;
}) {
    const { option, ctx, selectedIds, onApply, nodeId } = props;
    const depth = props.depth ?? 0;

    const optAny = option as any;

    // custom render wins
    if (option.render) {
        return (
            <div className={depth ? "pl-3" : ""}>
                {option.render({
                    option,
                    ctx,
                    state: {
                        open: true,
                        selected: selectedIds.includes(nodeId),
                    },
                    actions: { close() {} },
                })}
            </div>
        );
    }

    const hasChildren = !!option.children?.length;

    const groupKey = `group:${String(nodeId)}`;
    const groupOpen = Boolean(props.openGroups[groupKey]);

    // ✅ THIS IS THE KEY FIX:
    // value nodes should be clickable even without option.apply
    const isValueKind = optAny?.kind === "value";
    const hasApply = !!option.apply;
    const isClickableToggle = isValueKind || hasApply;

    const isInput = !!optAny.input;

    const isSelected = selectedIds.includes(nodeId);

    const resolvedInputBindKey = (optAny.input?.bindKey ?? optAny.bindKey) as
        | (keyof TFilters & string)
        | undefined;

    const renderRow = () => {
        return (
            <div
                className={[
                    "flex items-center gap-2 rounded-md px-2 py-1.5",
                    "hover:bg-muted/50",
                    option.disabled ? "opacity-50 pointer-events-none" : "",
                ].join(" ")}
            >
                {hasChildren ? (
                    <button
                        type="button"
                        className="flex size-5 items-center justify-center rounded-md hover:bg-muted"
                        onClick={(e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            props.onToggleGroup(groupKey);
                        }}
                        aria-label="Toggle group"
                    >
                        <ChevronRight
                            className={[
                                "h-4 w-4 transition-transform",
                                groupOpen ? "rotate-90" : "",
                            ].join(" ")}
                        />
                    </button>
                ) : (
                    <span className="size-5" />
                )}

                {isClickableToggle ? (
                    <button
                        type="button"
                        className="flex flex-1 items-center justify-between gap-3 text-left"
                        onClick={(e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            onApply(nodeId);
                        }}
                    >
                        <div className="min-w-0">
                            <div className="truncate text-sm">
                                {option.label ?? String(option.value)}
                            </div>
                            {option.description ? (
                                <div className="truncate text-xs opacity-70">
                                    {option.description}
                                </div>
                            ) : null}
                        </div>

                        <span className="flex items-center">
                            {isSelected ? (
                                <Check className="h-4 w-4" />
                            ) : (
                                <span className="h-4 w-4" />
                            )}
                        </span>
                    </button>
                ) : (
                    <div className="flex-1 min-w-0">
                        <div className="truncate text-sm">
                            {option.label ?? String(option.value)}
                        </div>
                        {option.description ? (
                            <div className="truncate text-xs opacity-70">
                                {option.description}
                            </div>
                        ) : null}
                    </div>
                )}
            </div>
        );
    };

    const renderInput = () => {
        if (!optAny.input) return null;
        if (!resolvedInputBindKey) return null;

        const currentValue = ctx.get(resolvedInputBindKey as any);
        const variant = optAny.input.variant as VariantKey;

        const extraProps = (optAny.input.props ?? {}) as VariantPropsFor<any>;

        return (
            <div className="pl-9 pr-2 pb-2">
                <InputField
                    variant={variant}
                    {...(extraProps as any)}
                    value={currentValue as any}
                    onChange={(e: any) => {
                        const v = extractValueFromInputFieldEvent(e);

                        if (optAny.input?.unsetOnEmpty && isEmptyValue(v)) {
                            ctx.unset(resolvedInputBindKey as any);
                            return;
                        }

                        const mode = optAny.input?.mode ?? "replace";
                        if (mode === "merge") {
                            ctx.merge({ [resolvedInputBindKey]: v } as any);
                        } else {
                            ctx.set(resolvedInputBindKey as any, v);
                        }
                    }}
                />
            </div>
        );
    };

    return (
        <div className={depth ? "pl-2" : ""}>
            {renderRow()}

            {isInput ? renderInput() : null}

            {hasChildren && groupOpen ? (
                <div className="mt-1 space-y-1">
                    {option.children!.map((child) => {
                        const childId = getOptionId(child as any);
                        return (
                            <FilterNode
                                key={String(childId)}
                                nodeId={childId}
                                option={child}
                                ctx={ctx}
                                selectedIds={selectedIds}
                                openGroups={props.openGroups}
                                onToggleGroup={props.onToggleGroup}
                                onApply={onApply}
                                depth={depth + 1}
                            />
                        );
                    })}
                </div>
            ) : null}
        </div>
    );
}
```

---
#### 14


` File: packages/form-palette/src/presets/lister/ui/search.tsx`  [↑ Back to top](#index)

```tsx
// packages/form-palette/src/presets/lister/ui/search.tsx

import * as React from "react";
import { InputField } from "@/input/input-field";
import {
    MapPin,
    Search,
    Globe as FaGlobeAmericas,
    SlidersHorizontal,
} from "lucide-react";

import type {
    ListerSearchPayload,
    ListerSearchTarget,
    ListerSessionId,
    ListerStoreState,
} from "@/presets/lister/types";

import { useLister } from "@/presets/lister";
import { Popover, PopoverContent, PopoverTrigger } from "@/presets/ui/popover";
import { Input } from "@/presets/ui/input";
import { Button } from "@/presets/ui/button";

// ✅ NEW: use our custom filter UI button
import { ListerFiltersButton } from "./filter-ui";

type AnyPresetMap = any;

type FilterValue = string | number;

function asArray(v: any): FilterValue[] {
    if (v == null) return [];
    return Array.isArray(v) ? (v as FilterValue[]) : ([v] as FilterValue[]);
}

/**
 * Search bar + trailing controls:
 * - Search target (all/subject/only) popover (leading control)
 * - Search mode toggle (remote/local/hybrid)
 * - Filters UI (custom popover button)
 *
 * Notes:
 * - Search mode is bound to session.searchMode via actions.setSearchMode(id, mode)
 * - Search target is bound to session.searchTarget via actions.setSearchTarget(id, target)
 * - Filters live in session.filtersSpec?.options and session.selectedFilterValues
 */
export function SearchBar(props: {
    id: ListerSessionId;
    store: ListerStoreState;
}) {
    const { id, store } = props;
    const { actions } = useLister<AnyPresetMap>();

    const session = store.sessions[id] as any;

    const searchMode: "local" | "remote" | "hybrid" = (session?.searchMode ??
        "remote") as any;

    const query = session?.query ?? "";

    const hasFilters = !!session?.filtersSpec?.options?.length;

    // Spec coming from your ListerDefinition.search
    const searchSpec = session?.searchSpec as
        | undefined
        | {
              subjects?: readonly string[];
              only?: readonly string[];
              allowAll?: boolean;
              allowCustomSubject?: boolean;
              allowCustomOnly?: boolean;
              default?: string;
          };

    const specSubjects = (searchSpec?.subjects ?? []) as string[];
    const specOnly = (searchSpec?.only ?? []) as string[];
    const allowAll = !!searchSpec?.allowAll;
    const allowCustomSubject = !!searchSpec?.allowCustomSubject;
    const allowCustomOnly = !!searchSpec?.allowCustomOnly;

    // persisted target (like searchMode)
    const target: ListerSearchTarget =
        (session?.searchTarget as any) ??
        (searchSpec?.default
            ? { mode: "subject", subject: searchSpec.default }
            : allowAll
              ? { mode: "all" }
              : { mode: "subject", subject: specSubjects[0] ?? null });

    // UI helper: when subject is not in the list, treat as "custom"
    const subjectValue = (target?.subject ?? "") as string;
    const isCustomSubject =
        !!subjectValue &&
        specSubjects.length > 0 &&
        !specSubjects.includes(subjectValue);

    const subjectSelectValue =
        isCustomSubject && allowCustomSubject ? "__custom__" : subjectValue;

    const onlyValue = asArray(target?.only);

    const buildSearchPayload = (t: ListerSearchTarget): ListerSearchPayload => {
        if (t.mode === "all") return { searchAll: true };

        if (t.mode === "only") {
            const only = asArray(t.only)
                .map((x) => String(x).trim())
                .filter(Boolean);

            return only.length ? { searchOnly: only } : {};
        }

        const subject = (t.subject ?? "").trim();
        return subject ? { subject } : {};
    };

    /**
     * IMPORTANT:
     * - remote => call searchRemote (provider debounces + fetches)
     * - local  => call searchLocal (no fetch)
     * - hybrid => call searchLocal ONLY (provider's hybrid logic schedules remote fetch)
     */
    const runSearch = (mode: "local" | "remote" | "hybrid", q: string) => {
        const latestTarget = ((store.sessions[id] as any)?.searchTarget ??
            target) as ListerSearchTarget;

        const payload = buildSearchPayload(latestTarget);

        if (mode === "remote") return actions.searchRemote(id, q, payload);
        if (mode === "local") return actions.searchLocal(id, q, payload);

        // hybrid: local now, remote is scheduled by provider
        return actions.searchLocal(id, q, payload);
    };

    const onQueryChange = (q: string) => {
        runSearch(searchMode, q);
    };

    const onSearchModeChange = (mode: "local" | "remote" | "hybrid") => {
        actions.setSearchMode(id, mode);

        // make behavior feel immediate when switching
        queueMicrotask(() => {
            const s = (store.sessions[id] as any) ?? session;
            const q = s?.query ?? "";
            runSearch(mode, q);
        });
    };

    const commitSearchTarget = (next: ListerSearchTarget) => {
        // Provider will persist it and (for remote/hybrid) schedule a refetch based on session.searchTarget
        actions.setSearchTarget(id, next);

        // For local mode, "refetch" isn't a thing, but we still want the UI to feel immediate.
        if (searchMode === "local") {
            queueMicrotask(() => {
                const s = (store.sessions[id] as any) ?? session;
                const q = s?.query ?? "";
                runSearch("local", q);
            });
        }
    };

    const hasSearchTargetUI =
        !!searchSpec &&
        (allowAll ||
            specSubjects.length > 0 ||
            specOnly.length > 0 ||
            allowCustomSubject);


    return (
        <div className="px-3 py-2" onMouseDown={() => actions.focus(id)}>
            <Input
                value={query}
                onChange={(e) => onQueryChange(e.target.value)}
                placeholder={
                    searchMode === "local"
                        ? "Search…"
                        : searchMode === "hybrid"
                          ? "Search (hybrid)…"
                          : "Search (remote)…"
                }
                icon={<Search className="h-4 w-4" />}
                leadingControl={
                    hasSearchTargetUI ? (
                        <Popover>
                            <PopoverTrigger asChild>
                                <Button
                                    type="button"
                                    size="icon"
                                    variant="ghost"
                                    title="Search target"
                                >
                                    <SlidersHorizontal className="h-4 w-4" />
                                </Button>
                            </PopoverTrigger>

                            <PopoverContent align="start" className="w-80 p-3">
                                <div className="space-y-3">
                                    <div className="text-xs opacity-70">
                                        Search target
                                    </div>

                                    <InputField
                                        variant="select"
                                        mode="button"
                                        value={target.mode}
                                        options={[
                                            ...(allowAll
                                                ? [
                                                      {
                                                          label: "All",
                                                          value: "all",
                                                      },
                                                  ]
                                                : []),
                                            {
                                                label: "Subject",
                                                value: "subject",
                                            },
                                            { label: "Only", value: "only" },
                                        ]}
                                        onChange={(e: any) => {
                                            const mode =
                                                e?.value as ListerSearchTarget["mode"];

                                            if (mode === "all") {
                                                commitSearchTarget({
                                                    mode: "all",
                                                });
                                                return;
                                            }

                                            if (mode === "only") {
                                                commitSearchTarget({
                                                    mode: "only",
                                                    only: onlyValue.length
                                                        ? onlyValue
                                                        : specOnly.length
                                                          ? [specOnly[0]]
                                                          : [],
                                                });
                                                return;
                                            }

                                            commitSearchTarget({
                                                mode: "subject",
                                                subject:
                                                    subjectValue ||
                                                    searchSpec?.default ||
                                                    specSubjects[0] ||
                                                    null,
                                            });
                                        }}
                                    />

                                    {target.mode === "subject" ? (
                                        <div className="space-y-2">
                                            {specSubjects.length ? (
                                                <InputField
                                                    variant="select"
                                                    mode="button"
                                                    value={subjectSelectValue}
                                                    options={[
                                                        ...specSubjects.map(
                                                            (c) => ({
                                                                label: c,
                                                                value: c,
                                                            }),
                                                        ),
                                                        ...(allowCustomSubject
                                                            ? [
                                                                  {
                                                                      label: "Custom…",
                                                                      value: "__custom__",
                                                                  },
                                                              ]
                                                            : []),
                                                    ]}
                                                    onChange={(e: any) => {
                                                        const v =
                                                            e?.value as string;

                                                        if (
                                                            v === "__custom__"
                                                        ) {
                                                            commitSearchTarget({
                                                                mode: "subject",
                                                                subject:
                                                                    subjectValue ||
                                                                    "",
                                                            });
                                                            return;
                                                        }

                                                        commitSearchTarget({
                                                            mode: "subject",
                                                            subject: v,
                                                        });
                                                    }}
                                                />
                                            ) : null}

                                            {allowCustomSubject &&
                                            subjectSelectValue ===
                                                "__custom__" ? (
                                                <div className="space-y-1">
                                                    <div className="text-xs opacity-70">
                                                        Custom column
                                                    </div>
                                                    <input
                                                        value={subjectValue}
                                                        onChange={(e) =>
                                                            commitSearchTarget({
                                                                mode: "subject",
                                                                subject:
                                                                    e.target
                                                                        .value,
                                                            })
                                                        }
                                                        placeholder="e.g. email"
                                                        className="h-9 w-full rounded-md border px-3 text-sm"
                                                    />
                                                </div>
                                            ) : null}
                                        </div>
                                    ) : null}

                                    {target.mode === "only" ? (
                                        <div className="space-y-2">
                                            <InputField
                                                variant="multi-select"
                                                mode="button"
                                                value={onlyValue as any}
                                                options={specOnly.map((c) => ({
                                                    label: c,
                                                    value: c,
                                                }))}
                                                onChange={(e: any) =>
                                                    commitSearchTarget({
                                                        mode: "only",
                                                        only: asArray(e?.value),
                                                    })
                                                }
                                            />

                                            {allowCustomOnly ? (
                                                <div className="space-y-1">
                                                    <div className="text-xs opacity-70">
                                                        Add custom column
                                                    </div>
                                                    <input
                                                        placeholder="type column + Enter"
                                                        className="h-9 w-full rounded-md border px-3 text-sm"
                                                        onKeyDown={(e) => {
                                                            if (
                                                                e.key !==
                                                                "Enter"
                                                            )
                                                                return;

                                                            const v = (
                                                                e.currentTarget
                                                                    .value ?? ""
                                                            ).trim();
                                                            if (!v) return;

                                                            e.preventDefault();

                                                            const next =
                                                                Array.from(
                                                                    new Set([
                                                                        ...onlyValue.map(
                                                                            String,
                                                                        ),
                                                                        v,
                                                                    ]),
                                                                );

                                                            e.currentTarget.value =
                                                                "";

                                                            commitSearchTarget({
                                                                mode: "only",
                                                                only: next,
                                                            });
                                                        }}
                                                    />
                                                </div>
                                            ) : null}
                                        </div>
                                    ) : null}
                                </div>
                            </PopoverContent>
                        </Popover>
                    ) : null
                }
                trailingControl={
                    <div className="flex items-center gap-2">
                        <InputField
                            variant="select"
                            mode="button"
                            defaultValue={searchMode}
                            triggerClassName={'border-none ring-0 shadow-none! px-1! cursor-pointer'}
                            options={[
                                {
                                    label: "Remote search",
                                    value: "remote",
                                    icon: (
                                        <FaGlobeAmericas className="size-3" />
                                    ),
                                },
                                {
                                    label: "Local search",
                                    value: "local",
                                    icon: <MapPin className="size-3" />,
                                },
                                {
                                    label: "Hybrid search",
                                    value: "hybrid",
                                    icon: (
                                        <FaGlobeAmericas className="size-3" />
                                    ),
                                },
                            ]}
                            onChange={(e: any) => onSearchModeChange(e?.value)}
                        />

                        {/* ✅ NEW: filters UI */}
                        {hasFilters ? (
                            <ListerFiltersButton id={id} store={store} />
                        ) : null}
                    </div>
                }
            />
        </div>
    );
}
```

---
#### 15


` File: packages/form-palette/src/presets/lister/utils/path.ts`  [↑ Back to top](#index)

```ts
// resources/js/context/lister/utils/path.ts

/**
 * Very small dot-path getter.
 * Supports:
 * - "a.b.c"
 * - ".a.b" (leading dot ok)
 * - "a[0].b" (basic bracket index)
 */
export function getPath(obj: any, path: string): any {
    if (!path) return obj;
    let p = path.trim();
    if (p.startsWith('.')) p = p.slice(1);

    // convert bracket notation into dots: a[0].b -> a.0.b
    p = p.replace(/\[(\d+)\]/g, '.$1');

    const parts = p.split('.').filter(Boolean);
    let cur: any = obj;

    for (const key of parts) {
        if (cur == null) return undefined;
        cur = cur[key as any];
    }

    return cur;
}
```

---
#### 16


` File: packages/form-palette/src/presets/lister/utils/permissions.ts`  [↑ Back to top](#index)

```ts
// resources/js/context/lister/utils/permissions.ts

import type { ListerPermissionCtx, ListerProviderHost } from '../types';

function stripBang(p: string) {
    return p.endsWith('!') ? p.slice(0, -1) : p;
}

function isMandatory(p: string) {
    return p.endsWith('!');
}

/**
 * Provider-side evaluation using host.can(...) as a primitive check.
 * We call host.can([perm], ctx) per entry so we can enforce:
 * - all mandatory pass
 * - if any optional exist, at least one optional passes
 */
export function evaluatePermissions(host: ListerProviderHost, entries: string[] | undefined, ctx: ListerPermissionCtx): boolean {
    if (!entries || entries.length === 0) return true;

    const mandatory = entries.filter(isMandatory).map(stripBang);
    const optional = entries.filter((p) => !isMandatory(p)).map(stripBang);

    for (const perm of mandatory) {
        if (!host.can([perm], ctx)) return false;
    }

    if (optional.length > 0) {
        return optional.some((perm) => host.can([perm], ctx));
    }

    return true;
}
```


---
*Generated with [Prodex](https://github.com/emxhive/prodex) — Codebase decoded.*
<!-- PRODEx v1.4.9 | 2025-12-31T06:24:55.478Z -->