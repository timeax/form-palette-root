# Index  L8-L63 

> Note for LLMs: `Lx-Ly` ranges refer to lines in this Prodex trace file, not the original source files.

*Generated by [Prodex](https://github.com/emxhive/prodex#readme)*

Included Source Files: 56
- [packages/form-palette/src/presets/shadcn-variants/checkbox.tsx](#1)  L66-L972
- [packages/form-palette/src/presets/shadcn-variants/chips.tsx](#2)  L973-L1738
- [packages/form-palette/src/presets/shadcn-variants/color.tsx](#3)  L1739-L2031
- [packages/form-palette/src/presets/shadcn-variants/custom.tsx](#4)  L2032-L2267
- [packages/form-palette/src/presets/shadcn-variants/date.tsx](#5)  L2268-L3072
- [packages/form-palette/src/presets/shadcn-variants/editor.tsx](#6)  L3073-L3382
- [packages/form-palette/src/presets/shadcn-variants/file.tsx](#7)  L3383-L4851
- [packages/form-palette/src/presets/shadcn-variants/json-editor/editor.tsx](#8)  L4852-L5553
- [packages/form-palette/src/presets/shadcn-variants/json-editor/header.tsx](#9)  L5554-L5688
- [packages/form-palette/src/presets/shadcn-variants/json-editor/index.tsx](#10)  L5689-L6193
- [packages/form-palette/src/presets/shadcn-variants/json-editor/main.tsx](#11)  L6194-L6969
- [packages/form-palette/src/presets/shadcn-variants/json-editor/raw-panel.tsx](#12)  L6970-L7103
- [packages/form-palette/src/presets/shadcn-variants/json-editor/types.ts](#13)  L7104-L7557
- [packages/form-palette/src/presets/shadcn-variants/keyvalue.tsx](#14)  L7558-L8120
- [packages/form-palette/src/presets/shadcn-variants/lister.tsx](#15)  L8121-L8158
- [packages/form-palette/src/presets/shadcn-variants/lister/index.tsx](#16)  L8159-L8485
- [packages/form-palette/src/presets/shadcn-variants/lister/inner.tsx](#17)  L8486-L9198
- [packages/form-palette/src/presets/shadcn-variants/lister/patch.ts](#18)  L9199-L9442
- [packages/form-palette/src/presets/shadcn-variants/lister/popover.tsx](#19)  L9443-L9510
- [packages/form-palette/src/presets/shadcn-variants/lister/types.ts](#20)  L9511-L9727
- [packages/form-palette/src/presets/shadcn-variants/lister/utils.tsx](#21)  L9728-L9929
- [packages/form-palette/src/presets/shadcn-variants/multiselect.tsx](#22)  L9930-L11030
- [packages/form-palette/src/presets/shadcn-variants/number.tsx](#23)  L11031-L11215
- [packages/form-palette/src/presets/shadcn-variants/password.tsx](#24)  L11216-L11961
- [packages/form-palette/src/presets/shadcn-variants/phone.tsx](#25)  L11962-L12616
- [packages/form-palette/src/presets/shadcn-variants/radio.tsx](#26)  L12617-L13201
- [packages/form-palette/src/presets/shadcn-variants/select.tsx](#27)  L13202-L14227
- [packages/form-palette/src/presets/shadcn-variants/slider.tsx](#28)  L14228-L14858
- [packages/form-palette/src/presets/shadcn-variants/text.tsx](#29)  L14859-L15210
- [packages/form-palette/src/presets/shadcn-variants/textarea.tsx](#30)  L15211-L15285
- [packages/form-palette/src/presets/shadcn-variants/toggle-group.tsx](#31)  L15286-L15840
- [packages/form-palette/src/presets/shadcn-variants/toggle.tsx](#32)  L15841-L16067
- [packages/form-palette/src/presets/shadcn-variants/tree-select-types.ts](#33)  L16068-L16108
- [packages/form-palette/src/presets/shadcn-variants/treeselect.tsx](#34)  L16109-L17052
- [packages/form-palette/src/variants/core/checkbox.tsx](#35)  L17053-L17115
- [packages/form-palette/src/variants/core/chips.tsx](#36)  L17116-L17146
- [packages/form-palette/src/variants/core/color.tsx](#37)  L17147-L17171
- [packages/form-palette/src/variants/core/custom.tsx](#38)  L17172-L17198
- [packages/form-palette/src/variants/core/date.tsx](#39)  L17199-L17232
- [packages/form-palette/src/variants/core/editor.ts](#40)  L17233-L17253
- [packages/form-palette/src/variants/core/file.tsx](#41)  L17254-L17271
- [packages/form-palette/src/variants/core/json-editor.tsx](#42)  L17272-L17360
- [packages/form-palette/src/variants/core/keyvalue.tsx](#43)  L17361-L17381
- [packages/form-palette/src/variants/core/lister.tsx](#44)  L17382-L17421
- [packages/form-palette/src/variants/core/multiselect.tsx](#45)  L17422-L17458
- [packages/form-palette/src/variants/core/number.tsx](#46)  L17459-L17582
- [packages/form-palette/src/variants/core/password.tsx](#47)  L17583-L17626
- [packages/form-palette/src/variants/core/phone.tsx](#48)  L17627-L17651
- [packages/form-palette/src/variants/core/radio.tsx](#49)  L17652-L17698
- [packages/form-palette/src/variants/core/select.tsx](#50)  L17699-L17722
- [packages/form-palette/src/variants/core/slider.tsx](#51)  L17723-L17786
- [packages/form-palette/src/variants/core/text.tsx](#52)  L17787-L17909
- [packages/form-palette/src/variants/core/textarea.tsx](#53)  L17910-L17940
- [packages/form-palette/src/variants/core/toggle-group.tsx](#54)  L17941-L17965
- [packages/form-palette/src/variants/core/toggle.tsx](#55)  L17966-L18024
- [packages/form-palette/src/variants/core/treeselect.tsx](#56)  L18025-L18047

---
---
#### 1


` File: packages/form-palette/src/presets/shadcn-variants/checkbox.tsx`  [↑ Back to top](#index)

```tsx
// noinspection RedundantConditionalExpressionJS,PointlessBooleanExpressionJS,SuspiciousTypeOfGuard,GrazieInspection,GrazieStyle

import * as React from "react";
import type { VariantBaseProps, ChangeDetail } from "@/variants/shared";
import { cn } from "@/lib/utils";
import { Checkbox } from "@/presets/ui/checkbox";
import { globalNormalizeCheckBasedOptions } from "@/lib/normalise-options";
import { buildGroupLayoutClasses } from "@/lib/group-layout";

// ─────────────────────────────────────────────
// Types
// ─────────────────────────────────────────────

export type CheckboxSize = "sm" | "md" | "lg";
export type CheckboxDensity = "compact" | "comfortable" | "loose";
export type CheckboxLayoutMode = "list" | "grid";

/**
 * Internal state we store in the value list.
 * "none" never goes into the external value.
 */
export type CheckboxTriStateValue = true | false;

/**
 * Internal state we pass to the Shadcn checkbox.
 * "none" is used to represent "no stance yet".
 */
export type CheckboxInternalState = true | false | "none";

export interface CheckboxGroupEntry<TValue> {
    value: TValue;
    state: CheckboxTriStateValue; // true or false only
}

export type CheckboxGroupValue<TValue> =
    | readonly CheckboxGroupEntry<TValue>[]
    | undefined;

/**
 * Single checkbox value.
 * undefined → "none"
 */
export type CheckboxSingleValue = boolean | undefined;

/**
 * Public union type for the variant's value.
 *
 * - In single mode: we expect CheckboxSingleValue
 * - In group mode: we expect CheckboxGroupValue<TValue>
 *
 * At the type level this is a union; at runtime we branch using `single`.
 */
export type CheckboxVariantValue<TValue> =
    | CheckboxSingleValue
    | CheckboxGroupValue<TValue>;

export interface CheckboxItem<TValue> {
    value: TValue;
    label: React.ReactNode;
    description?: React.ReactNode;
    disabled?: boolean;
    key?: React.Key;

    /**
     * Option-level renderer (provided by the normaliser).
     * If present, it should override the variant-level `renderOption` for this item.
     */
    render?: (ctx: CheckboxRenderOptionContext<TValue>) => React.ReactNode;

    /**
     * Override tri-state behaviour for this item.
     * If undefined, variant-level `tristate` is used.
     */
    tristate?: boolean;
}

export interface CheckboxMappers<TItem, TValue> {
    getValue: (item: TItem, index: number) => TValue;
    getLabel: (item: TItem, index: number) => React.ReactNode;
    getDescription?: (item: TItem, index: number) => React.ReactNode;
    isDisabled?: (item: TItem, index: number) => boolean;
    getKey?: (item: TItem, index: number) => React.Key;
    getTristate?: (item: TItem, index: number) => boolean | undefined;
}

export interface CheckboxRenderOptionContext<TValue> {
    item: CheckboxItem<TValue>;
    index: number;
    state: CheckboxInternalState;
    effectiveTristate: boolean;
    disabled: boolean;
    size: CheckboxSize;
    density: CheckboxDensity;
    checkboxId?: string;
    click(): void;
    /**
     * Prebuilt Shadcn checkbox node.
     */
    checkbox: React.ReactNode;
}

/**
 * UI props for both single and group modes.
 */
export interface ShadcnCheckboxUiProps<TItem, TValue> {
    /**
     * Group mode:
     *  - Required when `single` is not true.
     *
     * Single mode:
     *  - Optional; if provided, `items[0]` can supply label/description.
     */
    options?: readonly TItem[];
    /**
     * Group mode:
     *  - Optional; if provided, `items` can supply label/description.
     *
     * Single mode:
     *  - Required when `single` is true.
     */
    items?: readonly TItem[];

    /**
     * Mapping functions for arbitrary item shapes.
     * Takes precedence over optionValue/optionLabel.
     */
    mappers?: CheckboxMappers<TItem, TValue>;

    /**
     * Property name that holds the value on each item.
     *
     * Example:
     *   items = [{ id: "read", label: "Read" }]
     *   optionValue = "id"
     */
    optionValue?: keyof TItem;

    /**
     * Property name that holds the label on each item.
     *
     * Example:
     *   items = [{ id: "read", title: "Read" }]
     *   optionLabel = "title"
     */
    optionLabel?: keyof TItem;

    /**
     * Custom renderer for each option row.
     */
    renderOption?: (
        ctx: CheckboxRenderOptionContext<TValue>
    ) => React.ReactNode;

    /**
     * If true, treat this variant as a single checkbox instead of a group.
     *
     * Value is then CheckboxSingleValue (boolean | undefined).
     */
    single?: boolean;

    /**
     * Variant-level default tri-state behaviour.
     *
     * - In single mode: directly controls tri-state for the single checkbox.
     * - In group mode: default for all items, unless item.tristate overrides.
     */
    tristate?: boolean;

    /**
     * Layout mode in group mode: vertical list or CSS grid.
     */
    layout?: CheckboxLayoutMode;

    /**
     * Number of columns in grid mode.
     * Default: 2.
     */
    columns?: number;

    /**
     * Gap between items in px.
     */
    itemGapPx?: number;

    /**
     * Visual size of the checkbox / text.
     * Default: "md".
     */
    size?: CheckboxSize;

    /**
     * Vertical density of each row.
     * Default: "comfortable".
     */
    density?: CheckboxDensity;

    /**
     * When true, capitalizes the first letter of the label
     * (only applied when the label is a string).
     */
    autoCap?: boolean;

    /**
     * ARIA attributes for the group wrapper.
     */
    "aria-label"?: string;
    "aria-labelledby"?: string;

    /**
     * Wrapper class for the entire group (or single field).
     */
    groupClassName?: string;

    /**
     * Extra classes for each option row (group mode).
     */
    optionClassName?: string;

    /**
     * Extra classes for the option label text.
     */
    labelClassName?: string;

    /**
     * Extra classes for the option label text in group mode only.
     * This allows styling group item labels without affecting single mode labels.
     */
    optionLabelClassName?: string;

    /**
     * Extra classes for the option description text.
     */
    descriptionClassName?: string;

    /**
     * Single-mode inline label (if you want variant-level text).
     * Usually you'll rely on InputField's label instead.
     */
    singleLabel?: React.ReactNode;

    /**
     * Single-mode description text under the label.
     */
    singleDescription?: React.ReactNode;
}

/**
 * Full props for the Shadcn-based checkbox variant.
 *
 * TValue: primitive or object key
 * TItem: item shape used to build checkbox items
 */
export type ShadcnCheckboxVariantProps<
    TValue,
    TItem = CheckboxItem<TValue>,
> = ShadcnCheckboxUiProps<TItem, TValue> &
    Pick<
        VariantBaseProps<CheckboxVariantValue<TValue>>,
        "value" | "onValue" | "error" | "disabled" | "required"
    > & {
        id?: string;
        className?: string; // alias for groupClassName
        name?: string; // optional: name for native form post in group mode
        "aria-describedby"?: string;
    };

// ─────────────────────────────────────────────
// Helpers
// ─────────────────────────────────────────────

function paddingForDensity(density: CheckboxDensity): string {
    switch (density) {
        case "compact":
        // return "py-1.5";
        case "loose":
            return "py-2";
        case "comfortable":
        default:
            return "py-0";
    }
}

function labelTextSize(size: CheckboxSize): string {
    switch (size) {
        case "sm":
            return "text-xs";
        case "lg":
            return "text-base";
        case "md":
        default:
            return "text-sm";
    }
}

function descriptionTextSize(size: CheckboxSize): string {
    switch (size) {
        case "sm":
            return "text-[0.7rem]";
        case "lg":
            return "text-sm";
        case "md":
        default:
            return "text-xs";
    }
}

function capitalizeFirst(label: string): string {
    if (!label) return label;
    return label.charAt(0).toUpperCase() + label.slice(1);
}

/**
 * Normalize arbitrary items to CheckboxItem<TValue>[] using:
 * 1) mappers,
 * 2) optionValue/optionLabel,
 * 3) native CheckboxItem fields,
 * 4) primitive arrays (string[] / number[] / boolean[]).
 */
function normalizeItems<TItem, TValue>(
    items: readonly TItem[] | undefined,
    mappers?: CheckboxMappers<TItem, TValue>,
    optionValueKey?: keyof TItem,
    optionLabelKey?: keyof TItem
): CheckboxItem<TValue>[] {
    if (!items || !items.length) return [];

    // 1) Explicit mappers win
    if (mappers) {
        return items.map((item, index) => ({
            value: mappers.getValue(item, index),
            label: mappers.getLabel(item, index),
            description: mappers.getDescription
                ? mappers.getDescription(item, index)
                : undefined,
            disabled: mappers.isDisabled
                ? mappers.isDisabled(item, index)
                : false,
            key: mappers.getKey ? mappers.getKey(item, index) : index,
            tristate: mappers.getTristate
                ? mappers.getTristate(item, index)
                : undefined,
        }));
    }

    // 2) optionValue / optionLabel
    if (optionValueKey || optionLabelKey) {
        return items.map((item, index) => {
            const anyItem = item as any;
            const normalised = globalNormalizeCheckBasedOptions(
                item as any,
                index,
                optionLabelKey,
                optionValueKey
            );
            const tristate = anyItem.tristate as boolean | undefined;

            return {
                ...normalised,
                tristate,
            };
        });
    }

    // 3 & 4) Fallbacks:
    //    - primitive arrays (string[] / number[] / boolean[])
    //    - already-shaped CheckboxItem<TValue>[]
    return items.map((item, index) => {
        if (
            typeof item === "string" ||
            typeof item === "number" ||
            typeof item === "boolean"
        ) {
            const v = item as unknown as TValue;
            return {
                value: v,
                label: String(item),
                description: undefined,
                disabled: false,
                key: index,
                tristate: undefined,
            } satisfies CheckboxItem<TValue>;
        }

        return item as unknown as CheckboxItem<TValue>;
    });
}

function isEqualValue(a: unknown, b: unknown): boolean {
    return Object.is(a, b);
}

/**
 * Extract group value from the union.
 */
function asGroupValue<TValue>(
    value: CheckboxVariantValue<TValue>
): CheckboxGroupValue<TValue> {
    if (!value) return undefined;
    if (Array.isArray(value)) return value;
    return undefined;
}

/**
 * Extract single value from the union.
 */
function asSingleValue(
    value: CheckboxVariantValue<unknown>
): CheckboxSingleValue {
    if (Array.isArray(value)) return undefined;
    if (typeof value === "boolean" || value === undefined) return value;
    return undefined;
}

// ─────────────────────────────────────────────
// Component
// ─────────────────────────────────────────────

const InnerShadcnCheckboxVariant = <TValue, TItem = CheckboxItem<TValue>>(
    props: ShadcnCheckboxVariantProps<TValue, TItem>,
    ref: React.Ref<HTMLDivElement>
) => {
    const {
        // variant base
        value,
        onValue,
        error,
        disabled,
        required,

        // UI / behaviour
        items,
        options,
        mappers,
        optionValue,
        optionLabel,
        renderOption,
        single,
        tristate: tristateDefault,
        layout = "list",
        columns = 2,
        itemGapPx,
        size = "md",
        density = "comfortable",
        autoCap = false,

        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-describedby": ariaDescribedBy,
        name,

        groupClassName,
        optionClassName,
        labelClassName,
        optionLabelClassName,
        descriptionClassName,

        className, // alias for groupClassName

        singleLabel,
        singleDescription,

        id,
        ...restProps
    } = props;

    const hasError = !!error;
    const isSingle = !!single;

    // ─────────────────────────────────────────
    // Single mode
    // ─────────────────────────────────────────
    if (isSingle) {
        const singleVal = asSingleValue(value);
        const effectiveTristate = !!tristateDefault;

        const internalState: CheckboxInternalState = effectiveTristate
            ? (singleVal ?? "none")
            : !!singleVal;

        const handleSingleChange = (next: CheckboxInternalState) => {
            if (!onValue || disabled) return;

            let nextPublic: CheckboxSingleValue;

            if (effectiveTristate) {
                // tri-state single:
                // "none" → undefined
                // true/false → same
                nextPublic = next === "none" ? undefined : !!next;
            } else {
                // non-tristate: behave like normal checkbox
                nextPublic = next === true;
            }

            const detail: ChangeDetail = {
                source: "variant",
                raw: nextPublic,
                nativeEvent: undefined,
                meta: undefined,
            };

            onValue(nextPublic, detail);
        };

        let labelText = singleLabel ?? undefined;
        if (autoCap && typeof labelText === "string") {
            labelText = capitalizeFirst(labelText);
        }

        const descriptionText = singleDescription ?? undefined;

        const labelCls = cn(
            "text-foreground",
            labelTextSize(size),
            labelClassName
        );

        const descriptionCls = cn(
            "mt-0.5 text-muted-foreground",
            descriptionTextSize(size),
            descriptionClassName
        );

        return (
            <div
                ref={ref}
                role="group"
                aria-label={ariaLabel}
                aria-labelledby={ariaLabelledBy}
                aria-describedby={ariaDescribedBy}
                aria-invalid={hasError || undefined}
                aria-required={required || undefined}
                data-slot="checkbox-single"
                className={cn(
                    "flex items-start gap-3",
                    paddingForDensity(density),
                    groupClassName ?? className
                )}
                {...restProps}
            >
                <Checkbox
                    id={id}
                    checked={internalState}
                    tristate={effectiveTristate}
                    disabled={disabled}
                    onCheckedChange={handleSingleChange}
                    className="mt-0.5"
                />

                {(labelText || descriptionText) && (
                    <div className="flex min-w-0 flex-col">
                        {labelText && (
                            <span className={labelCls}>{labelText}</span>
                        )}
                        {descriptionText && (
                            <span className={descriptionCls}>
                                {descriptionText}
                            </span>
                        )}
                    </div>
                )}
            </div>
        );
    }

    // ─────────────────────────────────────────
    // Group mode
    // ─────────────────────────────────────────

    const groupValue = asGroupValue<TValue>(value);
    const normalized = React.useMemo(
        () =>
            normalizeItems<TItem, TValue>(
                items ?? options,
                mappers,
                optionValue,
                optionLabel
            ),
        [items, options, mappers, optionValue, optionLabel]
    );

    const {
        groupStyle,
        groupClasses,
        baseOptionClass,
        labelClassesBase,
        descriptionClassesBase,
    } = buildGroupLayoutClasses({
        layout,
        columns,
        itemGapPx,
        groupClassName,
        className,
        optionClassName,
        labelClassName,
        descriptionClassName,
        densityPaddingClass: paddingForDensity(density),
        labelTextSizeClass: labelTextSize(size),
        descriptionTextSizeClass: descriptionTextSize(size),
    });

    const findEntryIndex = React.useCallback(
        (val: TValue): number => {
            if (!groupValue) return -1;
            return groupValue.findIndex((e) => isEqualValue(e.value, val));
        },
        [groupValue]
    );

    const getEntryState = React.useCallback(
        (val: TValue): CheckboxTriStateValue | "none" => {
            const idx = findEntryIndex(val);
            if (!groupValue || idx === -1) return "none";
            return groupValue[idx].state;
        },
        [groupValue, findEntryIndex]
    );

    const updateGroupValue = React.useCallback(
        (
            itemValue: TValue,
            nextInternal: CheckboxInternalState,
            effectiveTristate: boolean
        ) => {
            if (!onValue || disabled) return;

            const currentList = groupValue ? [...groupValue] : [];
            const idx = currentList.findIndex((e) =>
                isEqualValue(e.value, itemValue)
            );

            let nextList: CheckboxGroupEntry<TValue>[] = currentList;

            if (effectiveTristate) {
                // Tri-state:
                // "none" → remove
                // true/false → ensure entry is present with state
                if (nextInternal === "none") {
                    if (idx !== -1) {
                        nextList = [
                            ...currentList.slice(0, idx),
                            ...currentList.slice(idx + 1),
                        ];
                    }
                } else {
                    const nextState: CheckboxTriStateValue =
                        nextInternal === true;
                    if (idx === -1) {
                        nextList = [
                            ...currentList,
                            { value: itemValue, state: nextState },
                        ];
                    } else {
                        nextList = [...currentList];
                        nextList[idx] = {
                            ...nextList[idx],
                            state: nextState,
                        };
                    }
                }
            } else {
                // Non tri-state:
                // true → ensure present
                // false/"none" → remove entry (false acts as none)
                if (nextInternal === true) {
                    if (idx === -1) {
                        nextList = [
                            ...currentList,
                            { value: itemValue, state: true },
                        ];
                    } else {
                        nextList = [...currentList];
                        nextList[idx] = {
                            ...nextList[idx],
                            state: true,
                        };
                    }
                } else {
                    // false / "none": remove
                    if (idx !== -1) {
                        nextList = [
                            ...currentList.slice(0, idx),
                            ...currentList.slice(idx + 1),
                        ];
                    }
                }
            }

            const detail: ChangeDetail = {
                source: "variant",
                raw: nextList,
                nativeEvent: undefined,
                meta: undefined,
            };

            onValue(nextList, detail);
        },
        [onValue, disabled, groupValue]
    );

    return (
        <div
            ref={ref}
            id={id}
            role="group"
            aria-label={ariaLabel}
            aria-labelledby={ariaLabelledBy}
            aria-describedby={ariaDescribedBy}
            aria-invalid={hasError || undefined}
            aria-required={required || undefined}
            data-slot="checkbox-group"
            className={groupClasses}
            style={groupStyle}
            {...restProps}
        >
            {normalized.map((item, index) => {
                const effectiveTristate =
                    item.tristate ?? tristateDefault ?? false;

                const currentState = getEntryState(item.value);
                const internalState: CheckboxInternalState = effectiveTristate
                    ? currentState // "none" | true | false
                    : currentState === "none"
                      ? false
                      : currentState;

                const optionDisabled = !!disabled || !!item.disabled;
                const optionKey = item.key ?? index;
                const checkboxId = id ? `${id}-option-${optionKey}` : undefined;

                // Apply autoCap to string labels for display
                let displayItem: CheckboxItem<TValue> = item;
                if (autoCap && typeof item.label === "string") {
                    displayItem = {
                        ...item,
                        label: capitalizeFirst(item.label),
                    };
                }

                const checkboxNode = (
                    <Checkbox
                        id={checkboxId}
                        checked={internalState}
                        disabled={optionDisabled}
                        tristate={effectiveTristate}
                        onCheckedChange={(next) =>
                            updateGroupValue(
                                item.value,
                                next as CheckboxInternalState,
                                effectiveTristate
                            )
                        }
                        className="mt-1"
                    />
                );

                const hiddenInput =
                    name != null ? (
                        <input
                            type="hidden"
                            name={name}
                            value={String(item.value)}
                            // Only send if in list; tri-state false still "has standing"
                            // in code, but native form post is simple and you can
                            // derive negative states server-side if you want.
                            disabled={getEntryState(item.value) === "none"}
                        />
                    ) : null;

                
                const renderer = (item as CheckboxItem<TValue>).render ?? renderOption;

                if (renderer) {
                    return (
                        <div
                            key={optionKey}
                            data-slot="checkbox-option"
                            data-disabled={optionDisabled ? "true" : "false"}
                            className={baseOptionClass}
                        >
                            {renderer({
                                item: displayItem,
                                index,
                                state: internalState,
                                effectiveTristate,
                                disabled: optionDisabled,
                                size,
                                density,
                                checkboxId,
                                click() {
                                    if (optionDisabled) return;

                                    const nextInternal: CheckboxInternalState =
                                        effectiveTristate
                                            ? internalState === "none"
                                                ? true
                                                : internalState === true
                                                  ? false
                                                  : "none"
                                            : internalState === true
                                              ? false
                                              : true;

                                    updateGroupValue(
                                        item.value,
                                        nextInternal,
                                        effectiveTristate
                                    );
                                },
                                checkbox: checkboxNode,
                            })}
                            {hiddenInput}
                        </div>
                    );
                }

                // Default row layout: checkbox + label + description
                return (
                    <div
                        key={optionKey}
                        data-slot="checkbox-option"
                        data-disabled={optionDisabled ? "true" : "false"}
                        className={baseOptionClass}
                    >
                        <label
                            htmlFor={checkboxId}
                            className="flex w-full cursor-pointer items-start gap-3 select-none"
                        >
                            {checkboxNode}

                            <div className="flex min-w-0 flex-col">
                                <span
                                    className={cn(
                                        labelClassesBase,
                                        optionLabelClassName
                                    )}
                                >
                                    {displayItem.label}
                                </span>
                                {displayItem.description != null && (
                                    <span className={descriptionClassesBase}>
                                        {displayItem.description}
                                    </span>
                                )}
                            </div>
                        </label>

                        {hiddenInput}
                    </div>
                );
            })}
        </div>
    );
};

export const ShadcnCheckboxVariant = React.forwardRef(
    InnerShadcnCheckboxVariant
) as unknown as <TValue, TItem = CheckboxItem<TValue>>(
    props: ShadcnCheckboxVariantProps<TValue, TItem> & {
        ref?: React.Ref<HTMLDivElement>;
    }
) => React.ReactElement | null;

// ShadcnCheckboxVariant.displayName = "ShadcnCheckboxVariant";

export default ShadcnCheckboxVariant;

// ─────────────────────────────────────────────
// Public aliases for the registry
// ─────────────────────────────────────────────

/**
 * Default item value type for the checkbox variant.
 *
 * You can still use the generic ShadcnCheckboxVariantProps<TValue, TItem>
 * directly if you need a different TValue; the registry uses this alias.
 */
export type DefaultCheckboxItemValue = string | number;

/**
 * Public "value" type for the checkbox variant used by the registry:
 *
 * - Single mode: boolean | undefined
 * - Group mode: CheckboxGroupEntry<DefaultCheckboxItemValue>[] | undefined
 *
 * In tri-state group mode, both `true` and `false` entries are present;
 * `"none"` never appears in this type.
 */
export type CheckboxVariantPublicValue =
    CheckboxVariantValue<DefaultCheckboxItemValue>;

/**
 * Public props type for the checkbox variant used by the registry.
 *
 * This is ShadcnCheckboxVariantProps with TValue fixed to DefaultCheckboxItemValue.
 */
export type ShadcnCheckboxVariantPublicProps =
    ShadcnCheckboxVariantProps<DefaultCheckboxItemValue>;
```

---
#### 2


` File: packages/form-palette/src/presets/shadcn-variants/chips.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/chips.tsx

import * as React from "react";

import type { VariantBaseProps, ChangeDetail } from "@/variants/shared";
import type { ShadcnTextVariantProps } from "@/presets/shadcn-variants/text";
import { Input } from "@/presets/ui/input";
import { Textarea } from "@/presets/ui/textarea";
import { cn } from "@/lib/utils";
import { X } from "lucide-react";

type ChipsValue = string[] | undefined;
type BaseProps = VariantBaseProps<ChipsValue>;

/**
 * How we split text into chips when committing.
 */
export type ChipsSeparator =
   | string
   | RegExp
   | (string | RegExp)[];

/**
 * Placement of chips relative to the entry control.
 *
 * - "inline" → inside the same visual box (Input) or in the textarea toolbox.
 * - "below"  → chips rendered as a block underneath the field.
 */
export type ChipsPlacement = "inline" | "below";

/**
 * Actions reported via ChangeDetail.meta.
 */
export type ChipsChangeAction = "add" | "remove" | "clear";

/**
 * Extra metadata sent with onValue() via ChangeDetail.
 */
export interface ChipsChangeMeta {
   action: ChipsChangeAction;
   added?: string[];
   removed?: string[];
   chips: string[];
}

/**
 * Chips-only props, on top of the injected ones.
 */
export interface ChipsVariantProps {
   /**
    * Placeholder shown when there are no chips and input is empty.
    */
   placeholder?: string;

   /**
    * Separators used to split raw input into chips.
    *
    * - string  → split on that string
    * - RegExp  → split with regex
    * - array   → try each in order
    *
    * Default: [",", ";"]
    */
   separators?: ChipsSeparator;

   /**
    * When true, pressing Enter commits the current input as chips.
    * Default: true
    */
   addOnEnter?: boolean;

   /**
    * When true, pressing Tab commits the current input as chips.
    * Default: true
    */
   addOnTab?: boolean;

   /**
    * When true, blurring the field commits any remaining input as chips.
    * Default: true
    */
   addOnBlur?: boolean;

   /**
    * When false, duplicate chips are ignored.
    * Default: false
    */
   allowDuplicates?: boolean;

   /**
    * Maximum number of chips allowed.
    * Undefined → unlimited.
    */
   maxChips?: number;

   /**
    * When true, Backspace on empty input removes the last chip.
    * Default: true
    */
   backspaceRemovesLast?: boolean;

   /**
    * Show a small clear-all button.
    * Default: false
    */
   clearable?: boolean;

   /**
    * Called when chips are added.
    */
   onAddChips?(added: string[], next: string[]): void;

   /**
    * Called when chips are removed.
    */
   onRemoveChips?(removed: string[], next: string[]): void;

   /**
    * Optional custom chip renderer.
    *
    * If provided, you are responsible for calling onRemove(index)
    * from your UI when you want to remove a chip.
    */
   renderChip?(
      chip: string,
      index: number,
      ctx: {
         remove(): void;
         chips: string[];
      },
   ): React.ReactNode;

   /**
    * Optional custom overflow chip renderer.
    *
    * Receives the hidden count and the full chip list.
    */
   renderOverflowChip?(
      hiddenCount: number,
      chips: string[],
   ): React.ReactNode;

   /**
    * Max number of chips to *render*.
    * Extra chips are summarized as "+N more".
    */
   maxVisibleChips?: number;

   /**
    * Max number of characters to *display* per chip.
    * The underlying value is not truncated.
    */
   maxChipChars?: number;

   /**
    * CSS max-width for chip labels (e.g. 160 or "12rem").
    */
   maxChipWidth?: number | string;

   /**
    * When true, the entry control is a Textarea instead of Input.
    * Good for comment-style chip entry.
    */
   textareaMode?: boolean;

   /**
    * Where chips are rendered relative to the entry.
    *
    * Default:
    * - Input mode → "inline"
    * - Textarea mode → "inline"
    */
   placement?: ChipsPlacement;

   // UI hooks
   className?: string;              // outer wrapper
   chipsClassName?: string;         // <div> that holds all chips
   chipClassName?: string;          // each chip container
   chipLabelClassName?: string;     // inner label span
   chipRemoveClassName?: string;    // remove "x" button/span
   inputClassName?: string;         // entry text input / textarea overrides
}

/**
 * We still type against ShadcnTextVariantProps so chips can reuse
 * size/density/icon props etc. We take control of:
 * - type / value / onValue
 * - leadingControl / trailingControl
 */
type TextUiProps = Omit<
   ShadcnTextVariantProps,
   | "type"
   | "inputMode"
   | "leadingControl"
   | "trailingControl"
   | "value"
   | "onValue"
>;

/**
 * Full props for the Shadcn-based chips variant.
 */
export type ShadcnChipsVariantProps = TextUiProps &
   ChipsVariantProps &
   Pick<BaseProps, "value" | "onValue" | "error">;

// ─────────────────────────────────────────────
// Helpers
// ─────────────────────────────────────────────

function normalizeSeparators(sep?: ChipsSeparator): (string | RegExp)[] {
   if (!sep) return [",", ";"];
   if (Array.isArray(sep)) return sep;
   return [sep];
}

function splitIntoTokens(raw: string, sep?: ChipsSeparator): string[] {
   const separators = normalizeSeparators(sep);
   let acc: string[] = [raw];

   for (const s of separators) {
      const next: string[] = [];
      for (const chunk of acc) {
         if (!chunk) continue;
         if (typeof s === "string") {
            next.push(...chunk.split(s));
         } else {
            next.push(...chunk.split(s));
         }
      }
      acc = next;
   }

   return acc
      .map((t) => t.trim())
      .filter((t) => t.length > 0);
}

// ─────────────────────────────────────────────
// Component
// ─────────────────────────────────────────────

export const ShadcnChipsVariant = React.forwardRef<
   HTMLInputElement | HTMLTextAreaElement,
   ShadcnChipsVariantProps
>(function ShadcnChipsVariant(props, ref) {
   const {
      // variant base bits
      value,
      onValue,
      error,

      // chips behaviour
      placeholder,
      separators,
      addOnEnter = true,
      addOnTab = true,
      addOnBlur = true,
      allowDuplicates = false,
      maxChips,
      backspaceRemovesLast = true,
      clearable = false,
      onAddChips,
      onRemoveChips,
      renderChip,
      renderOverflowChip,
      maxVisibleChips,
      maxChipChars,
      maxChipWidth,
      textareaMode = false,
      placement,

      // UI classNames
      className,
      chipsClassName,
      chipClassName,
      chipLabelClassName,
      chipRemoveClassName,
      inputClassName,

      // rest of text UI bits (size, density, icons, etc.)
      ...restTextProps
   } = props;

   const chips = React.useMemo(() => value ?? [], [value]);
   const hasChips = chips.length > 0;

   const [inputText, setInputText] = React.useState("");

   // ─────────────────────────────────────────────
   // Value emit
   // ─────────────────────────────────────────────

   const emitChange = React.useCallback(
      (
         nextChips: string[],
         meta: Omit<ChipsChangeMeta, "chips">,
      ) => {
         const detail: ChangeDetail<ChipsChangeMeta> = {
            source: "variant",
            raw: nextChips,
            nativeEvent: undefined,
            meta: {
               ...meta,
               chips: nextChips,
            },
         };
         onValue?.(nextChips.length ? nextChips : undefined, detail);
      },
      [onValue],
   );

   const commitFromRaw = React.useCallback(
      (raw: string) => {
         const tokens = splitIntoTokens(raw, separators);
         if (!tokens.length) return;

         let next = [...chips];
         const added: string[] = [];

         for (const token of tokens) {
            if (!allowDuplicates && next.includes(token)) continue;
            if (typeof maxChips === "number" && next.length >= maxChips) {
               break;
            }
            next.push(token);
            added.push(token);
         }

         if (!added.length) return;

         emitChange(next, { action: "add", added });
         onAddChips?.(added, next);
         setInputText("");
      },
      [chips, separators, allowDuplicates, maxChips, emitChange, onAddChips],
   );

   const handleRemoveAt = React.useCallback(
      (index: number) => {
         if (index < 0 || index >= chips.length) return;
         const removed = [chips[index]];
         const next = chips.filter((_, i) => i !== index);

         emitChange(next, { action: "remove", removed });
         onRemoveChips?.(removed, next);
      },
      [chips, emitChange, onRemoveChips],
   );

   const handleClear = React.useCallback(
      (ev?: React.MouseEvent) => {
         ev?.preventDefault();
         ev?.stopPropagation();
         if (!chips.length) return;
         emitChange([], { action: "clear", removed: [...chips] });
         onRemoveChips?.([...chips], []);
         setInputText("");
      },
      [chips, emitChange, onRemoveChips],
   );

   // ─────────────────────────────────────────────
   // Entry events (Input or Textarea)
   // ─────────────────────────────────────────────

   const handleEntryChange = React.useCallback(
      (
         event:
            | React.ChangeEvent<HTMLInputElement>
            | React.ChangeEvent<HTMLTextAreaElement>,
      ) => {
         const next = event.target.value ?? "";
         setInputText(next);
      },
      [],
   );

   const handleEntryKeyDown = React.useCallback(
      (
         event:
            | React.KeyboardEvent<HTMLInputElement>
            | React.KeyboardEvent<HTMLTextAreaElement>,
      ) => {
         const key = event.key;

         if (key === "Enter" && addOnEnter) {
            event.preventDefault();
            if (inputText.trim().length) {
               commitFromRaw(inputText);
            }
            return;
         }

         if (key === "Tab" && addOnTab && inputText.trim().length) {
            event.preventDefault();
            commitFromRaw(inputText);
            return;
         }

         // Backspace on empty input → remove last chip
         if (
            key === "Backspace" &&
            backspaceRemovesLast &&
            !inputText.length &&
            chips.length
         ) {
            event.preventDefault();
            handleRemoveAt(chips.length - 1);
            return;
         }
      },
      [
         inputText,
         addOnEnter,
         addOnTab,
         backspaceRemovesLast,
         chips.length,
         commitFromRaw,
         handleRemoveAt,
      ],
   );

   const handleEntryBlur = React.useCallback(
      (
         event:
            | React.FocusEvent<HTMLInputElement>
            | React.FocusEvent<HTMLTextAreaElement>,
      ) => {
         if (addOnBlur && inputText.trim().length) {
            commitFromRaw(inputText);
         }

         // Forward to host onBlur if provided in restTextProps
         const anyProps = restTextProps as any;
         const hostOnBlur = anyProps?.onBlur as
            | ((e: typeof event) => void)
            | undefined;
         hostOnBlur?.(event);
      },
      [addOnBlur, inputText, commitFromRaw, restTextProps],
   );

   const effectivePlaceholder =
      placeholder ?? (hasChips ? "" : "Add item…");

   // ─────────────────────────────────────────────
   // Chip rendering (maxVisible / overflow / truncation)
   // ─────────────────────────────────────────────

   let visibleChips = chips;
   let hiddenCount = 0;

   if (
      typeof maxVisibleChips === "number" &&
      maxVisibleChips > 0 &&
      chips.length > maxVisibleChips
   ) {
      visibleChips = chips.slice(0, maxVisibleChips);
      hiddenCount = chips.length - visibleChips.length;
   }

   const maxWidthStyle: React.CSSProperties | undefined =
      maxChipWidth !== undefined
         ? {
            maxWidth:
               typeof maxChipWidth === "number"
                  ? `${maxChipWidth}px`
                  : maxChipWidth,
         }
         : undefined;

   const baseChipClasses = textareaMode
      ? "inline-flex min-w-0 gap-1 items-center justify-between rounded-md bg-muted px-2 py-2 text-muted-foreground"
      : "inline-flex max-w-full items-center gap-1 rounded bg-muted px-2 py-0.5 text-muted-foreground hover:bg-muted/80";

   const baseRemoveClasses = textareaMode
      ? "cursor-pointer text-[16px] opacity-70 hover:opacity-100 mt-0.5"
      : "cursor-pointer text-[16px] opacity-70 hover:opacity-100";

   const chipNodes = visibleChips.map((chip, index) => {
      if (renderChip) {
         return (
            <React.Fragment key={`${chip}-${index}`}>
               {renderChip(chip, index, {
                  remove: () => handleRemoveAt(index),
                  chips,
               })}
            </React.Fragment>
         );
      }

      let label = chip;
      if (
         typeof maxChipChars === "number" &&
         maxChipChars > 0 &&
         label.length > maxChipChars
      ) {
         label = label.slice(0, maxChipChars) + "…";
      }

      return (
         <button
            key={`${chip}-${index}`}
            type="button"
            className={cn(baseChipClasses, chipClassName)}
            onClick={(e) => {
               e.preventDefault();
            }}
            data-slot="chip"
         >
            <span
               className={cn(
                  "truncate",
                  chipLabelClassName,
               )}
               style={maxWidthStyle}
            >
               {label}
            </span>
            <span
               className={cn(baseRemoveClasses, chipRemoveClassName)}
               onClick={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  handleRemoveAt(index);
               }}
               aria-hidden="true"
            >
               <X size={16} />
            </span>
         </button>
      );
   });

   if (hiddenCount > 0) {
      const defaultOverflow = (
         <span
            className={cn(
               baseChipClasses,
               "cursor-default",
               chipClassName,
            )}
            data-slot="chip-overflow"
         >
            +{hiddenCount} more
         </span>
      );

      const node =
         renderOverflowChip?.(hiddenCount, chips) ?? defaultOverflow;

      chipNodes.push(
         <React.Fragment key="__overflow">
            {node}
         </React.Fragment>,
      );
   }

   // ─────────────────────────────────────────────
   // Placement (inline vs below)
   // ─────────────────────────────────────────────

   const effectivePlacement: ChipsPlacement = textareaMode
      ? (placement ?? "inline")
      : (placement ?? "inline");

   const inlinePlacement = effectivePlacement === "inline";

   // Input-mode inline controls (inside the Input frame)
   let leadingControl: React.ReactNode | undefined;
   let trailingControl: React.ReactNode | undefined;

   // Below-the-field block (both modes)
   let chipsBelowBlock: React.ReactNode | undefined;

   // Textarea-mode upper toolbox (instead of leadingControl/trailingControl)
   let textareaUpperControl: React.ReactNode | undefined;
   let textareaUpperClassName: string | undefined;

   if (hasChips) {
      if (textareaMode) {
         if (inlinePlacement) {
            // chips live in the upper toolbox row, single-line row by default
            textareaUpperControl = (
               <div
                  data-slot="chips-upper"
                  className={cn(
                     "flex items-center gap-1 text-xs",
                     chipsClassName,
                  )}
               >
                  {chipNodes}
                  {clearable && (
                     <button
                        type="button"
                        onClick={handleClear}
                        className="ml-auto inline-flex h-6 px-2 items-center justify-center rounded-full text-[0.72rem] text-muted-foreground hover:bg-muted hover:text-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-1"
                        data-slot="chips-clear"
                     >
                        Clear
                     </button>
                  )}
               </div>
            );
            textareaUpperClassName = chipsClassName;
         } else {
            // textareaMode + placement=below → block under the textarea box
            chipsBelowBlock = (
               <div
                  className={cn(
                     "mt-2 flex items-center gap-2 text-xs",
                     chipsClassName,
                  )}
                  data-slot="chips-list-below"
               >
                  {chipNodes}
                  {clearable && (
                     <button
                        type="button"
                        onClick={handleClear}
                        className="self-start inline-flex h-6 px-2 items-center justify-center rounded-full text-[0.72rem] text-muted-foreground hover:bg-muted hover:text-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-1"
                        data-slot="chips-clear"
                     >
                        Clear
                     </button>
                  )}
               </div>
            );
         }
      } else {
         // INPUT MODE
         if (inlinePlacement) {
            leadingControl = (
               <div
                  className={cn(
                     "flex min-w-0 flex-row items-center gap-1 pr-1 py-1 text-xs pl-2",
                     chipsClassName,
                  )}
                  data-slot="chips-list"
               >
                  {chipNodes}
               </div>
            );

            if (clearable) {
               trailingControl = (
                  <div
                     className="flex h-full items-center pr-1"
                     data-slot="chips-trailing"
                  >
                     <button
                        type="button"
                        onClick={handleClear}
                        className="inline-flex h-6 w-6 items-center justify-center rounded-full text-xs text-muted-foreground hover:bg-muted hover:text-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-1"
                        data-slot="chips-clear"
                        aria-label="Clear chips"
                     >
                        ×
                     </button>
                  </div>
               );
            }
         } else {
            chipsBelowBlock = (
               <div
                  className={cn(
                     "mt-1 flex flex-row items-center gap-1 text-xs",
                     chipsClassName,
                  )}
                  data-slot="chips-list-below"
               >
                  {chipNodes}
                  {clearable && (
                     <button
                        type="button"
                        onClick={handleClear}
                        className="inline-flex h-6 px-2 items-center justify-center rounded-full text-[0.72rem] text-muted-foreground hover:bg-muted hover:text-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-1"
                        data-slot="chips-clear"
                     >
                        Clear
                     </button>
                  )}
               </div>
            );
         }
      }
   }

   const joinControls = !textareaMode && inlinePlacement && hasChips;
   const extendBoxToControls = !textareaMode && inlinePlacement && hasChips;

   // ─────────────────────────────────────────────
   // Entry control (Input vs Textarea)
   // ─────────────────────────────────────────────

   return (
      <div className={className} data-slot="chips-field">
         {textareaMode ? (
            <>
               {/* @ts-ignore */}
               <Textarea
                  ref={ref as any}
                  {...restTextProps}
                  value={inputText}
                  onChange={handleEntryChange}
                  onKeyDown={handleEntryKeyDown as any}
                  onBlur={handleEntryBlur as any}
                  extendBoxToToolbox={effectivePlacement === "inline"}
                  placeholder={effectivePlaceholder}
                  // textarea-specific defaults
                  autoResize={true}
                  rows={1}
                  upperControl={textareaUpperControl}
                  upperControlClassName={textareaUpperClassName}
                  inputClassName={inputClassName}
                  aria-invalid={error ? "true" : undefined}
               />
               {!inlinePlacement && hasChips && chipsBelowBlock}
            </>
         ) : (
            <>
               <Input
                  ref={ref as any}
                  {...restTextProps}
                  type="text"
                  // The Input's value is the *draft* text, not the chips.
                  value={inputText}
                  onChange={handleEntryChange as any}
                  onKeyDown={handleEntryKeyDown as any}
                  onBlur={handleEntryBlur as any}
                  placeholder={effectivePlaceholder}
                  // ONLY pass controls when chips are inline
                  leadingControl={inlinePlacement ? leadingControl : undefined}
                  trailingControl={inlinePlacement ? trailingControl : undefined}
                  // Only flip into "group box" mode when there are chips inline
                  joinControls={joinControls}
                  extendBoxToControls={extendBoxToControls}
                  inputClassName={cn(
                     "min-w-[4ch] flex-1 py-0",
                     inlinePlacement &&
                     hasChips &&
                     "bg-transparent border-none shadow-none outline-none",
                     inputClassName,
                  )}
                  aria-invalid={error ? "true" : undefined}
               />
               {!inlinePlacement && hasChips && chipsBelowBlock}
            </>
         )}
      </div>
   );
});

ShadcnChipsVariant.displayName = "ShadcnChipsVariant";

export default ShadcnChipsVariant;
```

---
#### 3


` File: packages/form-palette/src/presets/shadcn-variants/color.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/color.tsx

import * as React from "react";

import type { VariantModule } from "@/schema/variant";
import type { VariantBaseProps, ChangeDetail } from "@/variants/shared";
import type { ShadcnTextVariantProps } from "@/presets/shadcn-variants/text";
import { Input } from "@/presets/ui/input";
import { cn } from "@/lib/utils";
import { Palette } from "lucide-react";

type BaseProps = VariantBaseProps<string | undefined>;

/**
 * Extra options specific to the color variant.
 */
export interface ColorSpecificProps {
   /**
    * If false, we hide the colour preview box.
    * Default: true
    */
   showPreview?: boolean;

   /**
    * If false, we hide the picker toggle control/icon.
    * Default: true
    */
   showPickerToggle?: boolean;

   /**
    * Size of the colour swatch in pixels.
    * Default: 18
    */
   previewSize?: number;

   /**
    * Optional className for the outer wrapper that hosts
    * the Input + hidden color input.
    */
   wrapperClassName?: string;

   /**
    * Optional className for the preview button itself (around the swatch).
    */
   previewButtonClassName?: string;

   /**
    * Optional className for the swatch box inside the preview button.
    */
   previewSwatchClassName?: string;

   /**
    * Optional className for the hidden `<input type="color">`.
    *
    * By default this input is visually hidden and only used
    * to invoke the browser/OS colour picker, but you can override
    * this class to make it visible and style it.
    */
   pickerInputClassName?: string;

   /**
    * Custom icon shown in the trailing control as the picker toggle.
    * If omitted, a tiny ▾ triangle is used.
    */
   pickerToggleIcon?: React.ReactNode;

   className?: string;
}

/**
 * We inherit the *visual/behavioural* props from ShadcnTextVariant,
 * but control value / onValue / type / inputMode / leadingControl / trailingControl ourselves.
 */
type TextUiProps = Omit<
   ShadcnTextVariantProps,
   "type" | "inputMode" | "leadingControl" | "trailingControl" | "value" | "onValue"
>;

/**
 * Full props for the color variant as seen by the form runtime.
 */
export type ShadcnColorVariantProps = TextUiProps &
   ColorSpecificProps &
   Pick<BaseProps, "value" | "onValue">;

function normalizeColorForPicker(value: string | undefined): string {
   // Very light sanity: accept #rgb or #rrggbb; otherwise fall back.
   if (typeof value === "string" && /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(value)) {
      return value;
   }
   return "#000000";
}

export const ShadcnColorVariant = React.forwardRef<
   HTMLInputElement,
   ShadcnColorVariantProps
>(function ShadcnColorVariant(props, ref) {
   const {
      // variant contract
      value,
      onValue,

      // colour-specific
      showPreview = true,
      showPickerToggle = true,
      previewSize = 18,
      wrapperClassName,
      previewButtonClassName,
      previewSwatchClassName,
      pickerInputClassName,
      pickerToggleIcon,

      // from text variant UI
      error,
      joinControls = true,
      extendBoxToControls = true,

      // everything else → Input (size, density, className, icons, etc.)
      ...restTextProps
   } = props;

   const [local, setLocal] = React.useState<string>(value ?? "");
   const [pickerOpen, setPickerOpen] = React.useState(false);

   React.useEffect(() => {
      setLocal(value ?? "");
   }, [value]);

   const pickerRef = React.useRef<HTMLInputElement | null>(null);

   const effectiveColor = normalizeColorForPicker(local || value);
   const showError = Boolean(error);

   const openSystemPicker = React.useCallback(() => {
      setPickerOpen(true);
      // Small timeout so state flushes before click; not strictly required but safe.
      window.setTimeout(() => {
         pickerRef.current?.click();
      }, 0);
   }, []);

   const handleTextChange = React.useCallback(
      (event: React.ChangeEvent<HTMLInputElement>) => {
         const next = event.target.value ?? "";
         setLocal(next);

         if (onValue) {
            const detail: ChangeDetail<{ source: "input" }> = {
               source: "variant",
               raw: next,
               nativeEvent: event,
               meta: { source: "input" },
            };
            onValue(next || undefined, detail);
         }
      },
      [onValue]
   );

   const handlePickerChange = React.useCallback(
      (event: React.ChangeEvent<HTMLInputElement>) => {
         const next = event.target.value ?? "";
         setLocal(next);

         if (onValue) {
            const detail: ChangeDetail<{ source: "picker" }> = {
               source: "variant",
               raw: next,
               nativeEvent: event,
               meta: { source: "picker" },
            };
            onValue(next || undefined, detail);
         }

         // Once the user picks a colour, the OS picker closes.
         setPickerOpen(false);
      },
      [onValue]
   );

   const handlePickerBlur = React.useCallback(() => {
      // If the user cancels the picker, blur fires and we can clear state.
      setPickerOpen(false);
   }, []);

   // ———————————————————————————————
   // Leading control: colour preview
   // ———————————————————————————————

   const leadingControl = showPreview ? (
      <button
         type="button"
         onClick={openSystemPicker}
         className={cn(
            "flex h-full items-center px-3 border-r border-border/50",
            "hover:bg-muted/50 transition-colors focus-visible:outline-none focus-visible:bg-muted/50",
            previewButtonClassName
         )}
         tabIndex={-1}
         aria-label="Open colour picker"
      >
         <span
            className={cn(
               "inline-flex rounded-sm shadow-sm ring-1 ring-inset ring-foreground/10",
               previewSwatchClassName
            )}
            style={{
               width: previewSize,
               height: previewSize,
               backgroundColor: effectiveColor,
            }}
         />
      </button>
   ) : undefined;

   // ———————————————————————————————
   // Trailing control: picker toggle icon
   // ———————————————————————————————

   const toggleNode =
      pickerToggleIcon !== undefined ? (
         pickerToggleIcon
      ) : (
         // Swapped the text caret for a Lucide Palette icon
         <Palette className="h-4 w-4 opacity-50" />
      );

   const trailingControl = showPickerToggle ? (
      <button
         type="button"
         onClick={openSystemPicker}
         className="flex h-full items-center px-3 text-muted-foreground hover:text-foreground transition-colors"
         tabIndex={-1}
         aria-label={pickerOpen ? "Close colour picker" : "Open colour picker"}
         data-open={pickerOpen ? "true" : "false"}
      >
         {toggleNode}
      </button>
   ) : undefined;

   // ———————————————————————————————
   // Render
   // ———————————————————————————————

   return (
      <div className={cn("relative group/color", wrapperClassName)}>
         <Input
            ref={ref}
            {...restTextProps}
            type="text"
            value={local}
            onChange={handleTextChange}
            leadingControl={leadingControl}
            trailingControl={trailingControl}
            joinControls={joinControls}
            extendBoxToControls={extendBoxToControls}
            aria-invalid={showError ? "true" : undefined}
            // Added mono font and uppercase for cleaner hex code display
            className={cn("font-mono uppercase", restTextProps.className)}
            maxLength={9}
         />

         {/* Native color input – used to show the real browser/OS picker.
                By default it's visually hidden; override pickerInputClassName
                if you ever want to show/style it directly. */}
         <input
            ref={pickerRef}
            type="color"
            // hidden
            className={cn(
               "absolute h-0 w-0 opacity-0 pointer-events-none",
               pickerInputClassName
            )}
            value={effectiveColor}
            onChange={handlePickerChange}
            onBlur={handlePickerBlur}
            tabIndex={-1}
            aria-hidden="true"
         />
      </div>
   );
});

ShadcnColorVariant.displayName = "ShadcnColorVariant";
```

---
#### 4


` File: packages/form-palette/src/presets/shadcn-variants/custom.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/custom.tsx

import * as React from "react";
import type { VariantBaseProps, ChangeDetail } from "@/variants/shared";

/**
 * Props for the generic "custom" variant.
 *
 * - The only special props we define are:
 *   - component: the React component to render
 *   - valueProp / changeProp / disabledProp / readOnlyProp / errorProp
 *   - idProp / nameProp / placeholderProp
 *   - mapValue / mapDetail (optional hooks)
 *
 * - All other props are treated as "component props" and forwarded
 *   directly to the underlying component.
 *
 * The underlying component is expected to:
 *   - accept the mapped `valueProp`
 *   - call the mapped `changeProp` with the next value (first argument)
 *   - optionally use disabled/readOnly/error/id/name/placeholder via the mapped names
 */
export interface ShadcnCustomVariantProps<TValue = unknown>
   extends VariantBaseProps<TValue> {
   /**
    * The actual React component to render.
    *
    * Example:
    *   component={MyToggle}
    */
   component: React.ComponentType<any>;

   /**
    * Prop name that carries the current value for the component.
    * Default: "value".
    */
   valueProp?: string;

   /**
    * Prop name for the change handler that the component will call.
    * Default: "onChange".
    *
    * The component is expected to call:
    *   props[changeProp](nextValue, ...otherArgs?)
    *
    * The first argument is taken as the new value.
    */
   changeProp?: string;

   /**
    * Prop name for disabled state.
    * Default: "disabled".
    */
   disabledProp?: string;

   /**
    * Prop name for read-only state.
    * Default: "readOnly".
    */
   readOnlyProp?: string;

   /**
    * Prop name for passing error to the component (if it cares).
    * If provided, we pass the `error` field as-is.
    * Example values: "error", "isInvalid", "status".
    */
   errorProp?: string;

   /**
    * Prop name for the id attribute.
    * Default: "id".
    */
   idProp?: string;

   /**
    * Prop name for the name attribute.
    * Default: "name".
    */
   nameProp?: string;

   /**
    * Prop name for the placeholder attribute.
    * Default: "placeholder".
    */
   placeholderProp?: string;

   /**
    * Optional transform for the raw next value before it hits the field.
    *
    * Receives the first argument that the component passes to the change
    * handler, plus the full argument list for flexibility.
    */
   mapValue?: (raw: any, ...args: any[]) => TValue;

   /**
    * Optional builder for ChangeDetail, given the raw next value.
    *
    * If omitted, a default { source: "variant", raw } detail is used.
    */
   mapDetail?: (raw: any, ...args: any[]) => ChangeDetail;

   /**
    * Any other props are assumed to belong to the custom component.
    */
   [key: string]: unknown;
}

export const ShadcnCustomVariant = React.forwardRef<
   any,
   ShadcnCustomVariantProps<any>
>(function ShadcnCustomVariant(props, ref) {
   const {
      // Variant base props we care about:
      value,
      onValue,
      error,
      disabled,
      readOnly,
      id,
      name,
      placeholder,

      // Mapping props:
      component: Component,
      valueProp = "value",
      changeProp = "onChange",
      disabledProp = "disabled",
      readOnlyProp = "readOnly",
      errorProp,
      idProp = "id",
      nameProp = "name",
      placeholderProp = "placeholder",

      mapValue,
      mapDetail,

      // Everything else goes straight to the component:
      ...rest
   } = props as ShadcnCustomVariantProps<any>;

   // If there is no component, bail out (dev-time safety).
   if (!Component) {
      if (process.env.NODE_ENV !== "production") {
         // eslint-disable-next-line no-console
         console.warn(
            "[form-palette] ShadcnCustomVariant: `component` prop is required.",
         );
      }
      return null;
   }

   const isDisabled = !!disabled;
   const isReadOnly = !!readOnly;

   /**
    * Bridge from the component's change callback to the variant contract.
    *
    * We assume the custom component calls the mapped change prop
    * with the **next value as its first argument**:
    *
    *   props[changeProp](nextValue, ...rest)
    */
   const handleChange = React.useCallback(
      (...args: any[]) => {
         if (!onValue) return;
         if (isDisabled || isReadOnly) return;

         const raw = args[0];

         const next = mapValue
            ? mapValue(raw, ...args)
            : (raw as any);

         const detail: ChangeDetail =
            mapDetail?.(raw, ...args) ?? {
               source: "variant",
               raw,
               nativeEvent: undefined,
               meta: undefined,
            };

         (onValue as any)(next, detail);
      },
      [onValue, isDisabled, isReadOnly, mapValue, mapDetail],
   );

   // Build the props for the custom component.
   const innerProps: Record<string, unknown> = {
      ...rest, // ← all non-special props from InputField go directly to the component
   };

   // Map value → component[valueProp]
   innerProps[valueProp] = value;

   // Map handler → component[changeProp]
   innerProps[changeProp] = handleChange;

   // Map disabled / readOnly
   if (disabledProp) {
      innerProps[disabledProp] = isDisabled;
   }
   if (readOnlyProp) {
      innerProps[readOnlyProp] = isReadOnly;
   }

   // Map error if a mapping key is provided
   if (errorProp && error !== undefined) {
      innerProps[errorProp] = error;
   }

   // Map id/name/placeholder if present
   if (id !== undefined && idProp) {
      innerProps[idProp] = id;
   }
   if (name !== undefined && nameProp) {
      innerProps[nameProp] = name;
   }
   if (placeholder !== undefined && placeholderProp) {
      innerProps[placeholderProp] = placeholder;
   }

   return <Component ref={ref} {...innerProps} />;
});

ShadcnCustomVariant.displayName = "ShadcnCustomVariant";

export default ShadcnCustomVariant;
```

---
#### 5


` File: packages/form-palette/src/presets/shadcn-variants/date.tsx`  [↑ Back to top](#index)

```tsx
import * as React from "react";
import { Calendar as CalendarIcon, X as XIcon } from "lucide-react";

import type { VariantBaseProps, ChangeDetail } from "@/variants/shared";
import type { ShadcnTextVariantProps } from "@/presets/shadcn-variants/text";
import { Input } from "@/presets/ui/input";
import { Popover, PopoverTrigger, PopoverContent } from "@/presets/ui/popover";
import { Calendar } from "@/presets/ui/calendar";
import { TimeDropdowns } from "../ui/time-dropdowns";

type DateMode = "single" | "range";

export interface DateRange {
   from?: Date;
   to?: Date;
}

type DateValue = Date | DateRange | undefined;

type BaseProps = VariantBaseProps<DateValue>;

// Calendar disabled type from your calendar wrapper
type DisabledDays = React.ComponentProps<typeof Calendar>["disabled"];

/**
 * Logical temporal "kind" for the field.
 *
 * This controls the default mask + formatting/parsing.
 *
 * - "date"      → yyyy-MM-dd (default)
 * - "datetime"  → yyyy-MM-dd HH:mm
 * - "time"      → HH:mm
 * - "hour"      → HH
 * - "monthYear" → MM/yyyy
 * - "year"      → yyyy
 */
export type DateKind =
   | "date"
   | "datetime"
   | "time"
   | "hour"
   | "monthYear"
   | "year"
   | (string & {});

/**
 * Public props for the date variant (legacy + mask extensions).
 */
export interface DateVariantProps {
   mode?: DateMode;
   placeholder?: React.ReactNode;

   clearable?: boolean;

   minDate?: Date;
   maxDate?: Date;
   disabledDays?: DisabledDays;

   /**
    * Pattern for single dates.
    *
    * Tokens:
    * - yyyy → full year
    * - MM   → month (01–12)
    * - dd   → day (01–31)
    * - HH   → hours (00–23)
    * - mm   → minutes (00–59)
    *
    * Default depends on `kind`:
    * - date      → "yyyy-MM-dd"
    * - datetime  → "yyyy-MM-dd HH:mm"
    * - time      → "HH:mm"
    * - hour      → "HH"
    * - monthYear → "MM/yyyy"
    * - year      → "yyyy"
    */
   formatSingle?: string;

   /**
    * String pattern or custom formatter for ranges.
    *
    * - string → same token rules as formatSingle, applied to both ends
    * - function → full control over display text
    */
   formatRange?:
   | string
   | ((range: DateRange | undefined) => string);

   /**
    * Separator when formatRange is a string pattern.
    * Default: " – "
    */
   rangeSeparator?: string;

   /**
    * When true, keep the calendar open after a selection.
    *
    * For range mode, the picker also stays open until both
    * `from` and `to` are chosen.
    */
   stayOpenOnSelect?: boolean;

   /**
    * Controlled open state for the popover.
    */
   open?: boolean;
   onOpenChange?(o: boolean): void;

   /**
    * Temporal kind (controls default mask + formatting/parsing).
    *
    * Default: "date".
    */
   kind?: DateKind;

   /**
    * Optional explicit input mask pattern for the text input.
    *
    * If omitted, a sensible default based on `kind` is used.
    *
    * Mask tokens follow the same rules as the underlying Input mask:
    *   9 = digit, a = letter, * = alphanumeric.
    */
   inputMask?: string;

   /**
    * Whether to render the calendar popover.
    *
    * Defaults:
    * - true  for `kind` = "date" | "datetime"
    * - false for time-only kinds ("time", "hour", "monthYear", "year")
    */
   showCalendar?: boolean;
}

/**
 * We still reuse the Shadcn text UI props (size, density, icons, etc.),
 * but we take over type/value/onValue and the controls.
 */
type TextUiProps = Omit<
   ShadcnTextVariantProps,
   | "type"
   | "inputMode"
   | "leadingControl"
   | "trailingControl"
   | "value"
   | "onValue"
>;

/**
 * Full props for the Shadcn-based date variant.
 */
export type ShadcnDateVariantProps = TextUiProps &
   DateVariantProps &
   Pick<BaseProps, "value" | "onValue" | "error">;

// ─────────────────────────────────────────────
// Helpers
// ─────────────────────────────────────────────

function isRange(value: DateValue): value is DateRange {
   return !!value && !(value instanceof Date);
}

function normalizeValueForMode(
   value: DateValue,
   mode: DateMode,
): { single: Date | undefined; range: DateRange | undefined } {
   if (mode === "single") {
      if (value instanceof Date) {
         return { single: value, range: undefined };
      }
      if (isRange(value)) {
         // prefer "from" when coming from a range
         return { single: value.from ?? value.to, range: undefined };
      }
      return { single: undefined, range: undefined };
   }

   // range mode
   if (isRange(value)) {
      return { single: undefined, range: value };
   }
   if (value instanceof Date) {
      return { single: undefined, range: { from: value } };
   }
   return { single: undefined, range: undefined };
}

function hasSelection(value: DateValue): boolean {
   if (!value) return false;
   if (value instanceof Date) return true;
   return !!value.from || !!value.to;
}

function isRangeComplete(range: DateRange | undefined): boolean {
   return !!(range && range.from && range.to);
}

function pad2(n: number): string {
   return n.toString().padStart(2, "0");
}

interface KindConfig {
   mask: string;
   singlePattern: string;
}

function resolveKindConfig(kind: DateKind | undefined): KindConfig {
   const k = (kind ?? "date") as DateKind;

   switch (k) {
      case "datetime":
         return {
            mask: "9999-99-99 99:99",
            singlePattern: "yyyy-MM-dd HH:mm",
         };
      case "time":
         return {
            mask: "99:99",
            singlePattern: "HH:mm",
         };
      case "hour":
         return {
            mask: "99",
            singlePattern: "HH",
         };
      case "monthYear":
         return {
            mask: "99/9999",
            singlePattern: "MM/yyyy",
         };
      case "year":
         return {
            mask: "9999",
            singlePattern: "yyyy",
         };
      case "date":
      default:
         return {
            mask: "9999-99-99",
            singlePattern: "yyyy-MM-dd",
         };
   }
}

function formatDateWithPattern(
   date: Date,
   pattern: string | undefined,
): string {
   const p = pattern ?? "yyyy-MM-dd";

   const yyyy = date.getFullYear().toString();
   const MM = pad2(date.getMonth() + 1);
   const dd = pad2(date.getDate());
   const HH = pad2(date.getHours());
   const mm = pad2(date.getMinutes());

   return p
      .replace(/yyyy/g, yyyy)
      .replace(/MM/g, MM)
      .replace(/dd/g, dd)
      .replace(/HH/g, HH)
      .replace(/mm/g, mm);
}

function formatDisplaySingle(
   date: Date | undefined,
   pattern?: string,
): string {
   if (!date) return "";
   return formatDateWithPattern(date, pattern);
}

function formatDisplayRange(
   range: DateRange | undefined,
   formatRange: DateVariantProps["formatRange"],
   singlePattern?: string,
   separator?: string,
): string {
   if (!range || (!range.from && !range.to)) return "";

   if (typeof formatRange === "function") {
      return formatRange(range);
   }

   const pattern = formatRange ?? singlePattern ?? "yyyy-MM-dd";
   const sep = separator ?? " – ";

   const fromStr = range.from
      ? formatDateWithPattern(range.from, pattern)
      : "";
   const toStr = range.to
      ? formatDateWithPattern(range.to, pattern)
      : "";

   if (!fromStr && !toStr) return "";
   if (!fromStr) return toStr;
   if (!toStr) return fromStr;

   return `${fromStr}${sep}${toStr}`;
}

/**
 * Parse a raw digit string (unmasked) into a Date based on `kind`.
 *
 * Returns null when the input is incomplete or invalid.
 */
function parseRawToDate(rawDigits: string, kind: DateKind): Date | null {
   const len = rawDigits.length;

   switch (kind) {
      case "datetime": {
         if (len < 12) return null;
         const year = Number(rawDigits.slice(0, 4));
         const month = Number(rawDigits.slice(4, 6));
         const day = Number(rawDigits.slice(6, 8));
         const hour = Number(rawDigits.slice(8, 10));
         const minute = Number(rawDigits.slice(10, 12));
         if (!year || month < 1 || month > 12 || day < 1 || day > 31) {
            return null;
         }
         if (hour < 0 || hour > 23 || minute < 0 || minute > 59) {
            return null;
         }
         return new Date(year, month - 1, day, hour, minute, 0, 0);
      }

      case "time": {
         if (len < 4) return null;
         const hour = Number(rawDigits.slice(0, 2));
         const minute = Number(rawDigits.slice(2, 4));
         if (hour < 0 || hour > 23 || minute < 0 || minute > 59) {
            return null;
         }
         const d = new Date();
         d.setSeconds(0, 0);
         d.setHours(hour, minute);
         return d;
      }

      case "hour": {
         if (len < 2) return null;
         const hour = Number(rawDigits.slice(0, 2));
         if (hour < 0 || hour > 23) return null;
         const d = new Date();
         d.setSeconds(0, 0);
         d.setHours(hour, 0);
         return d;
      }

      case "monthYear": {
         if (len < 6) return null;
         const month = Number(rawDigits.slice(0, 2));
         const year = Number(rawDigits.slice(2, 6));
         if (!year || month < 1 || month > 12) {
            return null;
         }
         return new Date(year, month - 1, 1, 0, 0, 0, 0);
      }

      case "year": {
         if (len < 4) return null;
         const year = Number(rawDigits.slice(0, 4));
         if (!year) return null;
         return new Date(year, 0, 1, 0, 0, 0, 0);
      }

      case "date":
      default: {
         if (len < 8) return null;
         const year = Number(rawDigits.slice(0, 4));
         const month = Number(rawDigits.slice(4, 6));
         const day = Number(rawDigits.slice(6, 8));
         if (!year || month < 1 || month > 12 || day < 1 || day > 31) {
            return null;
         }
         return new Date(year, month - 1, day, 0, 0, 0, 0);
      }
   }
}

function meterSafeDigits(masked: string): string {
   return masked.replace(/\D+/g, "");
}

// ─────────────────────────────────────────────
// Component
// ─────────────────────────────────────────────

export const ShadcnDateVariant = React.forwardRef<
   HTMLInputElement,
   ShadcnDateVariantProps
>(function ShadcnDateVariant(props, ref) {
   const {
      // variant base bits
      value,
      onValue,
      error,

      // date props
      mode: modeProp = "single",
      placeholder,
      clearable = true,
      minDate,
      maxDate,
      disabledDays,
      formatSingle: formatSingleProp,
      formatRange,
      rangeSeparator,
      stayOpenOnSelect,
      open,
      onOpenChange,

      kind: kindProp = "date",
      inputMask,
      showCalendar: showCalendarProp,

      //@ts-ignore text UI bits (size, density, className, icons, etc.)
      className,
      ...restTextProps
   } = props;

   const mode: DateMode = modeProp ?? "single";
   const kind: DateKind = kindProp ?? "date";

   const kindConfig = resolveKindConfig(kind);
   const singlePattern = formatSingleProp ?? kindConfig.singlePattern;
   const resolvedMask = inputMask ?? kindConfig.mask;

   const defaultShowCalendar =
      kind === "date" || kind === "datetime";
   const showCalendar =
      typeof showCalendarProp === "boolean"
         ? showCalendarProp
         : defaultShowCalendar;

   const [internalOpen, setInternalOpen] = React.useState(false);
   const isControlledOpen = open !== undefined;
   const currentOpen = isControlledOpen ? !!open : internalOpen;

   const handleOpenChange = React.useCallback(
      (next: boolean) => {
         if (!isControlledOpen) {
            setInternalOpen(next);
         }
         onOpenChange?.(next);
      },
      [isControlledOpen, onOpenChange],
   );

   const { single, range } = normalizeValueForMode(value, mode);

   const displayValue = React.useMemo(() => {
      if (mode === "single") {
         return formatDisplaySingle(single, singlePattern);
      }
      return formatDisplayRange(
         range,
         formatRange,
         singlePattern,
         rangeSeparator,
      );
   }, [mode, single, range, singlePattern, formatRange, rangeSeparator]);

   const [localText, setLocalText] = React.useState<string>(displayValue);

   // Sync local text with external value / formatting
   React.useEffect(() => {
      setLocalText(displayValue);
   }, [displayValue]);

   // Time dropdown visibility:
   // - Only for mode="single"
   // - For datetime/time/hour kinds
   const showTimeDropdowns =
      mode === "single" &&
      (kind === "datetime" || kind === "time" || kind === "hour");

   const handleSelect = React.useCallback(
      (next: Date | DateRange | undefined) => {
         let nextValue: DateValue;
         let nextRange: DateRange | undefined;

         if (mode === "single") {
            if (next instanceof Date) {
               let selected = next;

               // For datetime, preserve previously chosen time (if any)
               if (kind === "datetime" && single) {
                  selected = new Date(
                     selected.getFullYear(),
                     selected.getMonth(),
                     selected.getDate(),
                     single.getHours(),
                     single.getMinutes(),
                     single.getSeconds(),
                     0,
                  );
               }

               nextValue = selected;
            } else {
               nextValue = undefined;
            }
            nextRange = undefined;
         } else {
            if (next && next instanceof Date) {
               nextRange = { from: next };
            } else {
               nextRange = (next as DateRange | undefined) ?? undefined;
            }
            nextValue = nextRange;
         }

         const rangeComplete =
            mode === "range" ? isRangeComplete(nextRange) : !!nextValue;

         const detail: ChangeDetail<{
            mode: DateMode;
            from: "calendar";
            rangeComplete: boolean;
         }> = {
            source: "variant",
            raw: nextValue,
            nativeEvent: undefined,
            meta: {
               mode,
               from: "calendar",
               rangeComplete,
            },
         };

         onValue?.(nextValue, detail);

         const shouldStayOpen =
            stayOpenOnSelect ||
            (mode === "range" && !rangeComplete);

         if (!shouldStayOpen) {
            handleOpenChange(false);
         }
      },
      [mode, stayOpenOnSelect, onValue, handleOpenChange, kind, single],
   );

   const handleTimeChange = React.useCallback(
      (next: Date | undefined) => {
         if (!next) {
            const detail: ChangeDetail<{
               mode: DateMode;
               kind: DateKind;
               from: "time";
               cleared: boolean;
            }> = {
               source: "variant",
               raw: undefined,
               nativeEvent: undefined,
               meta: {
                  mode,
                  kind,
                  from: "time",
                  cleared: true,
               },
            };
            onValue?.(undefined, detail);
            return;
         }

         const detail: ChangeDetail<{
            mode: DateMode;
            kind: DateKind;
            from: "time";
         }> = {
            source: "variant",
            raw: next,
            nativeEvent: undefined,
            meta: {
               mode,
               kind,
               from: "time",
            },
         };

         onValue?.(next, detail);
      },
      [mode, kind, onValue],
   );

   const handleClear = React.useCallback(
      (ev: React.MouseEvent) => {
         ev.preventDefault();
         ev.stopPropagation();

         const detail: ChangeDetail<{
            mode: DateMode;
            cleared: boolean;
         }> = {
            source: "variant",
            raw: undefined,
            nativeEvent: ev as any,
            meta: {
               mode,
               cleared: true,
            },
         };
         onValue?.(undefined, detail);
      },
      [mode, onValue],
   );

   const hasValue = hasSelection(value);
   const placeholderText =
      typeof placeholder === "string"
         ? placeholder
         : mode === "range"
            ? "Select date range"
            : "Select date";

   /**
    * Manual text input (mask-driven) — only for `mode = "single"`.
    * Range editing via text gets very hairy, so we keep range as
    * a calendar-driven control for now.
    */
   const handleInputChange = React.useCallback(
      (event: any) => {
         if (mode !== "single") return;

         const masked = (event?.value ??
            event?.target?.value ??
            "") as string;

         setLocalText(masked);

         const digits = meterSafeDigits(masked);

         if (!digits.length) {
            const detail: ChangeDetail<{
               mode: DateMode;
               kind: DateKind;
               from: "text";
               cleared: boolean;
            }> = {
               source: "variant",
               raw: undefined,
               nativeEvent: event,
               meta: {
                  mode,
                  kind,
                  from: "text",
                  cleared: true,
               },
            };
            onValue?.(undefined, detail);
            return;
         }

         const parsed = parseRawToDate(digits, kind);
         if (!parsed) {
            // Incomplete or invalid — keep local text but don't
            // push a Date value yet.
            return;
         }

         // If min/max are set, enforce them here.
         if (minDate && parsed < minDate) return;
         if (maxDate && parsed > maxDate) return;

         const detail: ChangeDetail<{
            mode: DateMode;
            kind: DateKind;
            from: "text";
         }> = {
            source: "variant",
            raw: parsed,
            nativeEvent: event,
            meta: {
               mode,
               kind,
               from: "text",
            },
         };

         onValue?.(parsed, detail);
      },
      [mode, kind, minDate, maxDate, onValue],
   );

   const trailingControl = (
      <div
         className="flex h-full items-center gap-1 pr-1"
         data-slot="date-controls"
      >
         {clearable && hasValue && (
            <button
               type="button"
               onClick={handleClear}
               className="inline-flex h-6 w-6 items-center justify-center rounded-full text-xs text-muted-foreground hover:bg-muted hover:text-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-1"
               aria-label="Clear date"
               data-slot="date-clear"
            >
               <XIcon className="h-3 w-3" />
            </button>
         )}

         {showCalendar && (
            <button
               type="button"
               onClick={() => handleOpenChange(!currentOpen)}
               className="inline-flex h-6 w-6 items-center justify-center rounded-full text-xs text-muted-foreground hover:bg-muted hover:text-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-1"
               aria-label="Open calendar"
               data-slot="date-toggle"
            >
               <CalendarIcon className="h-4 w-4" />
            </button>
         )}
      </div>
   );

   const inputNode = (
      <Input
         ref={ref}
         {...restTextProps}
         type="text"
         value={localText}
         onChange={mode === "single" ? (handleInputChange as any) : undefined}
         readOnly={mode !== "single" && showCalendar}
         placeholder={placeholderText}
         trailingControl={trailingControl}
         aria-invalid={error ? "true" : undefined}
         // Mask only makes sense when we allow typing.
         mask={mode === "single" ? resolvedMask : undefined}
      />
   );

   // If calendar is disabled completely, just render the masked input.
   if (!showCalendar) {
      return (
         <div className={className} data-slot="date-field">
            {inputNode}
         </div>
      );
   }

   const showCalendarBody = kind !== "time" && kind !== "hour";

   // Calendar / time popover.
   return (
      <Popover open={currentOpen} onOpenChange={handleOpenChange}>
         <PopoverTrigger asChild>
            <div className={className} data-slot="date-field">
               {inputNode}
            </div>
         </PopoverTrigger>
         <PopoverContent
            align="start"
            className="w-auto p-0"
            data-slot="date-popover"
         >
            <div className="flex flex-col gap-2 p-2">
               {showCalendarBody && (
                  <Calendar
                     mode={mode}
                     //@ts-ignore date UI bits
                     selected={mode === "single" ? single : range}
                     onSelect={handleSelect as any}
                     disabled={disabledDays}
                     fromDate={minDate}
                     toDate={maxDate}
                     initialFocus
                  />
               )}

               {showTimeDropdowns && (
                  <TimeDropdowns
                     value={single ?? undefined}
                     onChange={handleTimeChange}
                     label={
                        kind === "datetime"
                           ? "Time"
                           : undefined
                     }
                     minuteStep={5}
                     showSeconds={false}
                     density="compact"
                  />
               )}
            </div>
         </PopoverContent>
      </Popover>
   );
});

ShadcnDateVariant.displayName = "ShadcnDateVariant";

export default ShadcnDateVariant;
```

---
#### 6


` File: packages/form-palette/src/presets/shadcn-variants/editor.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/editor.tsx

import * as React from "react";
import Editor from "@toast-ui/editor";
import "@toast-ui/editor/dist/toastui-editor.css";
import { cn } from "@/lib/utils";
import type { ChangeDetail, VariantBaseProps, } from "@/variants/shared";

/**
 * Host app MUST import Toast UI Editor CSS:
 *   import "@toast-ui/editor/dist/toastui-editor.css";
 */

export type ToastToolbarItem =
    | "heading"
    | "bold"
    | "italic"
    | "strike"
    | "hr"
    | "quote"
    | "ul"
    | "ol"
    | "task"
    | "indent"
    | "outdent"
    | "table"
    | "image"
    | "link"
    | "code"
    | "codeblock";

export type EditorFormat = "html" | "markdown";
export type EditorToolbar = "default" | "none" | ToastToolbarItem[][];

type TuiEditorInstance = {
    getHTML(): string;
    getMarkdown(): string;
    setHTML(html: string, cursorToEnd?: boolean): void;
    setMarkdown(markdown: string, cursorToEnd?: boolean): void;
    insertText(text: string): void;

    setHeight?(height: string): void;
    setPlaceholder?(placeholder: string): void;
    changeMode?(mode: "markdown" | "wysiwyg", withoutFocus?: boolean): void;
    changePreviewStyle?(style: "tab" | "vertical"): void;

    on(type: string, handler: (...args: any[]) => void): void;
    off(type: string): void;
    destroy(): void;
};

export interface ShadcnEditorVariantProps extends Pick<
    VariantBaseProps<string | undefined>,
    | "value"
    | "onValue"
    | "error"
    | "disabled"
    | "readOnly"
    | "required"
    | "size"
    | "density"
> {
    placeholder?: string;
    height?: string; // ex) "400px"
    previewStyle?: "vertical" | "tab";
    editType?: "wysiwyg" | "markdown";
    useCommandShortcut?: boolean;

    /** Which format to store in the form value */
    format?: EditorFormat;

    /**
     * Toolbar config:
     * - "default" uses Toast UI defaults
     * - "none" hides tools + mode switch
     * - array provides toolbarItems
     */
    toolbar?: EditorToolbar;

    /** If true, paste is intercepted and inserted as plain text only */
    pastePlainText?: boolean;

    className?: string;
}

export function ShadcnEditorVariant(props: ShadcnEditorVariantProps) {
    const {
        value,
        onValue,
        error,
        disabled,
        readOnly,
        required,
        size,
        density,
        className,

        placeholder = "",
        height = "400px",
        previewStyle = "vertical",
        editType = "wysiwyg",
        useCommandShortcut = true,
        format = "html",
        toolbar = "default",
        pastePlainText = false,
    } = props;

    const mountRef = React.useRef<HTMLDivElement>(null);
    const editorRef = React.useRef<TuiEditorInstance | null>(null);

    const formatRef = React.useRef<EditorFormat>(format);
    const onValueRef = React.useRef<typeof onValue>(onValue);

    const syncingRef = React.useRef(false);
    const loadedRef = React.useRef(false);

    formatRef.current = format;
    onValueRef.current = onValue;

    const effectiveReadOnly = Boolean(disabled || readOnly);

    const readContent = React.useCallback((ed: TuiEditorInstance): string => {
        return formatRef.current === "markdown"
            ? (ed.getMarkdown() ?? "")
            : (ed.getHTML() ?? "");
    }, []);

    const emit = React.useCallback((next: string) => {
        const detail: ChangeDetail<string> = { source: "user", raw: next };
        onValueRef.current?.(next, detail);
    }, []);

    const structuralKey = React.useMemo(() => {
        const hideModeSwitch = toolbar === "none" || pastePlainText;
        // toolbar array is serializable (strings)
        return JSON.stringify({ toolbar, useCommandShortcut, hideModeSwitch });
    }, [toolbar, useCommandShortcut, pastePlainText]);

    // Create / recreate editor when structural options change
    React.useEffect(() => {
        const el = mountRef.current;
        if (!el) return;

        // Clean existing instance first
        if (editorRef.current) {
            try {
                editorRef.current.off("change");
            } catch {}
            try {
                editorRef.current.off("load");
            } catch {}
            try {
                editorRef.current.destroy();
            } catch {}
            editorRef.current = null;
        }

        loadedRef.current = false;
        syncingRef.current = true;

        const hideModeSwitch = toolbar === "none" || pastePlainText;

        const options: any = {
            el,
            height,
            initialValue: value ?? "",
            previewStyle,
            initialEditType: editType,
            useCommandShortcut,
            usageStatistics: false,
            placeholder,
            hideModeSwitch,
            ...(toolbar === "none"
                ? { toolbarItems: [] }
                : Array.isArray(toolbar)
                  ? { toolbarItems: toolbar }
                  : {}),
            events: {
                load: () => {
                    loadedRef.current = true;
                    syncingRef.current = false;
                },
                change: () => {
                    const ed = editorRef.current;
                    if (!ed) return;
                    if (syncingRef.current) return;
                    emit(readContent(ed));
                },
            },
        };

        editorRef.current = new (Editor as any)(options) as TuiEditorInstance;

        // If load never fires for some reason, don’t permanently block changes
        Promise.resolve().then(() => {
            syncingRef.current = false;
        });

        return () => {
            const ed = editorRef.current;
            if (!ed) return;

            try {
                ed.off("change");
            } catch {}
            try {
                ed.off("load");
            } catch {}
            try {
                ed.destroy();
            } catch {}

            editorRef.current = null;
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [structuralKey]); // intentionally only structural props

    // Keep height/placeholder updated without recreating (when supported)
    React.useEffect(() => {
        const ed = editorRef.current;
        if (!ed) return;
        if (typeof ed.setHeight === "function") ed.setHeight(height);
    }, [height]);

    React.useEffect(() => {
        const ed = editorRef.current;
        if (!ed) return;
        if (typeof ed.setPlaceholder === "function")
            ed.setPlaceholder(placeholder);
    }, [placeholder]);

    // Update mode + preview style without recreating (when supported)
    React.useEffect(() => {
        const ed = editorRef.current;
        if (!ed) return;
        if (typeof ed.changeMode === "function") ed.changeMode(editType);
    }, [editType]);

    React.useEffect(() => {
        const ed = editorRef.current;
        if (!ed) return;
        if (typeof ed.changePreviewStyle === "function")
            ed.changePreviewStyle(previewStyle);
    }, [previewStyle]);

    // Sync external value → editor (avoid cursor-jank with equality checks)
    React.useEffect(() => {
        const ed = editorRef.current;
        if (!ed) return;

        const next = value ?? "";

        syncingRef.current = true;

        if (format === "markdown") {
            const cur = ed.getMarkdown?.() ?? "";
            if (cur !== next) ed.setMarkdown(next, false);
        } else {
            const cur = ed.getHTML?.() ?? "";
            if (cur !== next) ed.setHTML(next, false);
        }

        Promise.resolve().then(() => {
            syncingRef.current = false;
        });
    }, [value, format]);

    // Plain-text paste interception (optional)
    React.useEffect(() => {
        if (!pastePlainText) return;

        const host = mountRef.current;
        if (!host) return;

        const onPaste = (e: ClipboardEvent) => {
            e.preventDefault();
            const text = e.clipboardData?.getData("text/plain") ?? "";
            const ed = editorRef.current;
            if (text && ed) ed.insertText(text);
        };

        host.addEventListener("paste", onPaste);
        return () => host.removeEventListener("paste", onPaste);
    }, [pastePlainText]);

    return (
        <div
            data-size={size}
            data-density={density}
            className={cn(
                "rounded-md border border-input bg-background overflow-hidden",
                effectiveReadOnly && "opacity-60 pointer-events-none",
                className
            )}
            aria-invalid={error ? true : undefined}
            aria-required={required ? true : undefined}
        >
            <div ref={mountRef} />
        </div>
    );
}
```

---
#### 7


` File: packages/form-palette/src/presets/shadcn-variants/file.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/file.tsx

import * as React from "react";
import type { VariantBaseProps, ChangeDetail } from "@/variants/shared";
import { cn, toArray } from "@/lib/utils";
import { Checkbox } from "@/presets/ui/checkbox";
import { ScrollArea } from "@/presets/ui/scroll-area";
import { Button } from "@/presets/ui/button";
import { Popover, PopoverContent, PopoverTrigger } from "@/presets/ui/popover";
import { Badge } from "@/presets/ui/badge";
import {
    FileIcon,
    UploadCloud,
    Trash2,
    CheckCircle2,
    X,
    AlertCircle,
    Loader2,
    ChevronDown,
    Plus,
    FolderUp,
} from "lucide-react";
import { getPaletteUtil } from "@/lib/register-global";

// ─────────────────────────────────────────────
// Types
// ─────────────────────────────────────────────

type Size = "sm" | "md" | "lg";
type Density = "compact" | "comfortable" | "loose";

export type FileSourceKind = "native" | "path" | "url" | "custom";

export interface FileItem {
    id: string;
    kind: FileSourceKind;
    file?: File;
    path?: string;
    url?: string;
    name: string;
    size?: number;
    type?: string;
    status?: "idle" | "loading" | "done" | "failed";
    error?: string | null;
    meta?: any;
}

export type FileLike =
    | File
    | string
    | {
          id?: string;
          file?: File;
          path?: string;
          url?: string;
          name?: string;
          size?: number;
          type?: string;
          status?: FileItem["status"];
          error?: string | null;
          meta?: any;
          [key: string]: unknown;
      };

export type CustomFileLoaderResult = FileLike | FileLike[] | null | undefined;

export type CustomFileLoader = (ctx: {
    multiple: boolean;
    current: FileItem[];
    allowedTypes?: string[];
}) => Promise<CustomFileLoaderResult> | CustomFileLoaderResult;

// ─────────────────────────────────────────────
// Helpers
// ─────────────────────────────────────────────

function fileId() {
    return `file_${Math.random().toString(36).slice(2)}`;
}

function formatSizeDefault(size?: number): string {
    if (!size || size <= 0) return "—";
    const kb = size / 1024;
    if (kb < 1024) return `${kb.toFixed(1)} KB`;
    const mb = kb / 1024;
    return `${mb.toFixed(1)} MB`;
}

/** ✅ Exact trigger height contract (your spec) */
function triggerHeight(size?: Size) {
    switch (size) {
        case "sm":
            return "h-8 text-xs";
        case "lg":
            return "h-11 text-base";
        default:
            return "h-9 text-sm";
    }
}

/** Keep chips safely within the trigger height */
function chipHeight(size?: Size) {
    switch (size) {
        case "sm":
            return "h-5";
        case "lg":
            return "h-7";
        default:
            return "h-6";
    }
}

/** Folder button sizing that fits inside each trigger height */
function pickerBtnSize(size?: Size) {
    switch (size) {
        case "sm":
            return "h-6 w-6";
        case "lg":
            return "h-8 w-8";
        default:
            return "h-7 w-7";
    }
}


function normaliseFileLike(input: FileLike): FileItem {
    const asAny: any = input as any;
    const existingId = asAny.id as string | undefined;

    if (existingId && (asAny.file || asAny.path || asAny.url)) {
        return {
            id: existingId,
            kind: (asAny.kind as FileSourceKind) ?? "custom",
            file: asAny.file,
            path: asAny.path,
            url: asAny.url,
            name: asAny.name ?? asAny.file?.name ?? existingId,
            size: asAny.size ?? asAny.file?.size,
            type: asAny.type ?? asAny.file?.type,
            status: asAny.status ?? "idle",
            error: asAny.error ?? null,
            meta: asAny.meta,
        };
    }

    if (input instanceof File) {
        return {
            id: existingId ?? fileId(),
            kind: "native",
            file: input,
            name: input.name,
            size: input.size,
            type: input.type,
            status: "idle",
            error: null,
        };
    }

    if (typeof input === "string") {
        const isUrl = input.includes("://");
        const name = input.split(/[\\/]/).pop() ?? input;
        return {
            id: existingId ?? fileId(),
            kind: isUrl ? "url" : "path",
            [isUrl ? "url" : "path"]: input,
            name,
            status: "idle",
            error: null,
        } as FileItem;
    }

    return {
        id: existingId ?? fileId(),
        kind: "custom",
        name: (input as any).name ?? "Unknown File",
        status: "idle",
        ...input,
    } as FileItem;
}

function normaliseFromFiles(list: FileList | File[]): FileItem[] {
    const arr: File[] = Array.isArray(list) ? list : Array.from(list);
    return arr.map(normaliseFileLike);
}

function densityTokens(density?: Density) {
    switch (density) {
        case "compact":
            return {
                triggerPadX: "px-2",
                triggerGap: "gap-1.5",
                headerPad: "px-3 py-1.5",
                listPad: "p-1",
                rowPad: "px-2 py-1.5",
                footerPad: "p-1",
                dropPad: "px-5 py-6",
                dropGap: "gap-2",
                chipPad: "px-1",
                chipGap: "gap-1",
            };
        case "loose":
            return {
                triggerPadX: "px-4",
                triggerGap: "gap-3",
                headerPad: "px-4 py-2.5",
                listPad: "p-2",
                rowPad: "px-3 py-2.5",
                footerPad: "p-2",
                dropPad: "px-8 py-10",
                dropGap: "gap-4",
                chipPad: "px-2",
                chipGap: "gap-2",
            };
        default:
            return {
                triggerPadX: "px-3",
                triggerGap: "gap-2",
                headerPad: "px-3 py-2",
                listPad: "p-1",
                rowPad: "px-2 py-2",
                footerPad: "p-1",
                dropPad: "px-6 py-8",
                dropGap: "gap-3",
                chipPad: "px-1.5",
                chipGap: "gap-1.5",
            };
    }
}

function mergeHandlers<E>(
    a: ((e: E) => void) | undefined,
    b: ((e: E) => void) | undefined,
) {
    if (!a) return b;
    if (!b) return a;
    return (e: E) => {
        a(e);
        b(e);
    };
}

// ─────────────────────────────────────────────
// Props (with mode discriminator)
// ─────────────────────────────────────────────

type BadgeVariant = React.ComponentProps<typeof Badge>["variant"];

type FileVariantBaseProps = Pick<
    VariantBaseProps<FileItem[]>,
    "value" | "onValue" | "error" | "disabled" | "readOnly" | "size" | "density"
> & {
    multiple?: boolean;
    accept?: string | string[];
    maxFiles?: number;
    maxTotalSize?: number;

    showDropArea?: boolean;
    dropIcon?: React.ReactNode;
    dropTitle?: React.ReactNode;
    dropDescription?: React.ReactNode;
    custom?: boolean;
    asRaw?: boolean;
    renderDropArea?: (ctx: {
        openPicker: () => void;
        isDragging: boolean;
    }) => React.ReactNode;

    renderFileItem?: (ctx: {
        item: FileItem;
        index: number;
        selected: boolean;
        toggleSelected: () => void;
        remove: () => void;
    }) => React.ReactNode;

    showCheckboxes?: boolean;
    onFilesAdded?: (
        added: FileItem[],
        detail: ChangeDetail<{ from: "input" | "drop" | "custom-loader" }>,
    ) => void;

    customLoader?: CustomFileLoader;
    mergeMode?: "append" | "replace";

    formatFileName?: (item: FileItem) => React.ReactNode;
    formatFileSize?: (size?: number) => React.ReactNode;
    placeholder?: string;

    className?: string;
    dropAreaClassName?: string;
    listClassName?: string;
    triggerClassName?: string;
};

type FileDefaultModeProps = {
    mode?: "default";

    leadingIcons?: React.ReactNode[];
    trailingIcons?: React.ReactNode[];
    icon?: React.ReactNode;

    leadingControl?: React.ReactNode;
    trailingControl?: React.ReactNode;
    leadingControlClassName?: string;
    trailingControlClassName?: string;
    joinControls?: boolean;
    extendBoxToControls?: boolean;

    // not supported in default mode
    button?: never;
    children?: never;

    selectedBadge?: never;
    selectedBadgeHiddenWhenZero?: never;
    selectedBadgeVariant?: never;
    selectedBadgeClassName?: never;
    selectedBadgePlacement?: never;
};

type FileButtonTrigger =
    | React.ReactNode
    | ((ctx: {
          open: boolean;
          items: FileItem[];
          selectedCount: number;
          disabled: boolean;
      }) => React.ReactNode);

type FileButtonModeProps = {
    mode: "button";

    /** Used when mode="button". If provided, this is the trigger. If not, `children` is used. */
    button?: FileButtonTrigger;
    children?: FileButtonTrigger;

    /** Selected-count badge (mode="button" only) */
    selectedBadge?: boolean;
    selectedBadgeHiddenWhenZero?: boolean;
    selectedBadgeVariant?: BadgeVariant;
    selectedBadgeClassName?: string;
    selectedBadgePlacement?: "end" | "corner";

    // icons & controls NOT supported in button mode
    leadingIcons?: never;
    trailingIcons?: never;
    icon?: never;

    leadingControl?: never;
    trailingControl?: never;
    leadingControlClassName?: never;
    trailingControlClassName?: never;
    joinControls?: never;
    extendBoxToControls?: never;
};

export type ShadcnFileVariantProps = FileVariantBaseProps &
    (FileDefaultModeProps | FileButtonModeProps);

// ─────────────────────────────────────────────
// Sub-Components
// ─────────────────────────────────────────────

const FileThumbnail = ({ item }: { item: FileItem }) => {
    const [preview, setPreview] = React.useState<string | null>(null);

    React.useEffect(() => {
        const isImage =
            item.type?.startsWith("image/") ||
            item.name.match(/\.(jpg|jpeg|png|gif|webp)$/i);
        if (!isImage) return;

        if (item.file) {
            const url = URL.createObjectURL(item.file);
            setPreview(url);
            return () => URL.revokeObjectURL(url);
        }
        if (item.url || item.path) {
            setPreview(item.url || item.path || null);
        }
    }, [item]);

    return (
        <div className="relative flex h-8 w-8 shrink-0 items-center justify-center overflow-hidden rounded-sm border bg-muted/50">
            {preview ? (
                <img
                    src={preview}
                    alt=""
                    className="h-full w-full object-cover"
                />
            ) : (
                <FileIcon className="h-4 w-4 text-muted-foreground/50" />
            )}
        </div>
    );
};

// ─────────────────────────────────────────────
// Main Component
// ─────────────────────────────────────────────

export const ShadcnFileVariant = React.forwardRef<
    HTMLDivElement,
    ShadcnFileVariantProps
>(function ShadcnFileVariant(props, ref) {
    const {
        value,
        onValue,
        disabled,
        readOnly,
        error,
        size = "md",
        density = "comfortable",

        multiple = false,
        accept,
        maxFiles,
        maxTotalSize,

        showDropArea = false,
        dropIcon,
        dropTitle,
        dropDescription,
        renderDropArea,

        renderFileItem,
        showCheckboxes,
        onFilesAdded,
        customLoader,
        mergeMode = "append",

        formatFileName,
        formatFileSize = formatSizeDefault,
        placeholder = "Select file...",
        asRaw,
        className,
        custom,
        dropAreaClassName,
        listClassName,
        triggerClassName,

        // default-mode only
        leadingIcons,
        trailingIcons,
        icon,
        leadingControl,
        trailingControl,
        leadingControlClassName,
        trailingControlClassName,
        joinControls: joinControlsProp,
        extendBoxToControls: extendBoxToControlsProp,

        // button-mode only
        mode = "default",
        button,
        children,
        selectedBadge = true,
        selectedBadgeHiddenWhenZero = true,
        selectedBadgeVariant = "secondary",
        selectedBadgeClassName,
        selectedBadgePlacement = "corner",
    } = props as ShadcnFileVariantProps & Record<string, any>;

    const joinControls =
        mode === "default" ? (joinControlsProp ?? true) : false;
    const extendBoxToControls =
        mode === "default" ? (extendBoxToControlsProp ?? true) : false;

    // ─────────────────────────────────────────────
    // State
    // ─────────────────────────────────────────────
    const items = toArray(value) ?? [];
    const isDisabled = Boolean(disabled || readOnly);

    const [dragOver, setDragOver] = React.useState(false);
    const [selectedIds, setSelectedIds] = React.useState<Set<string>>(
        () => new Set(),
    );
    const [popoverOpen, setPopoverOpen] = React.useState(false);
    const fileInputRef = React.useRef<HTMLInputElement | null>(null);

    const den = densityTokens(density as Density);

    // Pre-calculations
    const heightCls = triggerHeight(size as Size);
    const chipHeightCls = chipHeight(size as Size);
    const pickerBtnCls = pickerBtnSize(size as Size);

    const resolvedLeadingIcons = (
        leadingIcons?.length ? leadingIcons : icon ? [icon] : []
    ) as React.ReactNode[];
    const resolvedTrailingIcons = (
        trailingIcons?.length ? trailingIcons : []
    ) as React.ReactNode[];
    const hasExternalControls = !!leadingControl || !!trailingControl;

    const COLLAPSE_LIMIT = 2;

    // ─────────────────────────────────────────────
    // Logic
    // ─────────────────────────────────────────────

    const emitChange = React.useCallback(
        (next: FileItem[], meta: any) => {
            onValue?.(next, {
                source: "variant",
                raw: next,
                nativeEvent: undefined,
                meta,
            });
        },
        [onValue],
    );

    const handleAddItems = React.useCallback(
        (incoming: FileItem[], from: "input" | "drop" | "custom-loader") => {
            if (isDisabled) return;

            let next = multiple ? [...items] : [];
            const added: FileItem[] = [];

            for (const item of incoming) {
                if (multiple && maxFiles && next.length >= maxFiles) break;

                const currentTotalSize = next.reduce(
                    (acc, i) => acc + (i.size || 0),
                    0,
                );
                if (
                    maxTotalSize &&
                    currentTotalSize + (item.size || 0) > maxTotalSize
                )
                    break;

                next.push(item);
                added.push(item);
            }

            if (added.length > 0) {
                onFilesAdded?.(added, {
                    source: "variant",
                    raw: added,
                    nativeEvent: undefined,
                    meta: { from },
                });
                emitChange(next, { action: "add", from, added });
            }
        },
        [
            emitChange,
            isDisabled,
            items,
            maxFiles,
            maxTotalSize,
            multiple,
            onFilesAdded,
        ],
    );

    const handleRemove = React.useCallback(
        (id: string) => {
            const next = items.filter((i) => i.id !== id);
            emitChange(next, { action: "remove", id });
            if (selectedIds.has(id)) {
                const nextSel = new Set(selectedIds);
                nextSel.delete(id);
                setSelectedIds(nextSel);
            }
        },
        [emitChange, items, selectedIds],
    );

    const handleBulkRemove = React.useCallback(() => {
        const next = items.filter((i) => !selectedIds.has(i.id));
        emitChange(next, {
            action: "bulk-remove",
            ids: Array.from(selectedIds),
        });
        setSelectedIds(new Set());
    }, [emitChange, items, selectedIds]);

    const openPicker = React.useCallback(async () => {
        if (isDisabled) return;

        let resolvedLoader =
            customLoader ?? (custom && getPaletteUtil("customLoader"));

        if (resolvedLoader) {
            try {
                const result = await resolvedLoader({
                    multiple,
                    current: items,
                    allowedTypes: toArray(accept),
                });
                if (!result) return;

                const normalized = toArray(result).map(normaliseFileLike);
                if (mergeMode === "replace" || !multiple) {
                    emitChange(normalized, {
                        action: "set",
                        from: "custom-loader",
                    });
                } else {
                    handleAddItems(normalized, "custom-loader");
                }
            } catch (err) {
                console.error("Custom loader failed", err);
            }
            return;
        }

        fileInputRef.current?.click();
    }, [
        customLoader,
        emitChange,
        handleAddItems,
        isDisabled,
        items,
        mergeMode,
        multiple,
    ]);

    const onDragOver = React.useCallback(
        (e: React.DragEvent) => {
            e.preventDefault();
            if (!isDisabled) setDragOver(true);
        },
        [isDisabled],
    );

    const onDrop = React.useCallback(
        (e: React.DragEvent) => {
            e.preventDefault();
            setDragOver(false);
            if (isDisabled || !e.dataTransfer.files?.length) return;
            const files = normaliseFromFiles(e.dataTransfer.files);
            handleAddItems(files, "drop");
        },
        [handleAddItems, isDisabled],
    );

    const onNativeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        if (e.target.files?.length) {
            handleAddItems(normaliseFromFiles(e.target.files), "input");
        }
        e.target.value = "";
    };

    // ─────────────────────────────────────────────
    // UI Pieces: Interactive File Chip
    // ─────────────────────────────────────────────

    const FileChip = React.useCallback(
        ({
            item,
            condensed = false,
        }: {
            item: FileItem;
            condensed?: boolean;
        }) => {
            const name = formatFileName ? formatFileName(item) : item.name;
            const [preview, setPreview] = React.useState<string | null>(null);
            const [isOpen, setIsOpen] = React.useState(false);

            React.useEffect(() => {
                const isImage =
                    item.type?.startsWith("image/") ||
                    item.name.match(/\.(jpg|jpeg|png|gif|webp)$/i);
                if (!isImage) {
                    setPreview(null);
                    return;
                }

                if (item.file) {
                    const url = URL.createObjectURL(item.file);
                    setPreview(url);
                    return () => URL.revokeObjectURL(url);
                }
                if (item.url || item.path) {
                    setPreview(item.url || item.path || null);
                }
            }, [item]);

            return (
                <Popover open={isOpen} onOpenChange={setIsOpen}>
                    <PopoverTrigger asChild>
                        <div
                            role="button"
                            tabIndex={0}
                            className={cn(
                                "flex items-center overflow-hidden rounded-sm border bg-muted/60 text-xs transition-colors hover:bg-muted focus-visible:ring-2 focus-visible:ring-ring focus-visible:outline-none cursor-pointer",
                                chipHeightCls,
                                den.chipPad,
                                den.chipGap,
                                condensed ? "max-w-30" : "max-w-50",
                            )}
                            onPointerDown={(e) => e.stopPropagation()}
                            onClick={(e) => {
                                e.stopPropagation();
                                setIsOpen(true);
                            }}
                            onKeyDown={(e) => {
                                if (e.key === "Enter" || e.key === " ") {
                                    e.stopPropagation();
                                    setIsOpen(true);
                                }
                            }}
                        >
                            <FileIcon className="h-3 w-3 text-muted-foreground shrink-0" />
                            <span className="truncate font-medium">{name}</span>

                            <button
                                type="button"
                                onPointerDown={(e) => e.stopPropagation()}
                                onClick={(e) => {
                                    e.stopPropagation();
                                    handleRemove(item.id);
                                }}
                                className="ml-auto flex h-4 w-4 shrink-0 items-center justify-center rounded-full text-muted-foreground/70 hover:bg-destructive/20 hover:text-destructive focus:outline-none"
                                aria-label="Remove file"
                            >
                                <X className="h-3 w-3" />
                            </button>
                        </div>
                    </PopoverTrigger>

                    <PopoverContent
                        className="w-64 p-0"
                        align="start"
                        side="bottom"
                    >
                        <div className="relative aspect-video w-full flex items-center justify-center bg-muted/30 border-b">
                            {preview ? (
                                <img
                                    src={preview}
                                    alt={item.name}
                                    className="h-full w-full object-contain"
                                />
                            ) : (
                                <div className="flex flex-col items-center gap-2 text-muted-foreground/50">
                                    <FileIcon className="h-10 w-10" />
                                    <span className="text-[10px] uppercase">
                                        No Preview
                                    </span>
                                </div>
                            )}
                        </div>

                        <div className="p-3">
                            <div
                                className="font-medium text-sm truncate"
                                title={item.name}
                            >
                                {name}
                            </div>
                            <div className="mt-1 flex items-center justify-between text-xs text-muted-foreground">
                                <span>{formatFileSize(item.size)}</span>
                                {item.type && (
                                    <span className="uppercase opacity-70">
                                        {item.type.split("/").pop()}
                                    </span>
                                )}
                            </div>
                        </div>
                    </PopoverContent>
                </Popover>
            );
        },
        [
            chipHeightCls,
            den.chipGap,
            den.chipPad,
            formatFileName,
            formatFileSize,
            handleRemove,
        ],
    );

    // ─────────────────────────────────────────────
    // Button-mode trigger (with badge)
    // ─────────────────────────────────────────────

    const selectedCount = items.length;

    const resolveButtonTriggerElement =
        React.useCallback((): React.ReactElement => {
            const ctx = {
                open: popoverOpen,
                items,
                selectedCount,
                disabled: isDisabled,
            };

            const rawNode =
                typeof button === "function"
                    ? button(ctx)
                    : (button ??
                      (typeof children === "function"
                          ? children(ctx)
                          : children));

            const shouldShowBadge =
                Boolean(selectedBadge) &&
                (!selectedBadgeHiddenWhenZero || selectedCount > 0);

            const badgeEl = shouldShowBadge ? (
                <Badge
                    variant={selectedBadgeVariant}
                    className={cn(
                        "text-[10px] h-5 px-1.5 leading-none",
                        selectedBadgePlacement === "corner" &&
                            "absolute -top-2 -right-2",
                        selectedBadgeClassName,
                    )}
                >
                    {selectedCount}
                </Badge>
            ) : null;

            // Note: Using broader typings and `as any` in cloneElement prop bags to avoid TS complaining
            // when enhancing arbitrary custom components that may not declare DOM event props.
            const injectBadgeIntoElement = (el: React.ReactElement<any>) => {
                if (!badgeEl) return el;

                const existingClass = (el.props as any).className as
                    | string
                    | undefined;
                const nextClass = cn(
                    existingClass,
                    selectedBadgePlacement === "corner" && "relative",
                );

                const child = (el.props as any).children;

                if (selectedBadgePlacement === "end") {
                    return React.cloneElement(el, {
                        className: nextClass,
                        children: (
                            <span className="inline-flex items-center gap-2">
                                <span className="min-w-0">{child}</span>
                                {badgeEl}
                            </span>
                        ),
                    } as any);
                }

                return React.cloneElement(el, {
                    className: nextClass,
                    children: (
                        <>
                            {child}
                            {badgeEl}
                        </>
                    ),
                } as any);
            };

            const withDnD = (el: React.ReactElement<any>) =>
                React.cloneElement(el, {
                    onDragOver: mergeHandlers(
                        (el.props as any).onDragOver,
                        onDragOver,
                    ),
                    onDragLeave: mergeHandlers(
                        (el.props as any).onDragLeave,
                        () => setDragOver(false),
                    ),
                    onDrop: mergeHandlers((el.props as any).onDrop, onDrop),
                } as any);

            if (React.isValidElement(rawNode)) {
                return withDnD(injectBadgeIntoElement(rawNode));
            }

            // fallback trigger (no input styles; just whatever you passed + optional badge)
            const fallback = (
                <button
                    type="button"
                    disabled={isDisabled}
                    className={cn(
                        triggerClassName,
                        selectedBadgePlacement === "corner" && "relative",
                    )}
                    onDragOver={onDragOver}
                    onDragLeave={() => setDragOver(false)}
                    onDrop={onDrop}
                >
                    {rawNode ?? <span>{placeholder}</span>}
                    {badgeEl}
                </button>
            );

            // end placement needs an inline flex wrapper (fallback only)
            if (badgeEl && selectedBadgePlacement === "end") {
                return (
                    <button
                        type="button"
                        disabled={isDisabled}
                        className={cn(triggerClassName)}
                        onDragOver={onDragOver}
                        onDragLeave={() => setDragOver(false)}
                        onDrop={onDrop}
                    >
                        <span className="inline-flex items-center gap-2">
                            <span className="min-w-0">
                                {rawNode ?? <span>{placeholder}</span>}
                            </span>
                            {badgeEl}
                        </span>
                    </button>
                );
            }

            return fallback;
        }, [
            button,
            children,
            isDisabled,
            items,
            onDragOver,
            onDrop,
            placeholder,
            popoverOpen,
            selectedBadge,
            selectedBadgeClassName,
            selectedBadgeHiddenWhenZero,
            selectedBadgePlacement,
            selectedBadgeVariant,
            selectedCount,
            triggerClassName,
        ]);

    // ─────────────────────────────────────────────
    // Trigger Region
    // ─────────────────────────────────────────────

    const TriggerRegion = React.useMemo(() => {
        // A) Drop Zone Mode (Big Box) - No Popover, the list is external
        if (showDropArea) {
            if (renderDropArea)
                return renderDropArea({ openPicker, isDragging: dragOver });

            return (
                <div
                    onClick={openPicker}
                    onDragOver={onDragOver}
                    onDragLeave={() => setDragOver(false)}
                    onDrop={onDrop}
                    className={cn(
                        "group relative flex cursor-pointer flex-col items-center justify-center rounded-lg border-2 border-dashed text-center transition-all duration-200",
                        den.dropPad,
                        den.dropGap,
                        dragOver
                            ? "border-primary bg-primary/5 ring-4 ring-primary/10"
                            : "border-muted-foreground/25 hover:bg-muted/30 hover:border-muted-foreground/50",
                        isDisabled && "cursor-not-allowed opacity-50",
                        error && "border-destructive/50 bg-destructive/5",
                        dropAreaClassName,
                    )}
                >
                    <div className="rounded-full bg-surfaces-input p-3 shadow-sm">
                        {dropIcon ?? (
                            <UploadCloud className="h-5 w-5 text-muted-foreground" />
                        )}
                    </div>
                    <div className="space-y-1">
                        <p className="text-sm font-medium text-foreground">
                            {dropTitle ?? "Click or drag to select"}
                        </p>
                        <p className="text-xs text-muted-foreground">
                            {dropDescription ??
                                (multiple ? "Select files" : "Select a file")}
                        </p>
                    </div>
                </div>
            );
        }

        // B) Select-like mode: uses Popover
        const hasItems = items.length > 0;
        const visibleItems = items.slice(0, COLLAPSE_LIMIT);
        const hiddenCount = items.length - COLLAPSE_LIMIT;
        const isOverflowing = hiddenCount > 0;
        const anySelected = selectedIds.size > 0 && showCheckboxes && multiple;

        const TriggerEl =
            mode === "button" ? (
                resolveButtonTriggerElement()
            ) : (
                <div
                    className={cn(
                        "relative flex w-full cursor-pointer items-center py-0 transition-all",
                        heightCls,
                        den.triggerPadX,
                        den.triggerGap,
                        (!joinControls || !hasExternalControls) &&
                            "rounded-md border border-input bg-surfaces-input ring-offset-background hover:bg-accent/5 focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2",
                        dragOver &&
                            (!joinControls || !hasExternalControls) &&
                            "border-primary ring-2 ring-primary/20",
                        isDisabled && "cursor-not-allowed opacity-50",
                        error &&
                            (!joinControls || !hasExternalControls) &&
                            "border-destructive text-destructive",
                        triggerClassName,
                    )}
                    onDragOver={onDragOver}
                    onDragLeave={() => setDragOver(false)}
                    onDrop={onDrop}
                >
                    {/* Leading Icons */}
                    {resolvedLeadingIcons.map((ico, i) => (
                        <span
                            key={i}
                            className="flex shrink-0 items-center justify-center text-muted-foreground"
                        >
                            {ico}
                        </span>
                    ))}

                    {/* Content: Chips or Placeholder */}
                    <div
                        className={cn(
                            "flex flex-1 items-center overflow-hidden",
                            den.triggerGap,
                        )}
                    >
                        {hasItems ? (
                            <>
                                {visibleItems.map((item) => (
                                    <FileChip
                                        key={item.id}
                                        item={item}
                                        condensed={multiple}
                                    />
                                ))}
                                {isOverflowing && (
                                    <span className="flex h-5 items-center justify-center rounded-sm bg-muted px-1.5 text-xs font-medium text-muted-foreground">
                                        +{hiddenCount}
                                    </span>
                                )}
                            </>
                        ) : (
                            <span className="truncate text-muted-foreground">
                                {placeholder}
                            </span>
                        )}
                    </div>

                    {/* Trailing Icons */}
                    {resolvedTrailingIcons.map((ico, i) => (
                        <span
                            key={i}
                            className="flex shrink-0 items-center justify-center text-muted-foreground"
                        >
                            {ico}
                        </span>
                    ))}

                    {/* Dedicated File Picker Button */}
                    <Button
                        type="button"
                        variant="ghost"
                        size="icon"
                        className={cn(
                            "shrink-0 text-muted-foreground hover:text-foreground",
                            pickerBtnCls,
                        )}
                        onPointerDown={(e) => e.stopPropagation()}
                        onClick={(e) => {
                            e.stopPropagation();
                            openPicker();
                        }}
                    >
                        <FolderUp className="h-4 w-4" />
                    </Button>

                    {/* Chevron (for Popover) */}
                    <ChevronDown
                        className={cn(
                            "h-4 w-4 shrink-0 text-muted-foreground opacity-50 transition-transform duration-200",
                            popoverOpen && "rotate-180",
                        )}
                    />
                </div>
            );

        return (
            <Popover open={popoverOpen} onOpenChange={setPopoverOpen}>
                <PopoverTrigger asChild>{TriggerEl}</PopoverTrigger>

                <PopoverContent
                    className="w-(--radix-popover-trigger-width) p-0"
                    align="start"
                >
                    <div className="flex flex-col">
                        {/* Header */}
                        <div
                            className={cn(
                                "flex items-center justify-between border-b text-xs font-medium text-muted-foreground",
                                den.headerPad,
                            )}
                        >
                            <span>
                                {anySelected
                                    ? `${selectedIds.size} selected`
                                    : `${items.length} files total`}
                            </span>

                            {anySelected ? (
                                <button
                                    type="button"
                                    className="text-destructive hover:underline"
                                    onClick={handleBulkRemove}
                                >
                                    Remove selected
                                </button>
                            ) : items.length > 0 ? (
                                <button
                                    type="button"
                                    className="text-muted-foreground hover:text-foreground"
                                    onClick={() =>
                                        emitChange([], { action: "clear" })
                                    }
                                >
                                    Clear all
                                </button>
                            ) : null}
                        </div>

                        {/* Scrollable List */}
                        <ScrollArea
                            className={cn(
                                "h-auto max-h-75 w-full",
                                den.listPad,
                            )}
                        >
                            <div className="flex flex-col gap-1">
                                {items.map((item) => {
                                    const selected = selectedIds.has(item.id);
                                    const toggle = () => {
                                        const next = new Set(selectedIds);
                                        if (next.has(item.id))
                                            next.delete(item.id);
                                        else next.add(item.id);
                                        setSelectedIds(next);
                                    };

                                    return (
                                        <div
                                            key={item.id}
                                            className={cn(
                                                "group flex items-center gap-3 rounded-md text-sm transition-colors hover:bg-muted/50",
                                                den.rowPad,
                                            )}
                                        >
                                            {showCheckboxes && multiple && (
                                                <Checkbox
                                                    checked={selected}
                                                    onCheckedChange={toggle}
                                                    className="h-4 w-4 shrink-0"
                                                />
                                            )}

                                            <FileThumbnail item={item} />

                                            <div className="min-w-0 flex-1">
                                                <div className="truncate font-medium">
                                                    {formatFileName?.(item) ??
                                                        item.name}
                                                </div>
                                                <div className="flex items-center gap-2 text-xs text-muted-foreground">
                                                    <span>
                                                        {formatFileSize(
                                                            item.size,
                                                        )}
                                                    </span>
                                                    {item.status ===
                                                        "failed" && (
                                                        <span className="text-destructive">
                                                            Failed
                                                        </span>
                                                    )}
                                                </div>
                                            </div>

                                            <Button
                                                variant="ghost"
                                                size="icon"
                                                className="h-7 w-7 opacity-0 group-hover:opacity-100"
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    handleRemove(item.id);
                                                }}
                                            >
                                                <Trash2 className="h-3.5 w-3.5 text-muted-foreground" />
                                            </Button>
                                        </div>
                                    );
                                })}

                                {items.length === 0 && (
                                    <div className="py-4 text-center text-xs text-muted-foreground">
                                        No files selected
                                    </div>
                                )}
                            </div>
                        </ScrollArea>

                        {/* Footer Add Button */}
                        <div className={cn("border-t", den.footerPad)}>
                            <Button
                                variant="secondary"
                                size="sm"
                                className="w-full justify-start text-xs"
                                onClick={() => {
                                    setPopoverOpen(false);
                                    openPicker();
                                }}
                            >
                                <Plus className="mr-2 h-3 w-3" />
                                {multiple
                                    ? "Add files..."
                                    : items.length
                                      ? "Replace file"
                                      : "Add file"}
                            </Button>
                        </div>
                    </div>
                </PopoverContent>
            </Popover>
        );
    }, [
        COLLAPSE_LIMIT,
        FileChip,
        den,
        dragOver,
        dropAreaClassName,
        dropDescription,
        dropIcon,
        dropTitle,
        emitChange,
        error,
        handleBulkRemove,
        handleRemove,
        heightCls,
        isDisabled,
        items,
        joinControls,
        mode,
        multiple,
        onDragOver,
        onDrop,
        openPicker,
        pickerBtnCls,
        placeholder,
        popoverOpen,
        renderDropArea,
        resolveButtonTriggerElement,
        resolvedLeadingIcons,
        resolvedTrailingIcons,
        selectedIds,
        showCheckboxes,
        showDropArea,
        hasExternalControls,
        triggerClassName,
        formatFileName,
        formatFileSize,
        setPopoverOpen,
    ]);

    // ─────────────────────────────────────────────
    // External List (Drop Zone Mode Only)
    // ─────────────────────────────────────────────

    const showExternalList = multiple && showDropArea && items.length > 0;
    const anySelectedExternal =
        selectedIds.size > 0 && showCheckboxes && multiple;

    const ExternalFileList = showExternalList ? (
        <>
            {(anySelectedExternal || items.length > 0) && (
                <div className="mt-2 flex items-center justify-between px-1 text-xs text-muted-foreground">
                    <span>{items.length} files</span>
                    <div className="flex gap-2">
                        {anySelectedExternal && (
                            <button
                                type="button"
                                onClick={handleBulkRemove}
                                className="text-destructive hover:underline"
                            >
                                Remove selected
                            </button>
                        )}
                        <button
                            type="button"
                            onClick={() => emitChange([], { action: "clear" })}
                            className="hover:text-foreground"
                        >
                            Clear all
                        </button>
                    </div>
                </div>
            )}

            <ScrollArea className={cn("mt-1 w-full", listClassName)}>
                <div className="flex flex-col gap-2">
                    {items.map((item, index) => {
                        const selected = selectedIds.has(item.id);
                        const toggle = () => {
                            const next = new Set(selectedIds);
                            if (next.has(item.id)) next.delete(item.id);
                            else next.add(item.id);
                            setSelectedIds(next);
                        };

                        if (renderFileItem) {
                            return renderFileItem({
                                item,
                                index,
                                selected,
                                toggleSelected: toggle,
                                remove: () => handleRemove(item.id),
                            });
                        }

                        return (
                            <div
                                key={item.id}
                                className={cn(
                                    "group relative flex items-center gap-3 rounded-lg border bg-card pr-3 transition-all hover:bg-muted/30",
                                    density === "compact"
                                        ? "p-2"
                                        : density === "loose"
                                          ? "p-3"
                                          : "p-2",
                                )}
                            >
                                {showCheckboxes && (
                                    <Checkbox
                                        checked={selected}
                                        onCheckedChange={toggle}
                                        className="ml-1"
                                    />
                                )}
                                <FileThumbnail item={item} />
                                <div className="min-w-0 flex-1 space-y-1">
                                    <div className="flex items-center justify-between gap-2">
                                        <span className="truncate text-sm font-medium text-foreground">
                                            {formatFileName?.(item) ??
                                                item.name}
                                        </span>
                                    </div>
                                    <div className="flex items-center gap-2 text-xs text-muted-foreground">
                                        <span>{formatFileSize(item.size)}</span>
                                        {item.status === "loading" && (
                                            <span className="flex items-center gap-1 text-primary">
                                                <Loader2 className="h-3 w-3 animate-spin" />
                                            </span>
                                        )}
                                        {item.status === "failed" && (
                                            <span className="flex items-center gap-1 text-destructive">
                                                <AlertCircle className="h-3 w-3" />
                                            </span>
                                        )}
                                        {item.status === "done" && (
                                            <CheckCircle2 className="h-3 w-3 text-emerald-500" />
                                        )}
                                    </div>
                                </div>
                                <button
                                    type="button"
                                    onClick={() => handleRemove(item.id)}
                                    className="flex h-8 w-8 shrink-0 items-center justify-center rounded-full text-muted-foreground/70 opacity-0 transition-all hover:bg-destructive/10 hover:text-destructive group-hover:opacity-100"
                                >
                                    <Trash2 className="h-4 w-4" />
                                </button>
                            </div>
                        );
                    })}
                </div>
            </ScrollArea>
        </>
    ) : null;

    // ─────────────────────────────────────────────
    // Render
    // ─────────────────────────────────────────────

    const joinedBox =
        mode === "default" &&
        joinControls &&
        extendBoxToControls &&
        !showDropArea;

    return (
        <div
            ref={ref}
            className={cn("w-full", className)}
            aria-disabled={isDisabled}
            aria-invalid={!!error}
        >
            <div
                className={cn(
                    "flex w-full",
                    joinedBox
                        ? "items-stretch rounded-md border border-input bg-surfaces-input shadow-xs ring-offset-background focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2"
                        : "items-start",
                    joinedBox &&
                        dragOver &&
                        "border-primary ring-2 ring-primary/20",
                    joinedBox && error && "border-destructive",
                )}
            >
                {mode === "default" && leadingControl && (
                    <div
                        className={cn(
                            "flex items-center",
                            joinControls &&
                                !showDropArea &&
                                "border-r bg-muted/50 px-3",
                            leadingControlClassName,
                        )}
                    >
                        {leadingControl}
                    </div>
                )}

                <div className="flex-1 min-w-0">{TriggerRegion}</div>

                {mode === "default" && trailingControl && (
                    <div
                        className={cn(
                            "flex items-center",
                            joinControls &&
                                !showDropArea &&
                                "border-l bg-muted/50 px-3",
                            trailingControlClassName,
                        )}
                    >
                        {trailingControl}
                    </div>
                )}
            </div>

            {ExternalFileList}

            <input
                ref={fileInputRef}
                type="file"
                className="hidden"
                multiple={multiple}
                accept={Array.isArray(accept) ? accept.join(",") : accept}
                onChange={onNativeChange}
            />
        </div>
    );
});

ShadcnFileVariant.displayName = "ShadcnFileVariant";
export default ShadcnFileVariant;
```

---
#### 8


` File: packages/form-palette/src/presets/shadcn-variants/json-editor/editor.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/json-editor/editor.tsx
// noinspection GrazieInspection

import * as React from "react";
import { cn } from "@/lib/utils";

import { Button } from "@/presets/ui/button";
import { Separator } from "@/presets/ui/separator";
import { ScrollArea } from "@/presets/ui/scroll-area";

import { Code2, Eye, SplitSquareVertical, Upload, X } from "lucide-react";

import type { ChangeDetail } from "@/variants/shared";

import type { JsonObject, JsonPath, JsonValue } from "@/lib/json-editor/utils";
import {
    buildJsonRoutes,
    lastSegment,
    splitPath,
} from "@/lib/json-editor/utils";

import type {
    JsonEditorCallbacks,
    JsonEditorDefaults,
    JsonEditorFieldMap,
    JsonEditorFilters,
    JsonEditorLayoutMap,
    JsonEditorPermissions,
    JsonEditorResolvedField,
    JsonEditorViewMode,
    JsonRouteNode,
} from "./types";

import JsonEditorMain from "./main";
import JsonEditorRawPanel from "./raw-panel";

/* ─────────────────────────────────────────────────────────────
 * Types
 * ───────────────────────────────────────────────────────────── */

export interface JsonEditorHeaderRenderCtx {
    title: React.ReactNode;
    viewControls: React.ReactNode;

    loadFile: () => void;
    setViewMode: (mode: JsonEditorViewMode) => void;
    close: () => void;
}

export interface JsonEditorHandle {
    loadFile: () => void;

    getRoute: () => JsonPath;
    setRoute: (route: JsonPath) => void;

    getViewMode: () => JsonEditorViewMode;
    setViewMode: (mode: JsonEditorViewMode) => void;
}

export interface JsonEditorEditorProps {
    root: JsonObject;
    onRoot: (nextRoot: JsonObject, detail?: ChangeDetail<any>) => void;

    // config
    fieldMap?: JsonEditorFieldMap;
    layout?: JsonEditorLayoutMap;
    defaults?: JsonEditorDefaults;
    filters?: JsonEditorFilters;
    permissions?: JsonEditorPermissions;
    callbacks?: JsonEditorCallbacks;

    // hooks
    renderField?: (ctx: {
        field: JsonEditorResolvedField;
        route: JsonPath;
    }) => React.ReactNode;
    renderRouteLabel?: (ctx: {
        node: JsonRouteNode;
        active: boolean;
    }) => React.ReactNode;

    // header
    title?: React.ReactNode;
    schema?: string; // validation identifier/selector (NOT a UI title)
    onClose?: () => void;
    showClose?: boolean;
    renderHeader?: (ctx: JsonEditorHeaderRenderCtx) => React.ReactNode;

    // routing (optional controlled)
    route?: JsonPath;
    defaultRoute?: JsonPath;
    onRouteChange?: (route: JsonPath) => void;

    // view mode (optional controlled)
    viewMode?: JsonEditorViewMode;
    defaultViewMode?: JsonEditorViewMode;
    onViewModeChange?: (mode: JsonEditorViewMode) => void;

    // styling
    className?: string;
    contentClassName?: string;
    rawClassName?: string;
}

/* ─────────────────────────────────────────────────────────────
 * Local utils (keep minimal)
 * ───────────────────────────────────────────────────────────── */

function isPlainObject(v: unknown): v is Record<string, any> {
    return typeof v === "object" && v !== null && !Array.isArray(v);
}

function prettifyLabel(key: string) {
    const spaced = key
        .replace(/_/g, " ")
        .replace(/([a-z0-9])([A-Z])/g, "$1 $2")
        .trim();
    return spaced ? spaced[0]!.toUpperCase() + spaced.slice(1) : key;
}

function parentOf(path: JsonPath): JsonPath {
    const segs = splitPath(path);
    if (segs.length <= 1) return "";
    return segs.slice(0, -1).join(".");
}

function collectAllPaths(
    value: JsonValue,
    prefix: JsonPath = "",
    out: JsonPath[] = [],
) {
    if (value === null) return out;

    if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            const p = prefix ? `${prefix}.${i}` : `${i}`;
            out.push(p);
            collectAllPaths(value[i] as JsonValue, p, out);
        }
        return out;
    }

    if (isPlainObject(value)) {
        for (const k of Object.keys(value)) {
            const p = prefix ? `${prefix}.${k}` : k;
            out.push(p);
            collectAllPaths((value as any)[k] as JsonValue, p, out);
        }
        return out;
    }

    return out;
}

function useControllable<T>(opts: {
    value?: T;
    defaultValue: T;
    onChange?: (v: T) => void;
}) {
    const { value, defaultValue, onChange } = opts;
    const [inner, setInner] = React.useState<T>(defaultValue);

    const isControlled = value !== undefined;
    const state = (isControlled ? value : inner) as T;

    const setState = React.useCallback(
        (next: T) => {
            if (!isControlled) setInner(next);
            onChange?.(next);
        },
        [isControlled, onChange],
    );

    React.useEffect(() => {
        if (!isControlled) return;
        setInner(value as T);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isControlled]);

    return [state, setState] as const;
}

function callCallbacks(
    callbacks: JsonEditorCallbacks | undefined,
    action: "edit" | "edit-raw",
    nextRoot: JsonObject,
    ctx: { route: JsonPath; path?: JsonPath },
) {
    if (!callbacks) return;

    const path = ctx.path ?? "";
    const key = path ? lastSegment(path) : "";
    const parent = path ? parentOf(path) : "";

    const meta = { action, route: ctx.route, path, parent, key } as const;

    // For now: everything funnels through onEdit
    callbacks.onEdit?.(nextRoot, meta as any);
}

/* ─────────────────────────────────────────────────────────────
 * Component
 * ───────────────────────────────────────────────────────────── */

export const JsonEditorEditor = React.forwardRef<
    JsonEditorHandle,
    JsonEditorEditorProps
>(function JsonEditorEditor(props, ref) {
    const {
        root,
        onRoot,

        fieldMap,
        layout,
        defaults,
        filters,
        permissions,
        callbacks,

        renderField,
        renderRouteLabel,

        title: headerTitle,
        schema,
        onClose,
        showClose,
        renderHeader,

        route: routeProp,
        defaultRoute,
        onRouteChange,

        viewMode: viewModeProp,
        defaultViewMode = "split",
        onViewModeChange,

        className,
        contentClassName,
        rawClassName,
    } = props;

    const canViewRaw = permissions?.canViewRaw ?? true;
    const canEditRaw = permissions?.canEditRaw ?? false;

    const routes = React.useMemo(
        () => buildJsonRoutes(root, undefined, filters),
        [root, filters],
    );

    const allPaths = React.useMemo(() => {
        const list = collectAllPaths(root as unknown as JsonValue, "", []);
        const seen = new Set<string>();
        return list.filter((p) => (seen.has(p) ? false : (seen.add(p), true)));
    }, [root]);

    const computedInitialRoute = React.useMemo(() => {
        const explicit = routeProp ?? defaultRoute;
        if (explicit !== undefined) return explicit;
        return routes[0]?.path ?? "";
    }, [routeProp, defaultRoute, routes]);

    const [route, setRoute] = useControllable<JsonPath>({
        value: routeProp,
        defaultValue: computedInitialRoute,
        onChange: onRouteChange,
    });

    const [viewMode, setViewMode] = useControllable<JsonEditorViewMode>({
        value: viewModeProp,
        defaultValue: defaultViewMode,
        onChange: onViewModeChange,
    });

    React.useEffect(() => {
        if (!canViewRaw && (viewMode === "raw" || viewMode === "split")) {
            setViewMode("visual");
        }
    }, [canViewRaw, setViewMode, viewMode]);

    const fileInputRef = React.useRef<HTMLInputElement | null>(null);

    /* ─────────────────────────────────────────────
     * Split view: resizable raw sidebar
     * ───────────────────────────────────────────── */

    const contentRef = React.useRef<HTMLDivElement | null>(null);

    const [rawWidth, setRawWidth] = React.useState<number>(420);
    const [isResizing, setIsResizing] = React.useState(false);

    const startXRef = React.useRef(0);
    const startWRef = React.useRef(0);

    const clampRawWidth = React.useCallback((w: number) => {
        const containerW =
            contentRef.current?.getBoundingClientRect().width ?? 0;

        const min = 260;
        const max = containerW
            ? Math.max(min, Math.min(900, containerW - 240))
            : 900;

        return Math.max(min, Math.min(max, w));
    }, []);

    const onResizePointerDown = React.useCallback(
        (e: React.PointerEvent<HTMLDivElement>) => {
            if (e.button !== 0 && e.pointerType === "mouse") return;

            setIsResizing(true);
            startXRef.current = e.clientX;
            startWRef.current = rawWidth;

            e.currentTarget.setPointerCapture(e.pointerId);
            e.preventDefault();
            e.stopPropagation();
        },
        [rawWidth],
    );

    const onResizePointerMove = React.useCallback(
        (e: React.PointerEvent<HTMLDivElement>) => {
            if (!isResizing) return;

            const dx = e.clientX - startXRef.current;
            setRawWidth(clampRawWidth(startWRef.current + dx));

            e.preventDefault();
        },
        [clampRawWidth, isResizing],
    );

    const stopResizing = React.useCallback(
        (e: React.PointerEvent<HTMLDivElement>) => {
            if (!isResizing) return;
            setIsResizing(false);

            try {
                e.currentTarget.releasePointerCapture(e.pointerId);
            } catch {
                // ignore
            }
        },
        [isResizing],
    );

    const loadFile = React.useCallback(() => {
        fileInputRef.current?.click();
    }, []);

    const close = React.useCallback(() => {
        onClose?.();
    }, [onClose]);

    const onFilePicked = React.useCallback(
        async (e: React.ChangeEvent<HTMLInputElement>) => {
            const file = e.target.files?.[0];
            e.target.value = "";
            if (!file) return;

            try {
                const raw = await file.text();
                const parsed = JSON.parse(raw);

                const nextRoot: JsonObject = isPlainObject(parsed)
                    ? (parsed as JsonObject)
                    : ({ value: parsed } as any);

                onRoot(nextRoot);
                callCallbacks(callbacks, "edit-raw", nextRoot, {
                    route,
                    path: "",
                });
            } catch {
                // Keep silent; raw-panel handles validation UX.
            }
        },
        [callbacks, onRoot, route],
    );

    const breadcrumb = React.useMemo(() => {
        const segs = splitPath(route);
        const parts: Array<{ path: JsonPath; label: React.ReactNode }> = [];

        const rootNode = {
            path: "" as JsonPath,
            key: "",
            label: "Root",
            children: routes,
        };

        const rootLabel = renderRouteLabel
            ? renderRouteLabel({ node: rootNode, active: !route })
            : rootNode.label;

        parts.push({ path: "", label: rootLabel });

        let acc = "";
        for (let i = 0; i < segs.length; i++) {
            const s = segs[i]!;
            acc = acc ? `${acc}.${s}` : s;
            const isActive = i === segs.length - 1;

            const label = renderRouteLabel
                ? renderRouteLabel({
                      node: {
                          path: acc,
                          key: s,
                          label: prettifyLabel(s),
                          children: [],
                      },
                      active: isActive,
                  })
                : prettifyLabel(s);

            parts.push({ path: acc, label });
        }

        return (
            <div className="flex items-center gap-1 text-sm text-muted-foreground">
                {parts.map((p, idx) => (
                    <React.Fragment key={p.path || "root"}>
                        <Button
                            type="button"
                            variant="ghost"
                            size="sm"
                            className="h-7 px-2"
                            onClick={() => setRoute(p.path)}
                        >
                            {p.label}
                        </Button>
                        {idx < parts.length - 1 ? (
                            <span className="opacity-60">/</span>
                        ) : null}
                    </React.Fragment>
                ))}
            </div>
        );
    }, [route, routes, renderRouteLabel, setRoute]);

    const routeTitle = React.useMemo(() => {
        if (!route) return "Config.json";
        const key = lastSegment(route);
        if (renderRouteLabel) {
            return renderRouteLabel({
                node: {
                    path: route,
                    key,
                    label: prettifyLabel(key),
                    children: [],
                },
                active: true,
            });
        }
        return prettifyLabel(key);
    }, [route, renderRouteLabel]);

    const viewControls = React.useMemo(() => {
        return (
            <div className="flex items-center gap-1 rounded-md border p-1">
                <Button
                    type="button"
                    size="sm"
                    variant={viewMode === "visual" ? "secondary" : "ghost"}
                    onClick={() => setViewMode("visual")}
                >
                    <Eye className="mr-2 h-4 w-4" />
                    Visual
                </Button>

                {canViewRaw ? (
                    <Button
                        type="button"
                        size="sm"
                        variant={viewMode === "split" ? "secondary" : "ghost"}
                        onClick={() => setViewMode("split")}
                    >
                        <SplitSquareVertical className="mr-2 h-4 w-4" />
                        Split
                    </Button>
                ) : null}

                {canViewRaw ? (
                    <Button
                        type="button"
                        size="sm"
                        variant={viewMode === "raw" ? "secondary" : "ghost"}
                        onClick={() => setViewMode("raw")}
                    >
                        <Code2 className="mr-2 h-4 w-4" />
                        Raw
                    </Button>
                ) : null}
            </div>
        );
    }, [canViewRaw, setViewMode, viewMode]);

    const header = React.useMemo(() => {
        const ctx: JsonEditorHeaderRenderCtx = {
            title: (
                <div className="min-w-0 flex items-center gap-2">
                    <div className="truncate font-medium">
                        {headerTitle ?? "JSON Editor"}
                    </div>
                </div>
            ),
            viewControls,
            loadFile,
            setViewMode,
            close,
        };

        if (renderHeader) return renderHeader(ctx);

        return (
            <div className="flex items-center justify-between gap-3 px-4 py-3">
                <div className="min-w-0 flex items-center gap-3">
                    {ctx.title}

                    <Button
                        type="button"
                        size="sm"
                        variant="outline"
                        onClick={loadFile}
                    >
                        <Upload className="mr-2 h-4 w-4" />
                        Load file
                    </Button>
                </div>

                <div className="flex items-center gap-2">
                    {viewControls}
                    {showClose && onClose ? (
                        <Button
                            type="button"
                            variant="ghost"
                            size="icon"
                            onClick={close}
                            aria-label="Close"
                        >
                            <X className="h-4 w-4" />
                        </Button>
                    ) : null}
                </div>
            </div>
        );
    }, [
        close,
        headerTitle,
        loadFile,
        onClose,
        renderHeader,
        schema,
        setViewMode,
        showClose,
        viewControls,
    ]);

    const onVisualRoot = React.useCallback(
        (nextRoot: JsonObject, detail?: ChangeDetail<any>) => {
            onRoot(nextRoot, detail);

            const d: any = detail;
            const pathGuess =
                (typeof d?.name === "string" && d.name) ||
                (typeof d?.path === "string" && d.path) ||
                route;

            callCallbacks(callbacks, "edit", nextRoot, {
                route,
                path: pathGuess,
            });
        },
        [callbacks, onRoot, route],
    );

    const onRawRoot = React.useCallback(
        (nextRoot: JsonObject, detail?: ChangeDetail<any>) => {
            onRoot(nextRoot, detail);
            callCallbacks(callbacks, "edit-raw", nextRoot, { route, path: "" });
        },
        [callbacks, onRoot, route],
    );

    React.useImperativeHandle(
        ref,
        () => ({
            loadFile,
            getRoute: () => route,
            setRoute: (r) => setRoute(r),
            getViewMode: () => viewMode,
            setViewMode: (m) => setViewMode(m),
        }),
        [loadFile, route, setRoute, setViewMode, viewMode],
    );

    const showRaw = canViewRaw && (viewMode === "split" || viewMode === "raw");
    const showVisual = viewMode !== "raw";
    const rawOnly = viewMode === "raw";

    return (
        <div
            className={cn(
                "flex h-full min-h-0 w-full flex-col overflow-hidden",
                className,
            )}
        >
            <input
                ref={fileInputRef}
                type="file"
                accept="application/json,.json"
                className="hidden"
                onChange={onFilePicked}
            />

            {/* Header stays fixed */}
            {header}
            <Separator />

            {/* Body is the only scrollable region */}
            <ScrollArea className={cn("min-h-0 flex-1", contentClassName)}>
                <div
                    ref={contentRef}
                    className={cn(
                        "flex min-h-0 h-full",
                        isResizing && "select-none cursor-col-resize",
                    )}
                >
                    {/* Raw panel (LEFT) */}
                    {showRaw ? (
                        <div
                            className={cn(
                                "shrink-0 relative",
                                rawOnly ? "flex-1 border-r-0" : "border-r",
                                rawClassName,
                            )}
                            style={{ width: rawOnly ? "100%" : rawWidth }}
                        >
                            <JsonEditorRawPanel
                                root={root}
                                onRoot={onRawRoot}
                                readOnly={!canEditRaw}
                            />

                            {/* Resizer only in split mode */}
                            {!rawOnly && viewMode === "split" ? (
                                <div
                                    role="separator"
                                    aria-orientation="vertical"
                                    tabIndex={0}
                                    className={cn(
                                        "absolute top-0 right-0 h-full w-3 -mr-1.5",
                                        "cursor-col-resize touch-none",
                                        "hover:bg-muted/40",
                                    )}
                                    onPointerDown={onResizePointerDown}
                                    onPointerMove={onResizePointerMove}
                                    onPointerUp={stopResizing}
                                    onPointerCancel={stopResizing}
                                    onDoubleClick={() => setRawWidth(420)}
                                />
                            ) : null}
                        </div>
                    ) : null}

                    {/* Main (RIGHT) */}
                    {showVisual ? (
                        <div className="min-h-0 flex-1 p-4">
                            <JsonEditorMain
                                root={root}
                                onRoot={onVisualRoot}
                                route={route}
                                allPaths={allPaths}
                                fieldMap={fieldMap}
                                layout={layout}
                                defaults={defaults}
                                filters={filters}
                                disabled={false}
                                readOnly={false}
                                breadcrumb={breadcrumb}
                                title={routeTitle}
                                onNavigate={(r) => setRoute(r)}
                                renderField={renderField}
                            />
                        </div>
                    ) : null}
                </div>
            </ScrollArea>
        </div>
    );
});

export default JsonEditorEditor;
```

---
#### 9


` File: packages/form-palette/src/presets/shadcn-variants/json-editor/header.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/json-editor/header.tsx
import * as React from "react";
import { cn } from "@/lib/utils";

import { Button } from "@/presets/ui/button";
import { ToggleGroup, ToggleGroupItem } from "@/presets/ui/toggle-group";

import type { JsonEditorViewMode } from "./types";

export interface JsonEditorHeaderProps {
    /** Header title (matches screenshot: simple, no filename/sublabel) */
    title?: React.ReactNode;

    /** View toggle */
    viewMode: JsonEditorViewMode;
    onViewMode: (mode: JsonEditorViewMode) => void;

    /** Top-right actions (optional wiring) */
    onLoad?: () => void;
    onSave?: () => void;
    onExport?: () => void;

    /** Close button (top-right) */
    onClose?: () => void;

    /** Disable all interactions */
    disabled?: boolean;

    className?: string;
}

export function JsonEditorHeader(props: JsonEditorHeaderProps) {
    const {
        title = "Structured JSON Editor",
        viewMode,
        onViewMode,
        onLoad,
        onSave,
        onExport,
        onClose,
        disabled,
        className,
    } = props;

    return (
        <div
            className={cn(
                "flex w-full items-center justify-between gap-4 border-b bg-background px-4 py-3",
                className
            )}
        >
            {/* Left: title only */}
            <div className="min-w-0">
                <div className="truncate text-sm font-medium">{title}</div>
            </div>

            {/* Right cluster */}
            <div className="flex items-center gap-2">
                <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    disabled={disabled || !onLoad}
                    onClick={onLoad}
                >
                    Load
                </Button>

                <ToggleGroup
                    type="single"
                    value={viewMode}
                    onValueChange={(v) => {
                        if (!v) return;
                        onViewMode(v as JsonEditorViewMode);
                    }}
                    disabled={disabled}
                    className="rounded-md border bg-muted/20 p-1"
                >
                    <ToggleGroupItem value="split" className="px-3 text-xs">
                        Split
                    </ToggleGroupItem>
                    <ToggleGroupItem value="visual" className="px-3 text-xs">
                        Visual
                    </ToggleGroupItem>
                    <ToggleGroupItem value="raw" className="px-3 text-xs">
                        Raw
                    </ToggleGroupItem>
                </ToggleGroup>

                <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    disabled={disabled || !onSave}
                    onClick={onSave}
                >
                    Save
                </Button>

                <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    disabled={disabled || !onExport}
                    onClick={onExport}
                >
                    Export
                </Button>

                {/* Close button (no profile icon) */}
                <Button
                    type="button"
                    variant="ghost"
                    size="icon"
                    aria-label="Close"
                    disabled={disabled || !onClose}
                    onClick={onClose}
                >
                    ×
                </Button>
            </div>
        </div>
    );
}

export default JsonEditorHeader;
```

---
#### 10


` File: packages/form-palette/src/presets/shadcn-variants/json-editor/index.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/json-editor/index.tsx
// noinspection GrazieInspection

import * as React from "react";
import { cn } from "@/lib/utils";

import { Button } from "@/presets/ui/button";
import { Popover, PopoverContent, PopoverTrigger } from "@/presets/ui/popover";
import { ScrollArea } from "@/presets/ui/scroll-area";

import { ChevronDown, ChevronUp, Code2 } from "lucide-react";

import type { ChangeDetail } from "@/variants/shared";
import type { JsonObject } from "@/lib/json-editor/utils";

import type {
    JsonEditorIndexHandle,
    JsonEditorTriggerSize,
    JsonEditorTriggerVariant,
    ShadcnJsonEditorProps,
} from "./types";

import JsonEditorEditor from "./editor";

function isPlainObject(v: unknown): v is JsonObject {
    return typeof v === "object" && v !== null && !Array.isArray(v);
}

function triggerHeightCls(size?: JsonEditorTriggerSize) {
    // match your input-ish sizing conventions
    switch (size) {
        case "sm":
            return "h-8 text-xs";
        case "lg":
            return "h-11 text-base";
        default:
            return "h-9 text-sm";
    }
}

export const ShadcnJsonEditorVariant = React.forwardRef<
    JsonEditorIndexHandle,
    ShadcnJsonEditorProps
>(function ShadcnJsonEditorVariant(props, ref) {
    const {
        mode = "popover",

        // wrapper ui
        title,
        schema,
        triggerLabel = "Edit JSON",
        triggerVariant = "outline" as JsonEditorTriggerVariant,
        triggerSize = "default" as JsonEditorTriggerSize,

        popoverClassName,
        panelClassName,
        className,

        open: openProp,
        onOpenChange,

        id,
        describedBy,

        onClose,

        // editor passthrough
        fieldMap,
        layout,
        defaults,
        filters,
        permissions,
        callbacks,

        renderRouteLabel,
        renderField,

        viewMode,
        defaultViewMode,
        onViewModeChange,

        route,
        onRouteChange,

        // Popover trigger visuals (optional)
        leadingIcons,
        trailingIcons,
        icon,
        iconGap,
        leadingIconSpacing,
        trailingIconSpacing,

        leadingControl,
        trailingControl,
        leadingControlClassName,
        trailingControlClassName,
        joinControls = true,
        extendBoxToControls = true,

        triggerClassName,
    } = props as any;

    const editorRef = React.useRef<any>(null);

    // ---------------------------------------------------------------------
    // Wiring: standalone OR variant
    // ---------------------------------------------------------------------

    const root: JsonObject = React.useMemo(() => {
        if ("root" in props) return (props as any).root;

        const v = (props as any).value;
        if (isPlainObject(v)) return v;
        if (v == null) return {} as JsonObject;

        // avoid crashing on non-object values
        return {} as JsonObject;
    }, [props]);

    const emitRoot = React.useCallback(
        (nextRoot: JsonObject, detail?: ChangeDetail<any>) => {
            if ("onRoot" in props) {
                (props as any).onRoot?.(nextRoot, detail);
                return;
            }
            (props as any).onValue?.(nextRoot, detail);
        },
        [props],
    );

    // ---------------------------------------------------------------------
    // Popover open state (controlled or internal)
    // ---------------------------------------------------------------------

    const [openInner, setOpenInner] = React.useState(false);
    const open = openProp ?? openInner;

    const setOpen = React.useCallback(
        (next: boolean) => {
            if (openProp === undefined) setOpenInner(next);
            onOpenChange?.(next);
            if (!next) onClose?.();
        },
        [openProp, onOpenChange, onClose],
    );

    const close = React.useCallback(() => setOpen(false), [setOpen]);
    const doOpen = React.useCallback(() => setOpen(true), [setOpen]);
    const toggle = React.useCallback(() => setOpen(!open), [setOpen, open]);

    // ---------------------------------------------------------------------
    // Inline “accordion-like” expansion (MUST NOT be a hook in a branch)
    // ---------------------------------------------------------------------

    const [expanded, setExpanded] = React.useState<boolean | undefined>();
    React.useImperativeHandle(
        ref,
        () => ({
            open: doOpen,
            close,
            toggle,
            editor: editorRef,
        }),
        [doOpen, close, toggle],
    );

    // If accordion and user didn't control viewMode, force default to visual
    const resolvedDefaultViewMode =
        defaultViewMode ??
        (mode === "accordion" && viewMode === undefined ? "visual" : undefined);

    const editorNode = (
        <JsonEditorEditor
            ref={editorRef}
            root={root}
            onRoot={emitRoot}
            fieldMap={fieldMap}
            layout={layout}
            defaults={defaults}
            filters={filters}
            permissions={permissions}
            callbacks={callbacks}
            renderRouteLabel={renderRouteLabel as any}
            renderField={renderField as any}
            title={title}
            schema={schema}
            route={route}
            onRouteChange={onRouteChange}
            viewMode={viewMode as any}
            defaultViewMode={resolvedDefaultViewMode as any}
            onViewModeChange={onViewModeChange}
            showClose={mode === "popover"}
            onClose={mode === "popover" ? close : undefined}
        />
    );

    // ---------------------------------------------------------------------
    // Inline “accordion-like” mode
    // - header must look like an input trigger (border/bg/height/focus)
    // ---------------------------------------------------------------------

    if (mode === "accordion") {
        const headerHeight = triggerHeightCls(triggerSize);
        const wrapperBox = cn(
            "border-input w-full min-w-0 rounded-md border bg-surfaces-input shadow-xs",
            "transition-[color,box-shadow] outline-none",
            "focus-within:border-ring focus-within:ring-ring/50 focus-within:ring-[3px]",
            "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        );

        return (
            <div className={cn("w-full", className)}>
                <div
                    className={cn(
                        wrapperBox,
                        "overflow-hidden",
                        panelClassName,
                    )}
                >
                    {/* “Trigger area” */}
                    <div
                        className={cn(
                            "flex items-center justify-between gap-3 px-3",
                            headerHeight,
                        )}
                        aria-controls={
                            id ? `${id}__json_editor_panel` : undefined
                        }
                    >
                        {typeof schema === "string" ? (
                            <div className="min-w-0 flex-1 truncate">
                                {schema}
                            </div>
                        ) : (
                            <div className="min-w-0 flex-1 truncate">
                                {title ?? "JSON Editor"}
                            </div>
                        )}

                        <Button
                            type="button"
                            size="sm"
                            variant="link"
                            onClick={() => setExpanded((v) => !v)}
                            aria-expanded={expanded}
                            aria-controls={
                                id ? `${id}__json_editor_panel` : undefined
                            }
                            aria-label={
                                expanded
                                    ? "Collapse JSON editor"
                                    : "Expand JSON editor"
                            }
                            className="h-8 w-8 p-0"
                        >
                            {expanded ? (
                                <ChevronUp className="h-4 w-4" />
                            ) : (
                                <ChevronDown className="h-4 w-4" />
                            )}
                        </Button>
                    </div>

                    {expanded ? (
                        <div
                            id={id ? `${id}__json_editor_panel` : undefined}
                            className="h-130 min-h-0 overflow-hidden border-t border-border/60"
                        >
                            <ScrollArea className="h-full w-full">
                                <div className="min-h-0">{editorNode}</div>
                            </ScrollArea>
                        </div>
                    ) : null}
                </div>
            </div>
        );
    }

    // ---------------------------------------------------------------------
    // Popover mode (trigger visuals + optional controls)
    // ---------------------------------------------------------------------

    const triggerDisabled =
        "disabled" in props ? !!(props as any).disabled : false;

    const resolvedLeadingIcons: React.ReactNode[] = (() => {
        if (Array.isArray(leadingIcons) && leadingIcons.length)
            return leadingIcons;
        if (icon) return [icon];
        return [<Code2 key="default" className="h-4 w-4 opacity-70" />];
    })();

    const resolvedTrailingIcons: React.ReactNode[] =
        (Array.isArray(trailingIcons) ? trailingIcons : []) ?? [];

    const baseIconGap = iconGap ?? 4;
    const leadingGap = leadingIconSpacing ?? baseIconGap;
    const trailingGap = trailingIconSpacing ?? baseIconGap;

    const hasLeadingIcons = resolvedLeadingIcons.length > 0;
    const hasTrailingIcons = resolvedTrailingIcons.length > 0;

    const hasLeadingControl = !!leadingControl;
    const hasTrailingControl = !!trailingControl;
    const hasControls = hasLeadingControl || hasTrailingControl;

    const baseBoxClasses = cn(
        "border-input w-full min-w-0 rounded-md border bg-surfaces-input hover:bg-surfaces-input shadow-xs",
        "transition-[color,box-shadow] outline-none",
        "focus-within:border-ring focus-within:ring-ring/50 focus-within:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
    );

    const TriggerButton = (
        <Button
            type="button"
            id={id}
            aria-describedby={describedBy}
            variant={triggerVariant as any}
            size={triggerSize as any}
            disabled={triggerDisabled}
            className={cn(
                "w-full justify-between",
                baseBoxClasses,
                hasControls &&
                    joinControls &&
                    extendBoxToControls &&
                    "border-none shadow-none focus-visible:ring-0 focus-visible:outline-none",
                triggerClassName,
            )}
        >
            <div className="flex w-full items-center justify-between gap-2 min-w-0">
                <div className="flex min-w-0 items-center gap-2 grow">
                    {hasLeadingIcons && (
                        <span
                            className="flex items-center shrink-0"
                            style={{ columnGap: leadingGap }}
                            data-slot="leading-icons"
                        >
                            {resolvedLeadingIcons.map((node, idx) => (
                                <span
                                    key={idx}
                                    className="flex items-center justify-center"
                                >
                                    {node}
                                </span>
                            ))}
                        </span>
                    )}

                    <span className="min-w-0 flex-1 truncate text-left">
                        {triggerLabel}
                    </span>
                </div>

                <div className="flex items-center gap-1 shrink-0">
                    {typeof schema === "string" ? (
                        <span className="ml-2 max-w-[45%] truncate text-xs text-muted-foreground">
                            {schema}
                        </span>
                    ) : null}

                    {hasTrailingIcons && (
                        <span
                            className="flex items-center"
                            style={{ columnGap: trailingGap }}
                            data-slot="trailing-icons"
                        >
                            {resolvedTrailingIcons.map((node, idx) => (
                                <span
                                    key={idx}
                                    className="flex items-center justify-center"
                                >
                                    {node}
                                </span>
                            ))}
                        </span>
                    )}
                </div>
            </div>
        </Button>
    );

    const PopoverCore = (
        <Popover open={open} onOpenChange={setOpen}>
            <PopoverTrigger asChild>{TriggerButton}</PopoverTrigger>

            <PopoverContent
                align="end"
                sideOffset={8}
                avoidCollisions
                collisionPadding={12}
                className={cn(
                    "p-0 overflow-hidden",
                    "w-[min(980px,var(--radix-popper-available-width))] max-w-[95dvw]",
                    "h-[min(85dvh,var(--radix-popper-available-height))] max-h-[min(85dvh,var(--radix-popper-available-height))]",
                    popoverClassName,
                )}
                style={{
                    maxHeight:
                        "min(85dvh, var(--radix-popper-available-height))",
                    maxWidth: "min(95dvw, var(--radix-popper-available-width))",
                }}
            >
                <ScrollArea className="h-full w-full">
                    <div className="min-h-0">{editorNode}</div>
                </ScrollArea>
            </PopoverContent>
        </Popover>
    );

    if (!hasControls) {
        return <div className={cn("w-full", className)}>{PopoverCore}</div>;
    }

    if (joinControls) {
        return (
            <div className={cn("w-full", className)}>
                <div
                    className={cn(
                        "flex items-stretch w-full",
                        extendBoxToControls
                            ? baseBoxClasses
                            : "border-none shadow-none bg-transparent",
                    )}
                    data-slot="json-editor-group"
                >
                    {hasLeadingControl && (
                        <div
                            className={cn(
                                "flex items-center px-2",
                                leadingControlClassName,
                            )}
                            data-slot="leading-control"
                        >
                            {leadingControl}
                        </div>
                    )}

                    <div
                        className="flex-1 min-w-0"
                        data-slot="json-editor-region"
                    >
                        {PopoverCore}
                    </div>

                    {hasTrailingControl && (
                        <div
                            className={cn(
                                "flex items-center px-2",
                                trailingControlClassName,
                            )}
                            data-slot="trailing-control"
                        >
                            {trailingControl}
                        </div>
                    )}
                </div>
            </div>
        );
    }

    return (
        <div className={cn("flex items-stretch w-full", className)}>
            {hasLeadingControl && (
                <div
                    className={cn(
                        "flex items-center mr-1",
                        leadingControlClassName,
                    )}
                    data-slot="leading-control"
                >
                    {leadingControl}
                </div>
            )}

            <div className="flex-1 min-w-0" data-slot="json-editor-region">
                {PopoverCore}
            </div>

            {hasTrailingControl && (
                <div
                    className={cn(
                        "flex items-center ml-1",
                        trailingControlClassName,
                    )}
                    data-slot="trailing-control"
                >
                    {trailingControl}
                </div>
            )}
        </div>
    );
});

export default ShadcnJsonEditorVariant;
```

---
#### 11


` File: packages/form-palette/src/presets/shadcn-variants/json-editor/main.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/json-editor-main.tsx
// noinspection GrazieInspection

import * as React from "react";
import { cn } from "@/lib/utils";

import { Badge } from "@/presets/ui/badge";
import { Button } from "@/presets/ui/button";
import { Separator } from "@/presets/ui/separator";

import { InputField } from "@/input/input-field";

import type { ChangeDetail } from "@/variants/shared";
import type {
    JsonObject,
    JsonPath,
    JsonValue,
    LayoutRow,
} from "@/lib/json-editor/utils";

import {
    splitPath,
    lastSegment,
    resolveLayoutForParent,
} from "@/lib/json-editor/utils";
import { getDirectChildPaths } from "@/lib/json-editor/tree";

import type {
    JsonEditorCallbacks,
    JsonEditorFieldMap,
    JsonEditorDefaults,
    JsonEditorFilters,
    JsonEditorLayoutMap,
    JsonEditorResolvedField,
    JsonEditorVariantSpec,
    JsonEditorEditMeta,
    JsonRouteNode,
} from "./types";

import { pickBest } from "@/lib/json-editor/utils";

/* ─────────────────────────────────────────────────────────────
 * Props
 * ───────────────────────────────────────────────────────────── */

export interface JsonEditorMainProps {
    /** root JSON (always an object for this editor) */
    root: JsonObject;

    /** notify parent (json-editor variant wrapper) */
    onRoot: (nextRoot: JsonObject, detail?: ChangeDetail<any>) => void;

    /** active "page" route: "" | "config" | "config.headers" */
    route: JsonPath;

    /**
     * IMPORTANT (matches your layout util):
     * A generic paths list used by layout/tree utils.
     * Should include *at least* all field paths you want to render.
     */
    allPaths: JsonPath[];

    /** config */
    fieldMap?: JsonEditorFieldMap;
    layout?: JsonEditorLayoutMap;
    defaults?: JsonEditorDefaults;
    filters?: JsonEditorFilters;

    /** callbacks */
    callbacks?: JsonEditorCallbacks;

    /** flags */
    disabled?: boolean;
    readOnly?: boolean;

    /** main header (inside main panel) */
    breadcrumb?: React.ReactNode;
    title?: React.ReactNode;
    headerRight?: React.ReactNode;

    /** navigation for section “open” buttons */
    onNavigate?: (route: JsonPath) => void;

    /** optional advanced override */
    renderField?: (ctx: {
        field: JsonEditorResolvedField;
        route: JsonPath;
    }) => React.ReactNode;
    renderRouteLabel?: (ctx: {
        node: JsonRouteNode;
        active: boolean;
    }) => React.ReactNode;

    /** styling */
    className?: string;
    contentClassName?: string;
}

/* ─────────────────────────────────────────────────────────────
 * Local JSON path helpers (NOT provided by your utils)
 * ───────────────────────────────────────────────────────────── */

function isPlainObject(v: unknown): v is Record<string, any> {
    return typeof v === "object" && v !== null && !Array.isArray(v);
}

function valueTypeOf(v: JsonValue): JsonEditorResolvedField["valueType"] {
    if (v === null) return "null";
    if (Array.isArray(v)) return "array";
    if (isPlainObject(v)) return "object";
    if (typeof v === "string") return "string";
    if (typeof v === "number") return "number";
    return "boolean";
}

function getAtPath(root: any, path: JsonPath): any {
    if (!path) return root;
    const segs = splitPath(path);
    let cur = root;
    for (const seg of segs) {
        if (cur == null) return undefined;
        cur = cur[seg];
    }
    return cur;
}

function setAtPath(root: any, path: JsonPath, nextValue: any): any {
    const segs = splitPath(path);
    if (!segs.length) return nextValue;

    const out = Array.isArray(root) ? [...root] : { ...(root ?? {}) };
    let cur: any = out;

    for (let i = 0; i < segs.length; i++) {
        const seg = segs[i]!;
        const last = i === segs.length - 1;

        if (last) {
            cur[seg] = nextValue;
            break;
        }

        const prev = cur[seg];
        const next = Array.isArray(prev)
            ? [...prev]
            : isPlainObject(prev)
              ? { ...prev }
              : {};
        cur[seg] = next;
        cur = next;
    }

    return out;
}

function prettifyLabel(key: string) {
    const spaced = key
        .replace(/_/g, " ")
        .replace(/([a-z0-9])([A-Z])/g, "$1 $2")
        .trim();
    return spaced ? spaced[0]!.toUpperCase() + spaced.slice(1) : key;
}

function typeTag(type: string) {
    return (
        <Badge variant="secondary" className="uppercase tracking-wide">
            {type}
        </Badge>
    );
}

function normalizeVariantSpec(spec: JsonEditorVariantSpec | undefined): {
    variant?: string;
    props?: any;
} {
    if (!spec) return {};
    if (typeof spec === "string") return { variant: spec };
    return { variant: spec.variant, props: spec.props };
}

function fallbackVariantForValueType(t: JsonEditorResolvedField["valueType"]) {
    if (t === "number") return "number";
    if (t === "boolean") return "toggle"; // default
    // null/string
    return "text";
}

function metaForPath(
    action: JsonEditorEditMeta["action"],
    route: JsonPath,
    path: JsonPath,
): JsonEditorEditMeta {
    const segs = splitPath(path);
    const key = segs.length ? String(segs[segs.length - 1]!) : "";
    const parent = segs.length > 1 ? segs.slice(0, -1).join(".") : "";
    return { action, route, path, parent, key };
}

/* ─────────────────────────────────────────────────────────────
 * Render a primitive field (always InputField)
 * ───────────────────────────────────────────────────────────── */

function PrimitiveField(props: {
    root: JsonObject;
    path: JsonPath;
    route: JsonPath;
    fieldMap?: JsonEditorFieldMap;
    callbacks?: JsonEditorCallbacks;
    disabled?: boolean;
    readOnly?: boolean;
    onRoot: (next: JsonObject, detail?: ChangeDetail<any>) => void;
    renderField?: JsonEditorMainProps["renderField"];
}) {
    const {
        root,
        path,
        route,
        fieldMap,
        callbacks,
        disabled,
        readOnly,
        onRoot,
        renderField,
    } = props;

    const key = lastSegment(path);
    const raw = getAtPath(root, path) as JsonValue | undefined;
    const val = (raw === undefined ? null : raw) as JsonValue;
    const valueType = valueTypeOf(val);

    const hit = pickBest(fieldMap, path);
    const spec = hit?.value;
    const resolved = normalizeVariantSpec(spec);

    const variant = resolved.variant || fallbackVariantForValueType(valueType);

    const field: JsonEditorResolvedField = {
        path,
        key,
        value: val,
        valueType,
        variant: spec,
    };

    const override = renderField?.({ field, route });
    if (override != null) return <>{override}</>;

    return (
        <InputField
            name={path}
            label={prettifyLabel(key)}
            variant={variant as any}
            tags={[{ label: typeTag(valueType) }] as any}
            disabled={disabled}
            readOnly={readOnly}
            {...(resolved.props ?? {})}
            value={val as any}
            onValue={(next: any, detail?: ChangeDetail<any>) => {
                if (disabled || readOnly) return;

                const nextRoot = setAtPath(root, path, next) as JsonObject;
                onRoot(nextRoot, detail);

                callbacks?.onEdit?.(nextRoot, metaForPath("edit", route, path));
            }}
        />
    );
}

/* ─────────────────────────────────────────────────────────────
 * Section card (OBJECT / ARRAY) like your screenshot
 * ───────────────────────────────────────────────────────────── */

function SectionCard(props: {
    title: React.ReactNode;
    tag: React.ReactNode;
    right?: React.ReactNode;
    children: React.ReactNode;
}) {
    const { title, tag, right, children } = props;

    return (
        <div className="rounded-lg border bg-background/50">
            <div className="flex items-center justify-between gap-3 px-4 py-3">
                <div className="min-w-0">
                    <div className="flex items-center gap-2 min-w-0">
                        <div className="font-medium truncate">{title}</div>
                        <div className="shrink-0">{tag}</div>
                    </div>
                </div>

                {right ? <div className="shrink-0">{right}</div> : null}
            </div>

            <Separator />
            <div className="p-4">{children}</div>
        </div>
    );
}

/* ─────────────────────────────────────────────────────────────
 * Main
 * ───────────────────────────────────────────────────────────── */

export function JsonEditorMain(props: JsonEditorMainProps) {
    const {
        root,
        onRoot,
        route,
        allPaths,
        fieldMap,
        layout,
        defaults,
        filters,
        callbacks,
        disabled,
        readOnly,
        breadcrumb,
        title,
        onNavigate,
        renderField,
        renderRouteLabel,
        className,
        contentClassName,
    } = props;

    const directChildPaths = React.useMemo(() => {
        return getDirectChildPaths(route, allPaths);
    }, [route, allPaths]);

    const rows: LayoutRow[] = React.useMemo(() => {
        return resolveLayoutForParent({
            parent: route,
            childPaths: directChildPaths,
            layout: layout as any,
            filters,
        });
    }, [route, directChildPaths, layout, filters]);

    const effectiveRows: LayoutRow[] = React.useMemo(() => {
        const hasAny = rows.some((r) => r.fields?.length);
        if (hasAny) return rows;

        return directChildPaths.map(
            (p) => ({ parent: route, kind: "row", fields: [p] }) as LayoutRow,
        );
    }, [rows, directChildPaths, route]);

    const pageValue = getAtPath(root, route) as JsonValue;
    const validJson = isPlainObject(root);

    return (
        <div className={cn("flex min-h-0 flex-col gap-4", className)}>
            <div className="flex items-start justify-between gap-4">
                <div className="min-w-0">
                    {breadcrumb ? (
                        <div className="text-sm text-muted-foreground truncate">
                            {breadcrumb}
                        </div>
                    ) : (
                        <div className="text-sm text-muted-foreground truncate">
                            Root Object
                            {route ? ` > ${splitPath(route).join(" > ")}` : ""}
                        </div>
                    )}

                    <div className="mt-1 text-3xl font-semibold leading-tight">
                        {title ??
                            (route
                                ? prettifyLabel(lastSegment(route))
                                : "Config.json")}
                    </div>
                </div>

                <div className="shrink-0 flex items-center gap-2">
                    <Badge variant="secondary">
                        {validJson ? "Valid JSON" : "Invalid"}
                    </Badge>
                </div>
            </div>

            <div
                className={cn("flex min-h-0 flex-col gap-4", contentClassName)}
            >
                {!isPlainObject(pageValue) ? (
                    <div className="rounded-lg border bg-muted/20 p-4 text-sm text-muted-foreground">
                        This page is not an object.
                    </div>
                ) : null}

                {effectiveRows.map((row, idx) => {
                    if (!row.fields?.length) return null;

                    const isGrid = row.fields.length > 1;

                    return (
                        <div
                            key={`${row.parent}::${row.kind}::${idx}`}
                            className={cn(
                                isGrid
                                    ? "grid gap-4 md:grid-cols-2"
                                    : "flex flex-col",
                            )}
                        >
                            {row.fields.map((path) => {
                                const v = getAtPath(root, path) as JsonValue;
                                const vt = valueTypeOf(v);

                                if (vt === "object" && isPlainObject(v)) {
                                    const sectionRoute = path;

                                    const sectionChildPaths =
                                        getDirectChildPaths(
                                            sectionRoute,
                                            allPaths,
                                        );
                                    const sectionRows = resolveLayoutForParent({
                                        parent: sectionRoute,
                                        childPaths: sectionChildPaths,
                                        layout: layout as any,
                                        filters,
                                    });

                                    const openBtn = onNavigate ? (
                                        <Button
                                            type="button"
                                            variant="ghost"
                                            size="sm"
                                            onClick={() =>
                                                onNavigate(sectionRoute)
                                            }
                                        >
                                            Open
                                        </Button>
                                    ) : null;

                                    const sectionTitle = renderRouteLabel
                                        ? renderRouteLabel({
                                              node: {
                                                  path: path,
                                                  key: lastSegment(path),
                                                  label: prettifyLabel(
                                                      lastSegment(path),
                                                  ),
                                                  children: [],
                                              },
                                              active: false,
                                          })
                                        : prettifyLabel(lastSegment(path));

                                    return (
                                        <SectionCard
                                            key={path}
                                            title={sectionTitle}
                                            tag={typeTag("object")}
                                            right={openBtn}
                                        >
                                            <div className="flex flex-col gap-4">
                                                {sectionRows.map((sr, sidx) => {
                                                    if (!sr.fields?.length)
                                                        return null;

                                                    const sGrid =
                                                        sr.fields.length > 1;

                                                    return (
                                                        <div
                                                            key={`${sectionRoute}::${sidx}`}
                                                            className={cn(
                                                                sGrid
                                                                    ? "grid gap-4 md:grid-cols-2"
                                                                    : "flex flex-col",
                                                            )}
                                                        >
                                                            {sr.fields.map(
                                                                (sp) => {
                                                                    const sv =
                                                                        getAtPath(
                                                                            root,
                                                                            sp,
                                                                        ) as JsonValue;
                                                                    const svt =
                                                                        valueTypeOf(
                                                                            sv,
                                                                        );

                                                                    if (
                                                                        svt ===
                                                                            "object" ||
                                                                        svt ===
                                                                            "array"
                                                                    ) {
                                                                        return (
                                                                            <div
                                                                                key={
                                                                                    sp
                                                                                }
                                                                                className="rounded-md border px-3 py-2 text-sm text-muted-foreground flex items-center justify-between"
                                                                            >
                                                                                <div className="truncate">
                                                                                    {prettifyLabel(
                                                                                        lastSegment(
                                                                                            sp,
                                                                                        ),
                                                                                    )}
                                                                                </div>

                                                                                {onNavigate ? (
                                                                                    <Button
                                                                                        type="button"
                                                                                        size="sm"
                                                                                        variant="ghost"
                                                                                        onClick={() =>
                                                                                            onNavigate(
                                                                                                sp,
                                                                                            )
                                                                                        }
                                                                                    >
                                                                                        Open
                                                                                    </Button>
                                                                                ) : null}
                                                                            </div>
                                                                        );
                                                                    }

                                                                    return (
                                                                        <PrimitiveField
                                                                            key={
                                                                                sp
                                                                            }
                                                                            root={
                                                                                root
                                                                            }
                                                                            path={
                                                                                sp
                                                                            }
                                                                            route={
                                                                                route
                                                                            }
                                                                            fieldMap={
                                                                                fieldMap
                                                                            }
                                                                            callbacks={
                                                                                callbacks
                                                                            }
                                                                            disabled={
                                                                                disabled
                                                                            }
                                                                            readOnly={
                                                                                readOnly
                                                                            }
                                                                            onRoot={
                                                                                onRoot
                                                                            }
                                                                            renderField={
                                                                                renderField
                                                                            }
                                                                        />
                                                                    );
                                                                },
                                                            )}
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </SectionCard>
                                    );
                                }

                                if (vt === "array" && Array.isArray(v)) {
                                    const arrPath = path;
                                    const items = v;

                                    return (
                                        <SectionCard
                                            key={path}
                                            title={prettifyLabel(
                                                lastSegment(path),
                                            )}
                                            tag={typeTag("array")}
                                            right={
                                                onNavigate ? (
                                                    <Button
                                                        type="button"
                                                        variant="ghost"
                                                        size="sm"
                                                        onClick={() =>
                                                            onNavigate(arrPath)
                                                        }
                                                    >
                                                        Open
                                                    </Button>
                                                ) : null
                                            }
                                        >
                                            <div className="flex flex-col gap-3">
                                                <div className="text-sm text-muted-foreground">
                                                    {items.length} item
                                                    {items.length === 1
                                                        ? ""
                                                        : "s"}
                                                </div>

                                                <div className="flex flex-col gap-3">
                                                    {items.map((_item, i) => {
                                                        const itemPath = `${arrPath}.${i}`;

                                                        return (
                                                            <div
                                                                key={itemPath}
                                                                className="flex items-start gap-2"
                                                            >
                                                                <div className="flex-1">
                                                                    <PrimitiveField
                                                                        root={
                                                                            root
                                                                        }
                                                                        path={
                                                                            itemPath
                                                                        }
                                                                        route={
                                                                            route
                                                                        }
                                                                        fieldMap={
                                                                            fieldMap
                                                                        }
                                                                        callbacks={
                                                                            callbacks
                                                                        }
                                                                        disabled={
                                                                            disabled
                                                                        }
                                                                        readOnly={
                                                                            readOnly
                                                                        }
                                                                        onRoot={
                                                                            onRoot
                                                                        }
                                                                        renderField={
                                                                            renderField
                                                                        }
                                                                    />
                                                                </div>

                                                                <Button
                                                                    type="button"
                                                                    variant="ghost"
                                                                    size="icon"
                                                                    className="mt-1"
                                                                    disabled={
                                                                        disabled ||
                                                                        readOnly
                                                                    }
                                                                    onClick={() => {
                                                                        if (
                                                                            disabled ||
                                                                            readOnly
                                                                        )
                                                                            return;

                                                                        const nextArr =
                                                                            items.filter(
                                                                                (
                                                                                    _,
                                                                                    idx2,
                                                                                ) =>
                                                                                    idx2 !==
                                                                                    i,
                                                                            );
                                                                        const nextRoot =
                                                                            setAtPath(
                                                                                root,
                                                                                arrPath,
                                                                                nextArr,
                                                                            ) as JsonObject;

                                                                        onRoot(
                                                                            nextRoot,
                                                                        );
                                                                        callbacks?.onDelete?.(
                                                                            nextRoot,
                                                                            metaForPath(
                                                                                "delete",
                                                                                route,
                                                                                itemPath,
                                                                            ),
                                                                        );
                                                                    }}
                                                                >
                                                                    ×
                                                                </Button>
                                                            </div>
                                                        );
                                                    })}

                                                    <Button
                                                        type="button"
                                                        variant="outline"
                                                        className="border-dashed"
                                                        disabled={
                                                            disabled || readOnly
                                                        }
                                                        onClick={() => {
                                                            if (
                                                                disabled ||
                                                                readOnly
                                                            )
                                                                return;

                                                            const nextIndex =
                                                                items.length;
                                                            const nextArr = [
                                                                ...items,
                                                                "",
                                                            ];
                                                            const nextRoot =
                                                                setAtPath(
                                                                    root,
                                                                    arrPath,
                                                                    nextArr,
                                                                ) as JsonObject;

                                                            onRoot(nextRoot);
                                                            callbacks?.onAdd?.(
                                                                nextRoot,
                                                                metaForPath(
                                                                    "add",
                                                                    route,
                                                                    `${arrPath}.${nextIndex}`,
                                                                ),
                                                            );
                                                        }}
                                                    >
                                                        + Add Item
                                                    </Button>
                                                </div>
                                            </div>
                                        </SectionCard>
                                    );
                                }

                                return (
                                    <PrimitiveField
                                        key={path}
                                        root={root}
                                        path={path}
                                        route={route}
                                        fieldMap={fieldMap}
                                        callbacks={callbacks}
                                        disabled={disabled}
                                        readOnly={readOnly}
                                        onRoot={onRoot}
                                        renderField={renderField}
                                    />
                                );
                            })}
                        </div>
                    );
                })}
            </div>

            {defaults?.values ? null : null}
        </div>
    );
}

export default JsonEditorMain;
```

---
#### 12


` File: packages/form-palette/src/presets/shadcn-variants/json-editor/raw-panel.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/json-editor/raw-panel.tsx
// noinspection GrazieInspection

import * as React from "react";
import { cn } from "@/lib/utils";

import { Button } from "@/presets/ui/button";
import { Badge } from "@/presets/ui/badge";
import { Separator } from "@/presets/ui/separator";
import { ScrollArea } from "@/presets/ui/scroll-area";

import { JsonEditor } from "json-edit-react";

import type { ChangeDetail } from "@/variants/shared";
import type { JsonObject } from "@/lib/json-editor/utils";
import type { JsonEditorPermissions } from "./types";

export interface JsonEditorRawPanelProps {
    root: JsonObject;
    onRoot: (nextRoot: JsonObject, detail?: ChangeDetail<any>) => void;

    permissions?: JsonEditorPermissions;

    disabled?: boolean;
    readOnly?: boolean;

    className?: string;
    headerClassName?: string;
    bodyClassName?: string;
}

function isPlainObject(v: unknown): v is Record<string, any> {
    return typeof v === "object" && v !== null && !Array.isArray(v);
}

export function JsonEditorRawPanel(props: JsonEditorRawPanelProps) {
    const {
        root,
        onRoot,
        permissions,
        disabled,
        readOnly,
        className,
        headerClassName,
        bodyClassName,
    } = props;

    const canViewRaw = permissions?.canViewRaw ?? true;
    const canEditRaw = permissions?.canEditRaw ?? false;

    if (!canViewRaw) return null;

    const viewOnly = !!disabled || !!readOnly || !canEditRaw;

    const onCopy = React.useCallback(async () => {
        try {
            await navigator.clipboard.writeText(
                JSON.stringify(root ?? {}, null, 2)
            );
        } catch {
            // ignore clipboard failures silently
        }
    }, [root]);

    return (
        <div
            className={cn(
                // Sidebar panel look (not a rounded "card")
                "flex min-h-0 flex-col border-r bg-background",
                className
            )}
        >
            {/* Panel header (matches screenshot style) */}
            <div
                className={cn(
                    "flex items-center justify-between gap-2 px-4 py-3",
                    headerClassName
                )}
            >
                <div className="min-w-0">
                    <div className="text-sm font-medium truncate">
                        Source code
                    </div>
                </div>

                <div className="flex items-center gap-2 shrink-0">
                    {viewOnly ? (
                        <Badge variant="secondary" className="h-6">
                            Read only
                        </Badge>
                    ) : null}

                    <Button
                        type="button"
                        variant="ghost"
                        size="sm"
                        onClick={onCopy}
                        disabled={!root}
                    >
                        Copy
                    </Button>
                </div>
            </div>

            <Separator />

            {/* Scrollable editor body */}
            <ScrollArea className={cn("min-h-0 flex-1", bodyClassName)}>
                <div className="p-3">
                    <JsonEditor
                        data={root ?? {}}
                        setData={(next) => {
                            // Root must remain an object for this variant.
                            if (!isPlainObject(next)) return;
                            onRoot(next as JsonObject);
                        }}
                        viewOnly={viewOnly}
                    />
                </div>
            </ScrollArea>
        </div>
    );
}

export default JsonEditorRawPanel;
```

---
#### 13


` File: packages/form-palette/src/presets/shadcn-variants/json-editor/types.ts`  [↑ Back to top](#index)

```ts
// src/presets/shadcn-variants/json-editor/types.ts
// noinspection GrazieInspection

import type { VariantKey, VariantPropsFor } from "@/schema/variant";
import * as React from "react";
import type { VariantBaseProps } from "@/variants/shared";
import type {
    JsonObject,
    JsonPath,
    JsonValue,
    JsonWildcard,
} from "@/lib/json-editor/utils";

/* ─────────────────────────────────────────────────────────────
 * Variant config (fieldMap/defaults.array)
 * ───────────────────────────────────────────────────────────── */

/**
 * A "variant spec" can be:
 * - a plain VariantKey ("text", "number", "toggle", ...)
 * - a variant key + props to pass into that variant
 */
export type JsonEditorVariantSpec =
    | VariantKey
    | {
          variant: VariantKey;
          props?: VariantPropsFor<any>;
      };

/**
 * Map a key-path (or wildcard) to a variant spec.
 *
 * Keys are matched against:
 * - full path:  "config.apiEndpoint"
 * - leaf key:   "apiEndpoint"
 *
 * Wild examples:
 * - "*api*"             (segment contains "api")
 * - "config.*"          (direct children)
 * - "config.**"         (subtree)
 * - "**.*token*"        (any route/leaf)
 */
export type JsonEditorFieldMap = Record<JsonWildcard, JsonEditorVariantSpec>;

/* ─────────────────────────────────────────────────────────────
 * Layout
 * ───────────────────────────────────────────────────────────── */

/**
 * Layout is scoped to a "page" (object route path).
 *
 * Each entry is a "row":
 * - string: render a single field row
 * - string[]: render these fields side-by-side (grid row)
 *
 * Example:
 * layout: {
 *   "": [["projectName","version"], "description"],
 *   "config": [["maxEntries","apiEndpoint"], "retry"]
 * }
 */
export type JsonEditorLayoutRow = string | string[];
export type JsonEditorLayoutMap = Record<JsonWildcard, JsonEditorLayoutRow[]>;

/* ─────────────────────────────────────────────────────────────
 * Include / Exclude filters
 * ───────────────────────────────────────────────────────────── */

export interface JsonEditorFilters {
    /** Hide entire object routes/pages (navigation + rendering) */
    excludeRoutes?: JsonWildcard[];
    includeRoutes?: JsonWildcard[];

    /** Hide specific fields (by full path or leaf/wild patterns) */
    excludeFields?: JsonWildcard[];
    includeFields?: JsonWildcard[];

    /**
     * If true, excluding "config" also excludes "config.**".
     * Default: true
     */
    excludeRouteSubtree?: boolean;
}

/* ─────────────────────────────────────────────────────────────
 * Defaults
 * ───────────────────────────────────────────────────────────── */

/**
 * Default value for a newly created key (or a new array item).
 * Can be a constant JsonValue, or a function.
 */
export type JsonEditorDefaultValueSpec =
    | JsonValue
    | ((ctx: {
          parentPath: JsonPath;
          key: string;
          current: JsonValue | undefined;
      }) => JsonValue);

export interface JsonEditorDefaults {
    /**
     * When adding a new array item, you can pick from allowed variants.
     * You can pass VariantKey or a {variant, props} spec.
     */
    array?: JsonEditorVariantSpec[];

    /**
     * Optional default values for new keys.
     * Keyed by wildcard path (full path / leaf / patterns).
     */
    values?: Record<JsonWildcard, JsonEditorDefaultValueSpec>;
}

/* ─────────────────────────────────────────────────────────────
 * Navigation (routes derived from JSON)
 * ───────────────────────────────────────────────────────────── */

export type JsonEditorNavMode = "sidebar" | "tabs" | "drawer";

export interface JsonEditorNavOptions {
    mode?: JsonEditorNavMode;

    /** Show root "" as a page in navigation. Default: true */
    showRoot?: boolean;

    /** Initial active route/page. Default: "" */
    defaultRoute?: JsonPath;

    /** Optional label overrides for route nodes */
    routeLabels?: Record<JsonWildcard, React.ReactNode>;

    /** Max object nesting to generate routes for. Optional safety */
    maxDepth?: number;

    /**
     * Whether arrays containing objects can contribute routes.
     * - "none": arrays never create routes (default)
     * - "objects": array items that are objects become routes like "config.items.0"
     */
    arrayRoutes?: "none" | "objects";
}

export interface JsonRouteNode {
    path: JsonPath; // "" | "config" | "config.api"
    key: string; // leaf segment ("config", "api")
    label: React.ReactNode;
    children: JsonRouteNode[];
}

/* ─────────────────────────────────────────────────────────────
 * View mode (Split / Visual / Raw)
 * ───────────────────────────────────────────────────────────── */

export type JsonEditorViewMode = "split" | "visual" | "raw";

/* ─────────────────────────────────────────────────────────────
 * Editing permissions + callbacks
 * ───────────────────────────────────────────────────────────── */

export interface JsonEditorPermissions {
    canAdd?: boolean;
    canDelete?: boolean;
    canViewRaw?: boolean;
    canEditRaw?: boolean;

    /**
     * Keys/paths in this shape cannot be deleted even if canDelete is true.
     * (treated as "locked")
     */
    defaultShape?: JsonObject;

    /**
     * Optional finer-grain locks by wildcard.
     * If true, this key/path cannot be added/deleted/edited.
     */
    lockPaths?: JsonWildcard[];
}

export type JsonEditorEditAction = "add" | "delete" | "edit" | "edit-raw";

export interface JsonEditorEditMeta {
    action: JsonEditorEditAction;

    /** the page (object route) currently being edited */
    route: JsonPath;

    /** the exact key path being changed (field path) */
    path: JsonPath;

    /** parent object path of the key */
    parent: JsonPath;

    /** leaf key (segment) */
    key: string;
}

export interface JsonEditorCallbacks {
    onAdd?: (nextRoot: JsonObject, meta: JsonEditorEditMeta) => void;
    onDelete?: (nextRoot: JsonObject, meta: JsonEditorEditMeta) => void;
    onEdit?: (nextRoot: JsonObject, meta: JsonEditorEditMeta) => void;
}

/* ─────────────────────────────────────────────────────────────
 * Resolved field shape (for renderField hook)
 * ───────────────────────────────────────────────────────────── */

export interface JsonEditorResolvedField {
    path: JsonPath; // "config.apiEndpoint"
    key: string; // "apiEndpoint"
    value: JsonValue; // current value
    valueType: "string" | "number" | "boolean" | "null" | "object" | "array";
    variant?: JsonEditorVariantSpec; // resolved from fieldMap/defaults/etc
    hidden?: boolean; // from include/exclude
}

/* ─────────────────────────────────────────────────────────────
 * Variant props (the actual editor surface)
 * ───────────────────────────────────────────────────────────── */

/**
 * This is the "shared" props contract for the JSON editor variant UI.
 *
 * NOTE:
 * - `title` is purely UI (header text)
 * - `schema` is NOT a title — it’s a schema id/key for validation (later use)
 */
export interface ShadcnJsonEditorVariantProps extends Pick<
    VariantBaseProps<JsonObject | undefined>,
    "value" | "onValue" | "error" | "disabled" | "readOnly"
> {
    /** Header title (UI only) */
    title?: React.ReactNode;

    /** Optional schema id/key or raw JSON Schema object for validation */
    schema?: string | JsonObject;

    /** Primary config */
    fieldMap?: JsonEditorFieldMap;
    layout?: JsonEditorLayoutMap;
    defaults?: JsonEditorDefaults;

    /** Navigation derived from JSON structure */
    nav?: JsonEditorNavOptions;

    /** include/exclude for routes + fields */
    filters?: JsonEditorFilters;

    /** permissions + locks */
    permissions?: JsonEditorPermissions;

    /** callbacks */
    callbacks?: JsonEditorCallbacks;

    /**
     * Page rendering mode:
     * - "accordion": page sections expand/collapse in main panel
     * - "popover": nested objects open as overlays (optional UX)
     */
    mode?: "accordion" | "popover";

    /**
     * Routing:
     * - route: controlled current page
     * - defaultRoute: uncontrolled initial page (overrides nav.defaultRoute)
     * - onRouteChange: called whenever the editor navigates
     */
    route?: JsonPath;
    defaultRoute?: JsonPath;
    onRouteChange?: (route: JsonPath) => void;

    /**
     * View mode (top toggle):
     * - "split": raw sidebar + visual editor (default)
     * - "visual": visual editor only
     * - "raw": raw editor only
     *
     * If viewMode is provided, it is controlled.
     * Otherwise, the defaultViewMode seeds the internal state.
     */
    viewMode?: JsonEditorViewMode;
    defaultViewMode?: JsonEditorViewMode;
    onViewModeChange?: (mode: JsonEditorViewMode) => void;

    /** Close button intent (optional). Actual close UI is controlled by the wrapper (index.tsx). */
    onClose?: () => void;

    /** Visual (editor-level styling) */
    className?: string;
    contentClassName?: string;
    navClassName?: string;

    /**
     * Optional hooks to customize nav + page rendering.
     */
    renderRouteLabel?: (ctx: {
        node: JsonRouteNode;
        active: boolean;
    }) => React.ReactNode;
    renderField?: (ctx: {
        field: JsonEditorResolvedField;
        route: JsonPath;
    }) => React.ReactNode;

    // icons & controls (popover trigger only)
    leadingIcons?: React.ReactNode[];
    trailingIcons?: React.ReactNode[];
    icon?: React.ReactNode;
    iconGap?: number;
    leadingIconSpacing?: number;
    trailingIconSpacing?: number;

    leadingControl?: React.ReactNode;
    trailingControl?: React.ReactNode;
    leadingControlClassName?: string;
    trailingControlClassName?: string;

    joinControls?: boolean;
    extendBoxToControls?: boolean;

    triggerClassName?: string;
}

/* ─────────────────────────────────────────────────────────────
 * Index wrapper (popover/accordion + trigger + standalone wiring)
 * ───────────────────────────────────────────────────────────── */

/**
 * Wrapper mode:
 * - "popover": show trigger + popover
 * - "accordion": inline panel that can expand/collapse
 */
export type JsonEditorMode = "popover" | "accordion";

/**
 * Typed to match your shadcn button variants/sizes.
 * If your project differs, change these unions here once.
 */
export type JsonEditorTriggerVariant =
    | "default"
    | "destructive"
    | "outline"
    | "secondary"
    | "ghost"
    | "link";

export type JsonEditorTriggerSize = "default" | "sm" | "lg" | "icon";

/**
 * Exposed ref handle from index.tsx wrapper (not the inner editor).
 * The wrapper controls popover open/close; it can also expose the inner editor ref.
 */
export interface JsonEditorIndexHandle {
    open: () => void;
    close: () => void;
    toggle: () => void;
    editor: React.RefObject<any>;
}

/**
 * Standalone wiring:
 * - caller provides root/onRoot directly
 */
export type JsonEditorStandaloneWiring = {
    root: JsonObject;
    onRoot: (nextRoot: JsonObject, detail?: any) => void;

    value?: never;
    onValue?: never;
};

/**
 * Variant wiring:
 * - InputField variant uses value/onValue
 */
export type JsonEditorVariantWiring = Pick<
    VariantBaseProps<JsonObject | undefined>,
    "value" | "onValue" | "disabled" | "readOnly" | "error" | "size" | "density"
> & {
    root?: never;
    onRoot?: never;
};

/**
 * Props for the exported component (index.tsx):
 * - accepts standalone OR variant wiring
 * - wrapper owns mode/open/trigger UI
 * - editor-specific props are passed through, without redefining a second type list
 *
 * IMPORTANT:
 * - wrapper uses `wrapperClassName` (outer container)
 * - editor uses `className` (inner editor surface)
 */
export interface JsonEditorWrapperProps {
    /** Wrapper mode (popover vs accordion). */
    mode?: JsonEditorMode;

    /** Trigger UI (popover mode) */
    triggerLabel?: React.ReactNode;
    triggerVariant?: JsonEditorTriggerVariant;
    triggerSize?: JsonEditorTriggerSize;

    /** Popover sizing/skin */
    popoverClassName?: string;

    /** Inline/accordion container class */
    panelClassName?: string;

    /** Outer wrapper class */
    wrapperClassName?: string;

    /** Optional: controlled popover open state */
    open?: boolean;
    onOpenChange?: (open: boolean) => void;

    /** Accessibility (useful when rendered as an InputField variant) */
    id?: string;
    describedBy?: string;

    /** Called when the wrapper closes (popover close / accordion hide). */
    onClose?: () => void;
}

/**
 * Single source of truth for what index.tsx accepts:
 * - (standalone OR variant wiring)
 * - wrapper props
 * - editor props (minus a few keys owned by wrapper)
 */
export type ShadcnJsonEditorProps = (
    | JsonEditorStandaloneWiring
    | JsonEditorVariantWiring
) &
    JsonEditorWrapperProps &
    Omit<
        ShadcnJsonEditorVariantProps,
        | "onValue"
        | "value"
        | "disabled"
        | "readOnly"
        | "error"
        | "size"
        | "density"
        | "onClose"
    >;
```

---
#### 14


` File: packages/form-palette/src/presets/shadcn-variants/keyvalue.tsx`  [↑ Back to top](#index)

```tsx
import * as React from "react";
import type { VariantBaseProps, ChangeDetail } from "@/variants/shared";
import { cn } from "@/lib/utils";

import { Button } from "@/presets/ui/button";
import { Input } from "@/presets/ui/input";
import {
   Dialog,
   DialogContent,
   DialogHeader,
   DialogTitle,
   DialogFooter,
   DialogDescription,
} from "@/presets/ui/dialog";
import { X, Plus, MoreHorizontal, Tag, PenLine } from "lucide-react";

type Size = "sm" | "md" | "lg";
type Density = "compact" | "comfortable" | "loose";

export type KeyValueMap = Record<string, string>;

export interface KV {
   key: string;
   value: string;
}

export interface ShadcnKeyValueVariantProps
   extends Pick<
      VariantBaseProps<KeyValueMap | undefined>,
      "value" | "onValue" | "error" | "disabled" | "readOnly" | "size" | "density"
   > {
   min?: number;
   max?: number;
   minVisible?: number;
   maxVisible?: number;
   showAddButton?: boolean;
   showMenuButton?: boolean;
   placeholder?: React.ReactNode;
   dialogTitle?: React.ReactNode;
   keyLabel?: React.ReactNode;
   valueLabel?: React.ReactNode;
   submitLabel?: React.ReactNode;
   moreLabel?: (count: number) => React.ReactNode;
   emptyLabel?: React.ReactNode;
   className?: string;
   chipsClassName?: string;
   chipClassName?: string;
   renderChip?: (ctx: {
      pair: KV;
      index: number;
      onEdit: () => void;
      onRemove: () => void;
      defaultChip: React.ReactNode;
   }) => React.ReactNode;
}

// ─────────────────────────────────────────────
// Helpers
// ─────────────────────────────────────────────

function mapToItems(map: KeyValueMap | undefined): KV[] {
   if (!map) return [];
   return Object.entries(map).map(([key, value]) => ({
      key,
      value: value ?? "",
   }));
}

function itemsToMap(items: KV[]): KeyValueMap {
   const out: KeyValueMap = {};
   for (const { key, value } of items) {
      if (!key) continue;
      out[key] = value;
   }
   return out;
}

function clampVisible(
    total: number,
    minVisible: number,
    maxVisible: number
): number {
    if (total === 0) return 0;
    const clampedMax = Math.max(minVisible, maxVisible);
    return Math.min(total, clampedMax);
}

function sizeClasses(size?: Size) {
    switch (size) {
        case "sm":
            return "h-8 text-xs";
        case "lg":
            return "h-11 text-base";
        default:
            return "h-9 text-sm";
    }
}
function densityPadding(density?: Density) {
   switch (density) {
      case "compact":
         return "py-1 px-2 gap-1.5";
      case "loose":
         return "py-3 px-3 gap-3";
      case "comfortable":
      default:
         return "py-1 px-3 gap-2";
   }
}

function defaultMoreLabel(count: number): React.ReactNode {
   return `+${count} more`;
}

// ─────────────────────────────────────────────
// Component
// ─────────────────────────────────────────────

export const ShadcnKeyValueVariant = React.forwardRef<
   HTMLDivElement,
   ShadcnKeyValueVariantProps
>(function ShadcnKeyValueVariant(props, _ref) {
   const {
      value,
      onValue,
      error,
      disabled,
      readOnly,
      size,
      density,

      min = 0,
      max = Infinity,
      minVisible = 0,
      maxVisible = 6,

      showAddButton = true,
      showMenuButton = true,

      placeholder,
      dialogTitle = "Edit Item",
      keyLabel = "Key",
      valueLabel = "Value",
      submitLabel = "Save Changes",
      moreLabel = defaultMoreLabel,
      emptyLabel = "No items added",

      className,
      chipsClassName,
      chipClassName,
      renderChip,
   } = props;

   const isDisabled = disabled || readOnly;

   const items: KV[] = React.useMemo(
      () => mapToItems(value),
      [value]
   );

   const [dialogOpen, setDialogOpen] = React.useState(false);
   const [editingIndex, setEditingIndex] = React.useState<number | null>(
      null
   );
   const [draft, setDraft] = React.useState<KV>({ key: "", value: "" });

   const canAdd = items.length < max;
   const canDelete = items.length > min;

   // visible vs overflow
   const visibleCount = clampVisible(
      items.length,
      minVisible,
      maxVisible
   );
   const visibleItems = items.slice(0, visibleCount);
   const overflowCount = Math.max(0, items.length - visibleCount);

   // ────────────────────────────────
   // Change Logic
   // ────────────────────────────────

   const commitItems = React.useCallback(
      (next: KV[], meta: ChangeDetail["meta"]) => {
         if (!onValue) return;

         const nextMap = itemsToMap(next);
         const detail: ChangeDetail = {
            source: "variant",
            raw: next,
            nativeEvent: undefined,
            meta,
         };
         onValue(nextMap, detail);
      },
      [onValue]
   );

   const openForNew = React.useCallback(() => {
      if (isDisabled || !canAdd) return;
      setEditingIndex(null);
      setDraft({ key: "", value: "" });
      setDialogOpen(true);
   }, [isDisabled, canAdd]);

   const openForEdit = React.useCallback(
      (index: number) => {
         if (isDisabled) return;
         const item = items[index];
         if (!item) return;
         setEditingIndex(index);
         setDraft(item);
         setDialogOpen(true);
      },
      [isDisabled, items]
   );

   const handleDelete = React.useCallback(() => {
      if (editingIndex == null) return;
      if (!canDelete) return;

      const next = items.slice();
      next.splice(editingIndex, 1);

      setDialogOpen(false);
      commitItems(next, {
         action: "delete",
         index: editingIndex,
      });
   }, [editingIndex, items, canDelete, commitItems]);

   const handleSubmit = React.useCallback(() => {
      const trimmedKey = draft.key.trim();
      const trimmedValue = draft.value;

      if (!trimmedKey) return;

      let next = items.slice();

      if (editingIndex != null) {
         // edit
         next[editingIndex] = { key: trimmedKey, value: trimmedValue };
      } else {
         // add / upsert
         const existingIndex = next.findIndex(
            (kv) => kv.key === trimmedKey
         );
         if (existingIndex !== -1) {
            next[existingIndex] = {
               key: trimmedKey,
               value: trimmedValue,
            };
         } else {
            if (!canAdd) return;
            next.push({ key: trimmedKey, value: trimmedValue });
         }
      }

      setDialogOpen(false);
      commitItems(next, {
         action: editingIndex != null ? "edit" : "add",
         index: editingIndex ?? next.length - 1,
      });
   }, [draft, items, editingIndex, canAdd, commitItems]);

   const handleQuickRemove = React.useCallback(
      (index: number) => {
         if (isDisabled || !canDelete) return;
         const next = items.slice();
         next.splice(index, 1);
         commitItems(next, { action: "delete", index });
      },
      [isDisabled, canDelete, items, commitItems]
   );

   // ────────────────────────────────
   // Visuals
   // ────────────────────────────────

   const sizeCls = sizeClasses(size as Size | undefined);
   const densityCls = densityPadding(density as Density | undefined);

   const renderChipNode = (pair: KV, index: number) => {
      const baseChip = (
         <button
            type="button"
            key={index}
            className={cn(
               "group inline-flex items-center gap-1.5 rounded-md",
               "bg-secondary/50 border border-transparent",
               "px-2 py-1 text-xs transition-all duration-200",
               "hover:bg-secondary hover:border-border/50 hover:shadow-sm",
               "animate-in fade-in zoom-in-95 fill-mode-both",
               isDisabled && "opacity-50 cursor-not-allowed",
               chipClassName
            )}
            onClick={() => openForEdit(index)}
            disabled={isDisabled}
         >
            <span className="font-semibold text-foreground truncate max-w-[120px]">
               {pair.key}
            </span>
            <span className="text-muted-foreground/40">:</span>
            <span className="text-muted-foreground truncate max-w-[120px]">
               {pair.value}
            </span>

            {canDelete && !isDisabled && (
               <div
                  role="button"
                  tabIndex={0}
                  className={cn(
                     "ml-1 flex h-4 w-4 items-center justify-center rounded-full",
                     "text-muted-foreground/60 opacity-0 transition-all",
                     "hover:bg-destructive hover:text-destructive-foreground",
                     "group-hover:opacity-100",
                     "focus-visible:opacity-100 focus-visible:ring-2 focus-visible:ring-ring"
                  )}
                  onClick={(e) => {
                     e.stopPropagation();
                     handleQuickRemove(index);
                  }}
                  onKeyDown={(e) => {
                     if (e.key === "Enter" || e.key === " ") {
                        e.stopPropagation();
                        handleQuickRemove(index);
                     }
                  }}
                  aria-label={`Remove ${pair.key}`}
               >
                  <X className="h-3 w-3" />
               </div>
            )}
         </button>
      );

      if (!renderChip) return baseChip;

      return renderChip({
         pair,
         index,
         onEdit: () => openForEdit(index),
         onRemove: () => handleQuickRemove(index),
         defaultChip: baseChip,
      });
   };

   const hasItems = items.length > 0;

   // ────────────────────────────────
   // Dialog
   // ────────────────────────────────

   const ManageDialog = (
      <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
         <DialogContent className="sm:max-w-[425px]">
            <DialogHeader>
               <DialogTitle className="flex items-center gap-2">
                  <PenLine className="h-4 w-4 text-muted-foreground" />
                  {dialogTitle}
               </DialogTitle>
               <DialogDescription>
                  {editingIndex !== null ? "Modify the existing key-value pair." : "Add a new key-value pair to the list."}
               </DialogDescription>
            </DialogHeader>

            <div className="grid gap-4 py-4">
               <div className="grid grid-cols-4 items-center gap-4">
                  <label className="text-right text-sm font-medium text-muted-foreground">
                     {keyLabel}
                  </label>
                  <Input
                     value={draft.key}
                     onChange={(e) =>
                        setDraft((prev) => ({
                           ...prev,
                           key: e.target.value,
                        }))
                     }
                     className="col-span-3"
                     autoFocus
                     disabled={isDisabled}
                     placeholder="e.g. Color"
                  />
               </div>
               <div className="grid grid-cols-4 items-center gap-4">
                  <label className="text-right text-sm font-medium text-muted-foreground">
                     {valueLabel}
                  </label>
                  <Input
                     value={draft.value}
                     onChange={(e) =>
                        setDraft((prev) => ({
                           ...prev,
                           value: e.target.value,
                        }))
                     }
                     className="col-span-3"
                     disabled={isDisabled}
                     placeholder="e.g. Blue"
                     onKeyDown={(e) => {
                        if (e.key === 'Enter') handleSubmit();
                     }}
                  />
               </div>
            </div>

            <DialogFooter className="flex sm:justify-between flex-row items-center">
               <div>
                  {editingIndex != null && canDelete && (
                     <Button
                        type="button"
                        variant="destructive"
                        size="sm"
                        onClick={handleDelete}
                        disabled={isDisabled}
                     >
                        Delete
                     </Button>
                  )}
               </div>

               <div className="flex gap-2">
                  <Button
                     type="button"
                     variant="outline"
                     size="sm"
                     onClick={() => setDialogOpen(false)}
                  >
                     Cancel
                  </Button>
                  <Button
                     type="button"
                     size="sm"
                     onClick={handleSubmit}
                     disabled={isDisabled}
                  >
                     {submitLabel}
                  </Button>
               </div>
            </DialogFooter>
         </DialogContent>
      </Dialog>
   );

   // ────────────────────────────────
   // Render
   // ────────────────────────────────

   return (
      <div
         className={cn(
            "group/container w-full",
            isDisabled && "opacity-60 cursor-not-allowed",
            className
         )}
         aria-disabled={isDisabled}
         aria-invalid={error ? "true" : undefined}
      >
         {/* Container mimicking an Input */}
         <div
            className={cn(
               "relative flex w-full flex-wrap items-center rounded-md border border-input bg-background transition-all",
               // Focus within styles to mimic Input focus
               !isDisabled && "focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2 focus-within:ring-offset-background",
               densityCls,
               sizeCls,
               chipsClassName
            )}
         >
            {hasItems ? (
               <>
                  {visibleItems.map((pair, index) =>
                     renderChipNode(pair, index)
                  )}

                  {overflowCount > 0 && (
                     <button
                        type="button"
                        className={cn(
                           "inline-flex h-6 items-center gap-1 rounded-full",
                           "bg-muted px-2 text-[11px] font-medium text-muted-foreground",
                           "hover:bg-muted/80 hover:text-foreground transition-colors"
                        )}
                        onClick={() => {
                           setDialogOpen(true);
                           setEditingIndex(null);
                           setDraft({ key: "", value: "" });
                        }}
                        disabled={isDisabled}
                     >
                        {moreLabel(overflowCount)}
                     </button>
                  )}
               </>
            ) : (
               <div className="flex items-center gap-2 text-muted-foreground/60 select-none">
                  <Tag className="h-3.5 w-3.5" />
                  <span className="text-sm">{placeholder ?? emptyLabel}</span>
               </div>
            )}

            {/* Inline Add Button */}
            {showAddButton && canAdd && !isDisabled && (
               <button
                  type="button"
                  onClick={openForNew}
                  className={cn(
                     "inline-flex h-6 items-center gap-1 rounded-full",
                     "border border-dashed border-muted-foreground/30 px-2",
                     "text-[11px] font-medium text-muted-foreground",
                     "hover:border-primary/50 hover:bg-accent hover:text-accent-foreground transition-all",
                     "focus-visible:ring-2 focus-visible:ring-ring focus-visible:outline-none"
                  )}
               >
                  <Plus className="h-3 w-3" />
                  <span>Add</span>
               </button>
            )}

            {/* Menu/Manage Button */}
            {showMenuButton && hasItems && !isDisabled && (
               <div className="ml-auto pl-1">
                  <button
                     type="button"
                     onClick={() => {
                        // Default behavior: open "Add New"
                        setDialogOpen(true);
                        setEditingIndex(null);
                        setDraft({ key: "", value: "" });
                     }}
                     className="flex h-6 w-6 items-center justify-center rounded-sm text-muted-foreground hover:bg-accent hover:text-accent-foreground"
                     aria-label="Add another"
                  >
                     <MoreHorizontal className="h-4 w-4" />
                  </button>
               </div>
            )}
         </div>

         {/* Error Message Support (Optional usage) */}
         {error && typeof error === 'string' && (
            <p className="mt-1.5 text-xs font-medium text-destructive">
               {error}
            </p>
         )}

         {ManageDialog}
      </div>
   );
});

ShadcnKeyValueVariant.displayName = "ShadcnKeyValueVariant";

export default ShadcnKeyValueVariant;
```

---
#### 15


` File: packages/form-palette/src/presets/shadcn-variants/lister.tsx`  [↑ Back to top](#index)

```tsx
/* ─────────────────────────────────────────────────────────────
 * Public component
 * ───────────────────────────────────────────────────────────── */

import { ListerId, PresetMap } from "@/presets/lister/types";
import { ListerVariantProps } from "@/presets/shadcn-variants/lister/types";
import { ListerProvider } from "@/presets/lister";
import { defaultHost } from "@/presets/shadcn-variants/lister/utils";
import ListerResolvedInner from "@/presets/shadcn-variants/lister/index";

export default function ListerVariant<
    TMode extends "single" | "multiple",
    P extends PresetMap = PresetMap,
    TRaw extends Record<string, any> = any,
    TValue extends ListerId = any,
    TFilters extends Record<string, any> = any,
    TMeta = any,
>(props: ListerVariantProps<TMode, P, TRaw, TValue, TFilters, TMeta>) {
    const { host, presets, remoteDebounceMs, ...rest } = props;
    return (
        <ListerProvider
            host={host ?? defaultHost}
            presets={presets}
            remoteDebounceMs={remoteDebounceMs}
        >
            <ListerResolvedInner {...(rest as any)} />
        </ListerProvider>
    );
}
```

---
#### 16


` File: packages/form-palette/src/presets/shadcn-variants/lister/index.tsx`  [↑ Back to top](#index)

```tsx
// resources/js/presets/shadcn-variants/lister/index.tsx
import * as React from "react";

import { useLister } from "@/presets/lister";
import type {
    ListerApi,
    ListerDefinition,
    ListerId,
    PresetMap,
} from "@/presets/lister/types";

import type { KeyOrFn, ListerVariantProps } from "./types";
import { inferOptionValueKeyFromRawList } from "./utils";
import { makeInlineDef, makeInlinePatch, mergeListerDef } from "./patch";
import ListerInner from "./inner";

function ListerResolvedInner<
    P extends PresetMap,
    TRaw extends Record<string, any>,
    TValue extends ListerId,
    TFilters extends Record<string, any>,
    TMeta,
    TMode extends "single" | "multiple",
>(props: ListerVariantProps<TMode, P, TRaw, TValue, TFilters, TMeta>) {
    const { api } = useLister<P>();

    const {
        def,

        // inline
        endpoint,
        method,
        buildRequest,
        selector,

        optionValue,
        optionLabel,
        optionIcon,
        optionDescription,
        optionDisabled,
        optionGroup,
        optionMeta,

        // ✅ NEW: search overrides
        search,
        searchTarget,

        // data
        value,
        onValue,
        filters,
        mode,
        confirm,
        permissions,

        // ui
        disabled,
        readOnly,
        className,
        placeholder,
        maxDisplayItems,
        panelClassName,
        contentClassName,
        renderTrigger,

        // trigger styling + controls (multi-select parity)
        size,
        density,
        clearable,
        leadingIcons,
        trailingIcons,
        icon,
        iconGap,
        leadingIconSpacing,
        trailingIconSpacing,
        leadingControl,
        trailingControl,
        leadingControlClassName,
        trailingControlClassName,
        joinControls,
        extendBoxToControls,

        // open opts
        title,
        searchMode,
        initialQuery,
        showRefresh,
        refreshMode,
        filtersSpec,
        renderOption,
    } = props as any;

    // standalone inline means: no base def + we actually have an endpoint
    const isStandaloneInline = !def && endpoint != null;

    // infer optionValue ONLY for standalone inline when not provided
    const shouldInferOptionValue =
        isStandaloneInline && optionValue === undefined;

    const [resolvedOptionValue, setResolvedOptionValue] = React.useState<
        KeyOrFn<TRaw, TValue> | undefined
    >(() => optionValue ?? ("id" as any));

    React.useEffect(() => {
        if (optionValue !== undefined) setResolvedOptionValue(optionValue);
    }, [optionValue]);

    React.useEffect(() => {
        if (!shouldInferOptionValue) return;
        if (!endpoint) return;

        let alive = true;

        (async () => {
            const provisional = makeInlineDef<TRaw, TValue, TFilters, TMeta>({
                endpoint,
                method,
                buildRequest,
                selector,
                optionValue: "id" as any,
                optionLabel,
                optionIcon,
                optionDescription,
                optionDisabled,
                optionGroup,
                optionMeta,
            });

            const res = await (api as ListerApi<P>).fetch(
                provisional as any,
                filters as any,
                { query: "", permissions } as any,
            );

            if (!alive) return;

            const rawList = (res?.raw ?? []) as any[];
            const inferred = inferOptionValueKeyFromRawList(rawList, "id");
            setResolvedOptionValue(inferred.key as any);
        })().catch(() => {});

        return () => {
            alive = false;
        };
    }, [
        api,
        endpoint,
        method,
        buildRequest,
        selector,
        filters,
        permissions,
        shouldInferOptionValue,
        optionLabel,
        optionIcon,
        optionDescription,
        optionDisabled,
        optionGroup,
        optionMeta,
    ]);

    // ✅ YOUR RULE:
    // inlineExists is allowed to be always true because optionValue is always resolved.
    const inlineExists =
        endpoint !== undefined ||
        method !== undefined ||
        buildRequest !== undefined ||
        selector !== undefined ||
        resolvedOptionValue !== undefined || // ✅ KEEP THIS (your rule)
        optionLabel !== undefined ||
        optionIcon !== undefined ||
        optionDescription !== undefined ||
        optionDisabled !== undefined ||
        optionGroup !== undefined ||
        optionMeta !== undefined ||
        // ✅ include search override as "inline patch" signal too
        search !== undefined;

    const finalDef = React.useMemo(() => {
        const baseDef = def as
            | ListerDefinition<TRaw, TValue, TFilters, TMeta>
            | undefined;

        if (!inlineExists) return baseDef;

        // no base => must build standalone inline def (requires endpoint)
        if (!baseDef) {
            if (!endpoint) return undefined;

            // ✅ ONLY resolvedOptionValue (no optionValue fallback)
            const ov = (resolvedOptionValue ?? ("id" as any)) as any;

            const built = makeInlineDef<TRaw, TValue, TFilters, TMeta>({
                endpoint,
                method,
                buildRequest,
                selector,
                optionValue: ov,
                optionLabel,
                optionIcon,
                optionDescription,
                optionDisabled,
                optionGroup,
                optionMeta,
            }) as any;

            // ✅ attach search override (if provided)
            if (search !== undefined) built.search = search;

            return built as any;
        }

        // base + inline => ALWAYS merge (your rule)
        const inlinePatch = makeInlinePatch<TRaw, TValue, TFilters, TMeta>({
            endpoint,
            method,
            buildRequest,
            selector,

            // ✅ ONLY resolvedOptionValue (no optionValue fallback)
            optionValue: (resolvedOptionValue ?? ("id" as any)) as any,

            optionLabel,
            optionIcon,
            optionDescription,
            optionDisabled,
            optionGroup,
            optionMeta,
        });

        const merged = mergeListerDef(baseDef, inlinePatch) as any;

        // ✅ attach/override search (if provided)
        if (search !== undefined) merged.search = search;

        return merged as any;
    }, [
        def,
        inlineExists,
        endpoint,
        method,
        buildRequest,
        selector,
        resolvedOptionValue,
        optionLabel,
        optionIcon,
        optionDescription,
        optionDisabled,
        optionGroup,
        optionMeta,
        search,
    ]);

    const openOptions = React.useMemo(() => {
        return {
            title,
            searchMode,
            initialQuery,
            showRefresh,
            refreshMode,
            filtersSpec,
            renderOption,

            // ✅ NEW: allow caller to seed the session searchTarget
            searchTarget,
        } as any;
    }, [
        title,
        searchMode,
        initialQuery,
        showRefresh,
        refreshMode,
        filtersSpec,
        renderOption,
        searchTarget,
    ]);

    if (!finalDef) return null;

    return (
        <ListerInner<P, TRaw, TValue, TFilters, TMeta, any>
            def={finalDef}
            value={value as any}
            onValue={onValue as any}
            filters={filters as any}
            mode={mode as any}
            confirm={confirm as any}
            permissions={permissions as any}
            disabled={disabled}
            readOnly={readOnly}
            className={className}
            placeholder={placeholder}
            maxDisplayItems={maxDisplayItems}
            renderTrigger={renderTrigger}
            contentClassName={contentClassName}
            panelClassName={panelClassName}
            openOptions={openOptions}
            // ✅ forward UI/controls props to inner
            size={size}
            density={density}
            clearable={clearable}
            leadingIcons={leadingIcons}
            trailingIcons={trailingIcons}
            icon={icon}
            iconGap={iconGap}
            leadingIconSpacing={leadingIconSpacing}
            trailingIconSpacing={trailingIconSpacing}
            leadingControl={leadingControl}
            trailingControl={trailingControl}
            leadingControlClassName={leadingControlClassName}
            trailingControlClassName={trailingControlClassName}
            joinControls={joinControls}
            extendBoxToControls={extendBoxToControls}
        />
    );
}

export default ListerResolvedInner;
```

---
#### 17


` File: packages/form-palette/src/presets/shadcn-variants/lister/inner.tsx`  [↑ Back to top](#index)

```tsx
// resources/js/presets/shadcn-variants/lister/inner.tsx
// noinspection DuplicatedCode

import * as React from "react";
import { cn } from "@/lib/utils";

import { Popover, PopoverContent, PopoverTrigger } from "@/presets/ui/popover";
import { ChevronDown, X } from "lucide-react";

import { useLister } from "@/presets/lister";
import type {
    ListerApi,
    ListerDefinition,
    ListerId,
    ListerMode,
    ListerOpenOptions,
    ListerOpenResult,
    ListerSessionId,
    PresetMap,
} from "@/presets/lister/types";

import { ListerPopoverPanel } from "./popover";
import { buildLabelsFromOptions, isSameValue } from "./utils";

type Size = "sm" | "md" | "lg";
type Density = "compact" | "comfortable" | "loose";

function triggerHeight(size?: Size) {
    switch (size) {
        case "sm":
            return "h-8 text-xs";
        case "lg":
            return "h-11 text-base";
        default:
            return "h-9 text-sm";
    }
}

function triggerPadding(density?: Density) {
    switch (density) {
        case "compact":
            return "py-1";
        case "loose":
            return "py-2";
        case "comfortable":
        default:
            return "py-1.5";
    }
}

// ✅ NEW: stable owner key generator (per component mount)
function makeOwnerKey() {
    const anyCrypto = (globalThis as any)?.crypto;
    if (anyCrypto?.randomUUID) return `lister_owner_${anyCrypto.randomUUID()}`;
    return `lister_owner_${Date.now()}_${Math.random().toString(16).slice(2)}`;
}

export type ListerTriggerRenderCtx<
    TRaw extends Record<string, any>,
    TValue extends ListerId,
    TMeta,
    TMode extends ListerMode,
> = {
    mode: TMode;
    value: any;
    selectedOptions: any[] | null;
    placeholder: string;
    maxDisplayItems: number;
    display: React.ReactNode;

    disabled?: boolean;
    readOnly?: boolean;
    isOpen: boolean;

    /** convenience */
    disabledTrigger: boolean;
    hasValue: boolean;

    /** convenience actions */
    clear(): void;
    open(): void;
};

export type ListerInnerProps<
    P extends PresetMap = PresetMap,
    TRaw extends Record<string, any> = any,
    TValue extends ListerId = any,
    TFilters = any,
    TMeta = any,
    TMode extends ListerMode = "single",
> = {
    /** FINAL resolved definition (already merged/ready). Required. */
    def: ListerDefinition<TRaw, TValue, TFilters, TMeta>;

    value: any;
    onValue: (next: any, detail?: any) => void;

    filters?: TFilters;

    mode?: TMode;
    confirm?: TMode extends "single" ? boolean : never;
    permissions?: string[];

    disabled?: boolean;
    readOnly?: boolean;

    /**
     * Extra open options (everything except the things inner controls).
     * Inner always sets: mode, confirm, defaultValue, permissions.
     */
    openOptions?: Omit<
        ListerOpenOptions<TRaw, TValue, TFilters, TMeta, TMode>,
        "mode" | "confirm" | "defaultValue" | "permissions"
    >;

    /** Trigger renderer (custom). */
    renderTrigger?: (
        ctx: ListerTriggerRenderCtx<TRaw, TValue, TMeta, TMode>,
    ) => React.ReactElement;

    placeholder?: string;
    maxDisplayItems?: number;

    // ─────────────────────────────────────────────
    // Trigger styling + controls (mirrors multi-select)
    // ─────────────────────────────────────────────

    size?: Size;
    density?: Density;

    /** Small clear button in trigger when value is non-empty */
    clearable?: boolean;

    leadingIcons?: React.ReactNode[];
    trailingIcons?: React.ReactNode[];
    icon?: React.ReactNode;

    iconGap?: number;
    leadingIconSpacing?: number;
    trailingIconSpacing?: number;

    leadingControl?: React.ReactNode;
    trailingControl?: React.ReactNode;
    leadingControlClassName?: string;
    trailingControlClassName?: string;

    joinControls?: boolean;
    extendBoxToControls?: boolean;

    /**
     * NOTE:
     * - className is used for the overall field wrapper when controls exist.
     * - otherwise it's applied to the trigger.
     */
    className?: string;

    contentClassName?: string;
    panelClassName?: string;
};

export function ListerInner<
    P extends PresetMap = PresetMap,
    TRaw extends Record<string, any> = any,
    TValue extends ListerId = any,
    TFilters = any,
    TMeta = any,
    TMode extends ListerMode = "single",
>(props: ListerInnerProps<P, TRaw, TValue, TFilters, TMeta, TMode>) {
    const {
        def,
        value,
        onValue,
        filters,
        mode: modeProp,
        confirm: confirmProp,
        permissions,
        disabled,
        readOnly,
        openOptions,
        renderTrigger,
        placeholder = "Select…",
        maxDisplayItems = 2,

        size,
        density,
        clearable = true,

        leadingIcons,
        trailingIcons,
        icon,
        iconGap,
        leadingIconSpacing,
        trailingIconSpacing,

        leadingControl,
        trailingControl,
        leadingControlClassName,
        trailingControlClassName,
        joinControls = true,
        extendBoxToControls = true,

        className,
        contentClassName,
        panelClassName,
    } = props;

    const { api, actions, state, store } = useLister<P>();
    const sessionId = state?.sessionId as ListerSessionId | undefined;
    const isOpen = !!state?.isOpen;

    // ✅ NEW: stable owner key (one per mounted input)
    // If you ever decide to allow passing a custom ownerKey from outside, you can set it on openOptions
    // and we’ll adopt it. Otherwise we generate one once.
    const ownerKeyRef = React.useRef<string>(
        (openOptions as any)?.ownerKey ?? makeOwnerKey(),
    );
    React.useEffect(() => {
        const next = (openOptions as any)?.ownerKey as string | undefined;
        if (next) ownerKeyRef.current = next;
    }, [openOptions]);

    // Used ONLY for trigger display when closed.
    const [selectedOptions, setSelectedOptions] = React.useState<any[] | null>(
        null,
    );

    const openingRef = React.useRef(false);

    const mode = (modeProp ?? "single") as TMode;
    const confirm = (mode === "multiple" ? true : !!confirmProp) as any;

    const disabledTrigger = !!(disabled || readOnly);

    const hasValue =
        mode === "multiple"
            ? Array.isArray(value) && value.length > 0
            : value != null && value !== "";

    // Resolve selected options for trigger display (when value changes, or def/filters changes)
    React.useEffect(() => {
        if (!hasValue) {
            setSelectedOptions(null);
            return;
        }

        let alive = true;

        (async () => {
            const res = await (api as ListerApi<P>).fetch(
                def as any,
                filters as any,
                { query: "", permissions } as any,
            );

            if (!alive) return;

            const optionsList = (res?.options ?? []) as any[];

            const byValue = new Map<any, any>();
            for (const o of optionsList) {
                if (!o || o.value == null) continue;
                byValue.set(o.value, o);
            }

            const nextSelected =
                mode === "multiple"
                    ? (Array.isArray(value) ? value : [])
                          .map((v: any) => byValue.get(v))
                          .filter(Boolean)
                    : value != null && value !== ""
                      ? [byValue.get(value)].filter(Boolean)
                      : [];

            // avoid churn
            setSelectedOptions((prev) => {
                const p = prev ?? [];
                const n = nextSelected ?? [];
                const pv = p.map((o) => o?.value);
                const nv = n.map((o) => o?.value);
                return isSameValue(pv, nv) ? prev : nextSelected;
            });
        })().catch(() => {
            // ignore; trigger can still fall back to showing raw value
        });

        return () => {
            alive = false;
        };
    }, [api, def, filters, permissions, mode, value, hasValue]);

    const openSession = React.useCallback(async () => {
        if (disabledTrigger) return;
        if (openingRef.current) return;

        openingRef.current = true;

        try {
            const opts: ListerOpenOptions<
                TRaw,
                TValue,
                TFilters,
                TMeta,
                TMode
            > = {
                ...(openOptions as any),

                // ✅ NEW: stable owner/session key so provider can reuse session
                ownerKey: ownerKeyRef.current as any,

                mode,
                confirm,
                defaultValue: value as any,
                permissions,
            } as any;

            const res = (await (api as ListerApi<P>).open(
                def as any,
                filters as any,
                opts as any,
            )) as unknown as ListerOpenResult<TRaw, TValue, TMeta, TMode>;

            if (res?.reason === "apply") {
                // cache for trigger display
                const snap = (res.details?.options as any[]) ?? null;
                setSelectedOptions(snap);

                // propagate chosen value
                onValue(res.value as any, res.details);
            }
        } finally {
            openingRef.current = false;
        }
    }, [
        api,
        confirm,
        def,
        disabledTrigger,
        filters,
        mode,
        onValue,
        openOptions,
        permissions,
        value,
    ]);

    const clear = React.useCallback(() => {
        if (disabledTrigger) return;

        const next =
            mode === "multiple" ? (undefined as any) : (undefined as any);

        onValue(next, {
            action: "clear",
            source: "variant",
        });

        setSelectedOptions(null);
    }, [disabledTrigger, mode, onValue]);

    const display = React.useMemo(() => {
        return buildLabelsFromOptions({
            mode,
            value,
            selectedOptions,
            placeholder,
            maxItems: maxDisplayItems,
        });
    }, [maxDisplayItems, mode, placeholder, selectedOptions, value]);

    const triggerCtx: ListerTriggerRenderCtx<TRaw, TValue, TMeta, TMode> =
        React.useMemo(
            () => ({
                mode,
                value,
                selectedOptions,
                placeholder,
                maxDisplayItems,
                display,
                disabled,
                readOnly,
                isOpen,
                disabledTrigger,
                hasValue,
                clear,
                open: () => void openSession(),
            }),
            [
                mode,
                value,
                selectedOptions,
                placeholder,
                maxDisplayItems,
                display,
                disabled,
                readOnly,
                isOpen,
                disabledTrigger,
                hasValue,
                clear,
                openSession,
            ],
        );

    // ─────────────────────────────────────────────
    // Trigger visuals (mirrors multi-select default trigger)
    // ─────────────────────────────────────────────

    const heightCls = triggerHeight(size);
    const padCls = triggerPadding(density);

    const resolvedLeadingIcons: React.ReactNode[] = (() => {
        if (leadingIcons && leadingIcons.length) return leadingIcons;
        if (icon) return [icon];
        return [];
    })();

    const resolvedTrailingIcons: React.ReactNode[] = trailingIcons ?? [];

    const baseIconGap = iconGap ?? 4;
    const leadingGap = leadingIconSpacing ?? baseIconGap;
    const trailingGap = trailingIconSpacing ?? baseIconGap;

    const hasLeadingIcons = resolvedLeadingIcons.length > 0;
    const hasTrailingIcons = resolvedTrailingIcons.length > 0;

    const hasLeadingControl = !!leadingControl;
    const hasTrailingControl = !!trailingControl;
    const hasControls = hasLeadingControl || hasTrailingControl;

    const showClear = clearable && hasValue;

    const baseBoxClasses = cn(
        "border-input w-full min-w-0 rounded-md border bg-surfaces-input shadow-xs",
        "transition-[color,box-shadow] outline-none",
        "focus-within:border-ring focus-within:ring-ring/50 focus-within:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
    );

    const DefaultTriggerButton = (
        <button
            type="button"
            disabled={disabledTrigger}
            className={cn(
                "flex w-full items-center justify-between rounded-md border border-input bg-surfaces-input px-3 text-left shadow-xs",
                "focus-visible:outline-none focus-visible:ring-[3px] focus-visible:ring-ring/50 focus-visible:border-ring",
                "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
                heightCls,
                padCls,
                hasControls &&
                    joinControls &&
                    extendBoxToControls &&
                    "border-none shadow-none focus-visible:ring-0 focus-visible:outline-none",
                !hasControls ? className : undefined,
            )}
        >
            <div className="flex w-full items-center justify-between gap-2">
                {/* Left: icons + display */}
                <div className="flex min-w-0 items-center grow gap-2">
                    {hasLeadingIcons && (
                        <span
                            className="flex items-center gap-1 shrink-0"
                            style={{ columnGap: leadingGap }}
                            data-slot="leading-icons"
                        >
                            {resolvedLeadingIcons.map((node, idx) => (
                                <span
                                    key={idx}
                                    className="flex items-center justify-center"
                                >
                                    {node}
                                </span>
                            ))}
                        </span>
                    )}

                    <div className="min-w-0 flex-1 truncate">{display}</div>
                </div>

                {/* Right: clear + trailing icons + chevron */}
                <div className="flex items-center gap-1 shrink-0">
                    {showClear && (
                        <span
                            aria-label="Clear selection"
                            onClick={(e) => {
                                e.stopPropagation();
                                e.preventDefault();
                                clear();
                            }}
                            className="flex h-4 w-4 items-center justify-center rounded hover:bg-muted"
                            data-slot="clear"
                        >
                            <X className="h-3 w-3 pointer-events-none" />
                        </span>
                    )}

                    {hasTrailingIcons && (
                        <span
                            className="flex items-center gap-1"
                            style={{ columnGap: trailingGap }}
                            data-slot="trailing-icons"
                        >
                            {resolvedTrailingIcons.map((node, idx) => (
                                <span
                                    key={idx}
                                    className="flex items-center justify-center"
                                >
                                    {node}
                                </span>
                            ))}
                        </span>
                    )}

                    <ChevronDown className="h-4 w-4 text-muted-foreground" />
                </div>
            </div>
        </button>
    );

    // user trigger
    const userTriggerEl = renderTrigger ? renderTrigger(triggerCtx) : null;

    const TriggerNode =
        renderTrigger && React.isValidElement(userTriggerEl)
            ? React.cloneElement(userTriggerEl as any, {
                  className: cn(
                      (userTriggerEl as any).props?.className,
                      className,
                  ),
              })
            : DefaultTriggerButton;

    // ─────────────────────────────────────────────
    // Popover core
    // ─────────────────────────────────────────────

    const PopoverCore = (
        <Popover
            open={isOpen && !disabledTrigger}
            onOpenChange={(next) => {
                if (disabledTrigger) return;
                if (next) void openSession();
                else if (sessionId) actions.close(sessionId);
            }}
        >
            <PopoverTrigger asChild>{TriggerNode}</PopoverTrigger>

            <PopoverContent
                align="start"
                side="bottom"
                sideOffset={8}
                className={cn(
                    "p-0",
                    "w-(--radix-popover-trigger-width)",
                    "max-h-(--radix-popover-content-available-height)",
                    "max-w-(--radix-popover-content-available-width)",
                    "min-h-[calc(var(--radix-popover-trigger-height)*8)]",
                    contentClassName,
                )}
            >
                {sessionId ? (
                    <ListerPopoverPanel
                        id={sessionId}
                        store={store}
                        mode={mode as any}
                        confirm={!!confirm}
                        className={cn("h-full w-full", panelClassName)}
                    />
                ) : null}
            </PopoverContent>
        </Popover>
    );

    // ─────────────────────────────────────────────
    // Layout modes (mirrors multi-select)
    // ─────────────────────────────────────────────

    // If user fully custom-renders trigger, we won’t force controls layout around it.
    if (renderTrigger) {
        return (
            <div
                data-slot="lister-field"
                className={cn("w-full", className)}
                aria-disabled={disabled ? "true" : undefined}
            >
                {PopoverCore}
            </div>
        );
    }

    // CASE 1: no controls → just the popover core
    if (!hasControls) {
        return (
            <div
                data-slot="lister-field"
                className={cn(
                    "w-full",
                    disabledTrigger && "opacity-50 cursor-not-allowed",
                )}
                aria-disabled={disabledTrigger ? "true" : undefined}
            >
                {PopoverCore}
            </div>
        );
    }

    // CASE 2: controls + joinControls → shared single box
    if (joinControls) {
        const groupClassName = cn(
            "flex items-stretch w-full",
            extendBoxToControls
                ? cn("relative", baseBoxClasses)
                : "relative border-none shadow-none bg-transparent",
            className,
        );

        return (
            <div
                data-slot="lister-field"
                className="w-full"
                aria-disabled={disabledTrigger ? "true" : undefined}
            >
                <div
                    className={groupClassName}
                    data-slot="lister-group"
                    data-disabled={disabledTrigger ? "true" : "false"}
                >
                    {hasLeadingControl && (
                        <div
                            className={cn(
                                "flex items-center px-2",
                                leadingControlClassName,
                            )}
                            data-slot="leading-control"
                        >
                            {leadingControl}
                        </div>
                    )}

                    <div
                        className="flex-1 min-w-0 flex items-stretch"
                        data-slot="lister-region"
                    >
                        {PopoverCore}
                    </div>

                    {hasTrailingControl && (
                        <div
                            className={cn(
                                "flex items-center px-2",
                                trailingControlClassName,
                            )}
                            data-slot="trailing-control"
                        >
                            {trailingControl}
                        </div>
                    )}
                </div>
            </div>
        );
    }

    // CASE 3: controls present, but separate (no joined box)
    return (
        <div
            data-slot="lister-field"
            className={cn(
                "flex items-stretch w-full",
                disabledTrigger && "opacity-50 cursor-not-allowed",
                className,
            )}
            aria-disabled={disabledTrigger ? "true" : undefined}
        >
            {hasLeadingControl && (
                <div
                    className={cn(
                        "flex items-center mr-1",
                        leadingControlClassName,
                    )}
                    data-slot="leading-control"
                >
                    {leadingControl}
                </div>
            )}

            <div className="flex-1 min-w-0" data-slot="lister-region">
                {PopoverCore}
            </div>

            {hasTrailingControl && (
                <div
                    className={cn(
                        "flex items-center ml-1",
                        trailingControlClassName,
                    )}
                    data-slot="trailing-control"
                >
                    {trailingControl}
                </div>
            )}
        </div>
    );
}

export default ListerInner;
```

---
#### 18


` File: packages/form-palette/src/presets/shadcn-variants/lister/patch.ts`  [↑ Back to top](#index)

```ts
// src/presets/shadcn-variants/lister/inline-def.ts

/* ─────────────────────────────────────────────────────────────
 * Inline def builders
 * ───────────────────────────────────────────────────────────── */

import type {
    ListerDefinition,
    ListerId,
    ListerMapping,
    ListerSource,
    Selector,
} from "@/presets/lister/types";
import type { KeyOrFn } from "@/presets/shadcn-variants/lister/types";
import { pick } from "@/presets/shadcn-variants/lister/utils";

/**
 * Full inline def (standalone).
 * NOTE: mapping keys MUST match what mapOptions() reads.
 */
export function makeInlineDef<
    TRaw extends Record<string, any>,
    TValue extends ListerId,
    TFilters,
    TMeta,
    TCtx = any,
>(args: {
    endpoint: string;
    method?: "GET" | "POST";
    buildRequest?: ListerSource<TFilters>["buildRequest"];
    selector?: Selector<TRaw>;

    optionValue: KeyOrFn<TRaw, TValue, TCtx>;
    optionLabel?: KeyOrFn<TRaw, any, TCtx>;
    optionIcon?: KeyOrFn<TRaw, any, TCtx>;
    optionDescription?: KeyOrFn<TRaw, any, TCtx>;
    optionDisabled?: KeyOrFn<TRaw, boolean, TCtx>;
    optionGroup?: KeyOrFn<TRaw, string, TCtx>;
    optionMeta?: KeyOrFn<TRaw, TMeta, TCtx>;
}): ListerDefinition<TRaw, TValue, TFilters, TMeta, TCtx> {
    const mapping = {
        optionValue: (raw: TRaw, ctx: TCtx) =>
            pick(raw as any, args.optionValue as any, ctx)!,

        optionLabel: args.optionLabel
            ? (raw: TRaw, ctx: TCtx) =>
                  pick(raw as any, args.optionLabel as any, ctx)
            : undefined,

        optionIcon: args.optionIcon
            ? (raw: TRaw, ctx: TCtx) =>
                  pick(raw as any, args.optionIcon as any, ctx)
            : undefined,

        optionDescription: args.optionDescription
            ? (raw: TRaw, ctx: TCtx) =>
                  pick(raw as any, args.optionDescription as any, ctx)
            : undefined,

        optionDisabled: args.optionDisabled
            ? (raw: TRaw, ctx: TCtx) =>
                  !!pick(raw as any, args.optionDisabled as any, ctx)
            : undefined,

        optionGroup: (args.optionGroup
            ? (raw: TRaw, ctx: TCtx) =>
                  pick(raw as any, args.optionGroup as any, ctx)
            : undefined) as any,

        optionMeta: args.optionMeta
            ? (raw: TRaw, ctx: TCtx) =>
                  pick(raw as any, args.optionMeta as any, ctx)
            : undefined,
    } satisfies ListerMapping<any, any, any, any>;

    return {
        id: args.endpoint,
        source: {
            endpoint: args.endpoint,
            // IMPORTANT: do not invent defaults here (method is optional upstream)
            method: args.method,
            buildRequest: args.buildRequest,
        },
        selector: args.selector,
        mapping,
    } as any;
}

/**
 * Inline override "patch" to merge into an existing def.
 *
 * IMPORTANT (your rule):
 * - this can be created even if some fields are undefined
 * - merge logic will ignore undefined keys at the leaf level
 * - mapping is always present (even empty) so it can merge
 *
 * NOTE:
 * - No invented defaults (method stays undefined unless provided).
 * - endpoint is optional, so you can patch JUST mapping/selector.
 */
export function makeInlinePatch<
    TRaw extends Record<string, any>,
    TValue extends ListerId,
    TFilters,
    TMeta,
    TCtx = any,
>(args: {
    endpoint?: string;
    method?: "GET" | "POST";
    buildRequest?: ListerSource<TFilters>["buildRequest"];
    selector?: Selector<TRaw>;

    optionValue?: KeyOrFn<TRaw, TValue, TCtx>;
    optionLabel?: KeyOrFn<TRaw, any, TCtx>;
    optionIcon?: KeyOrFn<TRaw, any, TCtx>;
    optionDescription?: KeyOrFn<TRaw, any, TCtx>;
    optionDisabled?: KeyOrFn<TRaw, boolean, TCtx>;
    optionGroup?: KeyOrFn<TRaw, string, TCtx>;
    optionMeta?: KeyOrFn<TRaw, TMeta, TCtx>;
}): any {
    const mapping: any = {};

    if (args.optionValue)
        mapping.optionValue = (raw: TRaw, ctx: TCtx) =>
            pick(raw as any, args.optionValue as any, ctx)!;

    if (args.optionLabel)
        mapping.optionLabel = (raw: TRaw, ctx: TCtx) =>
            pick(raw as any, args.optionLabel as any, ctx);

    if (args.optionIcon)
        mapping.optionIcon = (raw: TRaw, ctx: TCtx) =>
            pick(raw as any, args.optionIcon as any, ctx);

    if (args.optionDescription)
        mapping.optionDescription = (raw: TRaw, ctx: TCtx) =>
            pick(raw as any, args.optionDescription as any, ctx);

    if (args.optionDisabled)
        mapping.optionDisabled = (raw: TRaw, ctx: TCtx) =>
            !!pick(raw as any, args.optionDisabled as any, ctx);

    if (args.optionGroup)
        mapping.optionGroup = (raw: TRaw, ctx: TCtx) =>
            pick(raw as any, args.optionGroup as any, ctx);

    if (args.optionMeta)
        mapping.optionMeta = (raw: TRaw, ctx: TCtx) =>
            pick(raw as any, args.optionMeta as any, ctx);

    return {
        id: args.endpoint,
        source: args.endpoint
            ? {
                  endpoint: args.endpoint,
                  // IMPORTANT: do not invent defaults
                  method: args.method,
                  buildRequest: args.buildRequest,
              }
            : undefined,
        selector: args.selector,
        // keep present even if empty (so deep merge can merge into base.mapping)
        mapping,
    };
}

/* ─────────────────────────────────────────────────────────────
 * Deep merge (def + inline)
 * ───────────────────────────────────────────────────────────── */

type AnyObj = Record<string, any>;

function isPlainObject(x: any): x is AnyObj {
    if (x == null || typeof x !== "object") return false;
    const proto = Object.getPrototypeOf(x);
    return proto === Object.prototype || proto === null;
}

/**
 * Deep merge:
 * - merges plain objects
 * - arrays are replaced
 * - undefined does not override
 */
function deepMergeDefined<T>(base: T, patch: any): T {
    if (patch === undefined) return base;

    if (!isPlainObject(base) || !isPlainObject(patch)) {
        if (Array.isArray(patch)) return patch as any;
        return patch as any;
    }

    const out: AnyObj = { ...(base as any) };

    for (const key of Object.keys(patch)) {
        const pv = patch[key];
        if (pv === undefined) continue;

        const bv = (base as any)[key];

        if (Array.isArray(pv)) {
            out[key] = pv;
            continue;
        }

        if (isPlainObject(bv) && isPlainObject(pv)) {
            out[key] = deepMergeDefined(bv, pv);
            continue;
        }

        out[key] = pv;
    }

    return out as T;
}

/**
 * Merge rule:
 * - if both are non-null/undefined, merge
 * - empty object still counts as "exists" and will merge
 */
export function mergeListerDef<
    TRaw,
    TValue extends ListerId,
    TFilters,
    TMeta,
    TCtx = any,
>(
    baseDef: ListerDefinition<TRaw, TValue, TFilters, TMeta, TCtx> | undefined,
    inlineDef: any | undefined,
): ListerDefinition<TRaw, TValue, TFilters, TMeta, TCtx> | undefined {
    if (baseDef == null) return inlineDef as any;
    if (inlineDef == null) return baseDef;
    return deepMergeDefined(baseDef, inlineDef);
}
```

---
#### 19


` File: packages/form-palette/src/presets/shadcn-variants/lister/popover.tsx`  [↑ Back to top](#index)

```tsx
import type { ListerMode, ListerSessionId, ListerStoreState } from "@/presets/lister/types";
import { useLister } from "@/presets/lister";
import { cn } from "@/lib/utils";
import { FooterBar, OptionList, SearchBar } from "@/presets/lister/lister-ui";
import { Separator } from "@/presets/ui/separator";
import * as React from "react";

export function ListerPopoverPanel(props: {
    className?: string;
    id: ListerSessionId;
    store: ListerStoreState;
    mode: ListerMode;
    confirm: boolean;
}) {
    const { className, id, store, mode, confirm } = props;

    const { actions } = useLister<any>();

    return (
        <div
            className={cn(
                "flex flex-col overflow-hidden",

                // ✅ width: match trigger width (Radix popover var)
                "w-(--radix-popover-trigger-width)",

                // ✅ height: scale from trigger height, but keep sane bounds
                // (pick one: fixed max, or available-height aware)
                "min-h-[calc(var(--radix-popover-trigger-height)*8)]",
                "max-h-[min(520px,var(--radix-popover-content-available-height))]",

                className,
            )}
        >
            <div className="">
                <SearchBar id={id} store={store} />
            </div>

            <Separator />

            <div className="min-h-0 flex-1 relative overflow-y-auto">
                <OptionList id={id} className="h-full max-h-full" />
            </div>

            <Separator />

            <div className="">
                <FooterBar
                    id={id}
                    mode={mode}
                    confirm={confirm}
                    onClear={() => actions.clear(id)}
                    onCancel={() => actions.cancel(id)}
                    onApply={() => actions.apply(id)}
                />
            </div>
        </div>
    );
}
```

---
#### 20


` File: packages/form-palette/src/presets/shadcn-variants/lister/types.ts`  [↑ Back to top](#index)

```ts
// resources/js/presets/shadcn-variants/lister/types.ts
import type * as React from "react";

import type {
    ListerDefinition,
    ListerFilterSpec,
    ListerId,
    ListerMode,
    ListerOpenOptions,
    ListerProviderHost,
    ListerSearchTarget,
    ListerSource,
    ListerValueForMode,
    PresetMap,
    Selector,
} from "@/presets/lister/types";

/* ─────────────────────────────────────────────────────────────
 * Base props
 * ───────────────────────────────────────────────────────────── */

export type ListerFieldBaseProps<TValue> = {
    value?: TValue;
    onValue?: (next: TValue, detail?: any) => void;
    disabled?: boolean;
    readOnly?: boolean;
    className?: string;
    placeholder?: string;
};

/**
 * Key or function mapping.
 * IMPORTANT: ctx-aware because your engine mapping functions receive (raw, ctx).
 */
export type KeyOrFn<TRaw, TOut, TCtx = any> =
    | (keyof TRaw & string)
    | ((raw: TRaw, ctx: TCtx) => TOut);

export type ListerInlineSource<TFilters = any> = Pick<
    ListerSource<TFilters>,
    "endpoint" | "method" | "buildRequest"
>;

/* ─────────────────────────────────────────────────────────────
 * Trigger customization (mirrors inner.tsx)
 * ───────────────────────────────────────────────────────────── */

export type ListerSize = "sm" | "md" | "lg";
export type ListerDensity = "compact" | "comfortable" | "loose";

export type ListerTriggerRenderCtx<
    TRaw extends Record<string, any>,
    TValue extends ListerId,
    TMeta,
    TMode extends ListerMode,
> = {
    mode: TMode;
    value: any;
    selectedOptions: any[] | null;
    placeholder: string;
    maxDisplayItems: number;
    display: React.ReactNode;

    disabled?: boolean;
    readOnly?: boolean;
    isOpen: boolean;

    /** convenience */
    disabledTrigger: boolean;
    hasValue: boolean;

    /** convenience actions */
    clear(): void;
    open(): void;
};

/* ─────────────────────────────────────────────────────────────
 * Variant props
 * ───────────────────────────────────────────────────────────── */
export type ListerVariantProps<
    TMode extends ListerMode,
    P extends PresetMap = PresetMap,
    TRaw extends Record<string, any> = any,
    TValue extends ListerId = any,
    TFilters extends Record<string, any> = Record<string, any>,
    TMeta = any,
    TCtx = any,
    TSearchColumn extends string = string,
> = ListerFieldBaseProps<ListerValueForMode<TValue, TMode>> & {
    host?: ListerProviderHost;
    presets?: P;
    remoteDebounceMs?: number;

    /** Final/base definition */
    def?: ListerDefinition<TRaw, TValue, TFilters, TMeta, TCtx, TSearchColumn>;

    /** Inline overrides (any one can exist => inline exists) */
    endpoint?: string;
    method?: "GET" | "POST";
    buildRequest?: ListerSource<TFilters>["buildRequest"];
    selector?: Selector<TRaw>;

    /** ✅ Search spec override (feeds session.searchSpec) */
    search?: ListerDefinition<
        TRaw,
        TValue,
        TFilters,
        TMeta,
        TCtx,
        TSearchColumn
    >["search"];

    /**
     * ✅ Initial/seed search target (feeds session.searchTarget)
     * If omitted, provider will derive it from `search.default` (if present) or fallback.
     */
    searchTarget?: ListerSearchTarget;

    /** Inline mapping overrides (ctx-aware) */
    optionValue?: KeyOrFn<TRaw, TValue, TCtx>;
    optionLabel?: KeyOrFn<TRaw, string, TCtx>;
    optionIcon?: KeyOrFn<TRaw, any, TCtx>;
    optionDescription?: KeyOrFn<TRaw, string, TCtx>;
    optionDisabled?: KeyOrFn<TRaw, boolean, TCtx>;
    optionGroup?: KeyOrFn<TRaw, string, TCtx>;
    optionMeta?: KeyOrFn<TRaw, TMeta, TCtx>;

    filters?: TFilters;

    mode?: TMode;
    confirm?: TMode extends "single" ? boolean : never;
    permissions?: string[];

    // ─────────────────────────────────────────────
    // Open options (passed through to inner/open)
    // ─────────────────────────────────────────────

    title?: string;
    searchMode?: ListerOpenOptions<
        TRaw,
        TValue,
        TFilters,
        TMeta,
        TMode
    >["searchMode"];
    initialQuery?: string;
    showRefresh?: boolean;
    refreshMode?: ListerOpenOptions<
        TRaw,
        TValue,
        TFilters,
        TMeta,
        TMode
    >["refreshMode"];

    /** Filters */
    filtersSpec?: ListerFilterSpec<TFilters>;

    renderOption?: ListerOpenOptions<
        TRaw,
        TValue,
        TFilters,
        TMeta,
        TMode
    >["renderOption"];

    // ─────────────────────────────────────────────
    // Trigger display
    // ─────────────────────────────────────────────

    maxDisplayItems?: number;

    renderTrigger?: (
        ctx: ListerTriggerRenderCtx<TRaw, TValue, TMeta, TMode>,
    ) => React.ReactElement;

    // ─────────────────────────────────────────────
    // Styling + controls (mirrors multi-select semantics)
    // ─────────────────────────────────────────────

    size?: ListerSize;
    density?: ListerDensity;

    clearable?: boolean;

    leadingIcons?: React.ReactNode[];
    trailingIcons?: React.ReactNode[];
    icon?: React.ReactNode;

    iconGap?: number;
    leadingIconSpacing?: number;
    trailingIconSpacing?: number;

    leadingControl?: React.ReactNode;
    trailingControl?: React.ReactNode;
    leadingControlClassName?: string;
    trailingControlClassName?: string;

    joinControls?: boolean;
    extendBoxToControls?: boolean;

    // ─────────────────────────────────────────────
    // Panel / content wrappers
    // ─────────────────────────────────────────────

    panelClassName?: string;
    contentClassName?: string;
};
```

---
#### 21


` File: packages/form-palette/src/presets/shadcn-variants/lister/utils.tsx`  [↑ Back to top](#index)

```tsx
// resources/js/presets/shadcn-variants/lister/utils.tsx
import * as React from "react";
import type { ListerMode, ListerProviderHost } from "@/presets/lister/types";
import type { KeyOrFn } from "./types";

/* ─────────────────────────────────────────────────────────────
 * pick + equality
 * ───────────────────────────────────────────────────────────── */

function pick<TRaw extends Record<string, any>, TOut, TCtx = any>(
    raw: TRaw,
    keyOrFn: KeyOrFn<TRaw, TOut, TCtx> | undefined,
    ctx: TCtx,
): TOut | undefined {
    if (!keyOrFn) return undefined;
    if (typeof keyOrFn === "function") return keyOrFn(raw, ctx);
    return raw?.[keyOrFn] as TOut;
}

function isSameValue(a: any, b: any) {
    if (a === b) return true;
    const aa = Array.isArray(a);
    const bb = Array.isArray(b);
    if (aa !== bb) return false;
    if (aa && bb) {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
        return true;
    }
    return false;
}

/* ─────────────────────────────────────────────────────────────
 * optionValue inference helpers (inline endpoint mode)
 * ───────────────────────────────────────────────────────────── */

function isScalarIdLike(v: any) {
    const t = typeof v;
    if (t !== "string" && t !== "number") return false;
    return !(t === "string" && v.trim() === "");
}

function uniqRatio(values: any[]) {
    const filtered = values.filter((v) => v != null && v !== "");
    if (!filtered.length) return 0;
    const set = new Set(
        filtered.map((v) => (typeof v === "string" ? v.trim() : v)),
    );
    return set.size / filtered.length;
}

function scoreKey(key: string, presence: number, uniq: number) {
    const k = key.toLowerCase();

    let bonus = 0;
    if (k === "id") bonus += 10;
    if (k === "_id") bonus += 7;
    if (k.includes("uuid")) bonus += 7;
    if (k.includes("slug")) bonus += 5;
    if (k.includes("code")) bonus += 4;
    if (k.includes("key")) bonus += 3;
    if (k.endsWith("id") && k !== "id") bonus += 4;

    if (k.includes("name") || k.includes("title") || k.includes("label")) {
        bonus -= 2;
    }

    const base = presence * 4 + uniq * 10;
    return base + bonus;
}

function inferOptionValueKeyFromRawList(rawList: any[], fallback = "id") {
    const sample = Array.isArray(rawList) ? rawList.slice(0, 10) : [];
    if (!sample.length) return { key: fallback, inferred: false };

    const common = ["id", "value", "key", "uuid", "slug", "_id", "code"];
    for (const k of common) {
        const vals = sample.map((r) => r?.[k]).filter(isScalarIdLike);
        const presence = vals.length / sample.length;
        const uniq = uniqRatio(vals);
        if (presence >= 0.9 && uniq >= 0.95) return { key: k, inferred: true };
    }

    const keys = new Set<string>();
    for (const r of sample) {
        if (!r || typeof r !== "object") continue;
        for (const k of Object.keys(r)) keys.add(k);
    }

    let bestKey = fallback;
    let bestScore = -Infinity;
    let bestPresence = 0;
    let bestUniq = 0;

    for (const k of keys) {
        const vals = sample.map((r) => r?.[k]).filter(isScalarIdLike);
        const presence = vals.length / sample.length;
        if (presence < 0.7) continue;

        const uniq = uniqRatio(vals);
        const score = scoreKey(k, presence, uniq);

        if (score > bestScore) {
            bestScore = score;
            bestKey = k;
            bestPresence = presence;
            bestUniq = uniq;
        }
    }

    if (bestPresence >= 0.9 && bestUniq >= 0.95) {
        return { key: bestKey, inferred: true };
    }

    return { key: fallback, inferred: false };
}

/* ─────────────────────────────────────────────────────────────
 * Trigger display
 * ───────────────────────────────────────────────────────────── */

function buildLabelsFromOptions(args: {
    mode: ListerMode;
    value: any;
    selectedOptions: any[] | null;
    placeholder: string;
    maxItems: number;
}) {
    const { mode, value, selectedOptions, placeholder, maxItems } = args;

    const labelFor = (opt: any) =>
        String(
            opt?.label ??
                opt?.meta?.label ??
                opt?.title ??
                opt?.name ??
                opt?.value ??
                "",
        ).trim();

    const labels = (() => {
        if (mode === "multiple") {
            const arr = Array.isArray(value) ? value : [];
            const map = new Map<any, string>();
            for (const o of selectedOptions ?? []) {
                if (o?.value == null) continue;
                const lbl = labelFor(o);
                if (lbl) map.set(o.value, lbl);
            }
            return arr.map((v) => map.get(v) ?? String(v));
        }

        if (value == null || value === "") return [];
        const opt = selectedOptions;
        const lbl = opt ? labelFor(opt) : "";
        return [lbl || String(value)];
    })();

    if (!labels.length) {
        return <span className="text-muted-foreground">{placeholder}</span>;
    }

    if (mode !== "multiple") {
        return <span className="truncate">{labels[0]}</span>;
    }

    const shown = labels.slice(0, Math.max(1, maxItems));
    const remaining = labels.length - shown.length;

    return (
        <span className="truncate">
            {shown.join(", ")}
            {remaining > 0 ? ` ..${remaining} more` : ""}
        </span>
    );
}

/* ─────────────────────────────────────────────────────────────
 * Defaults
 * ───────────────────────────────────────────────────────────── */

const defaultHost: ListerProviderHost = {
    can: () => true,
    log: () => {},
};

export {
    pick,
    isSameValue,
    inferOptionValueKeyFromRawList,
    buildLabelsFromOptions,
    defaultHost,
};
```

---
#### 22


` File: packages/form-palette/src/presets/shadcn-variants/multiselect.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/multi-select.tsx
// noinspection DuplicatedCode

import * as React from "react";
import type { VariantBaseProps, ChangeDetail } from "@/variants/shared";
import { cn } from "@/lib/utils";
import { Input } from "@/presets/ui/input";
import { Checkbox } from "@/presets/ui/checkbox";
import { Popover, PopoverTrigger, PopoverContent } from "@/presets/ui/popover";
import { ChevronDown, Search, X } from "lucide-react";
import { Badge } from "@/presets/ui/badge";
import {
    removeSelectValue,
    SelectionSummary,
} from "@/variants/helpers/selection-summary";
import { globalNormalizeOptions } from "@/lib/normalise-options";

type SelectPrimitive = string | number;

type Size = "sm" | "md" | "lg";
type Density = "compact" | "comfortable" | "loose";

export type MultiSelectOption =
    | SelectPrimitive
    | {
          label?: React.ReactNode;
          value?: SelectPrimitive;
          description?: React.ReactNode;
          disabled?: boolean;
          icon?: React.ReactNode;
          [key: string]: any;
      };

type NormalizedMultiItem = {
    key: string;
    value: SelectPrimitive;
    labelNode: React.ReactNode;
    labelText: string;
    description?: React.ReactNode;
    disabled?: boolean;
    icon?: React.ReactNode;
    /** Option-level renderer (falls back to global renderOption) */
    render?: (...args: any[]) => React.ReactNode;
    raw: MultiSelectOption;
};

type MultiSelectBaseProps = Pick<
    VariantBaseProps<SelectPrimitive[] | undefined>,
    "value" | "onValue" | "error" | "disabled" | "readOnly" | "size" | "density"
> & {
    /**
     * Options for the multi-select.
     *
     * You can pass:
     * - primitives: ["ng", "gh", "ke"]
     * - objects:    [{ label, value, ...extra }]
     */
    options?: MultiSelectOption[];

    /**
     * Automatically capitalise the first letter of the label
     * (when the resolved label is a string).
     */
    autoCap?: boolean;

    /**
     * How to read the label from each option.
     *
     * - string → key on the option object
     * - function → custom mapper
     * - omitted → tries `label`, else String(value)
     */
    optionLabel?: string | ((item: MultiSelectOption) => React.ReactNode);

    /**
     * How to read the value from each option.
     *
     * - string → key on the option object
     * - function → custom mapper
     * - omitted → uses `value`, or `id`, or `key`, or index
     */
    optionValue?: string | ((item: MultiSelectOption) => SelectPrimitive);

    /**
     * Optional description line under the label.
     */
    optionDescription?: string | ((item: MultiSelectOption) => React.ReactNode);

    /**
     * How to determine if an option is disabled.
     */
    optionDisabled?: string | ((item: MultiSelectOption) => boolean);

    /**
     * How to extract an icon for each option.
     *
     * - string → key on the option object (default "icon")
     * - function → custom mapper
     */
    optionIcon?: string | ((item: MultiSelectOption) => React.ReactNode);

    /**
     * How to compute the React key for each option.
     */
    optionKey?:
        | string
        | ((item: MultiSelectOption, index: number) => React.Key);

    /**
     * Enable inline search inside the dropdown.
     */
    searchable?: boolean;

    /**
     * Placeholder for the search input.
     */
    searchPlaceholder?: string;

    /**
     * Text to show when search yields no results.
     */
    emptySearchText?: React.ReactNode;

    /**
     * Placeholder when nothing is selected.
     */
    placeholder?: React.ReactNode;

    /**
     * Show a small clear button in the trigger when any value is selected.
     */
    clearable?: boolean;

    /**
     * Whether to show a "Select all" row.
     */
    showSelectAll?: boolean;

    /**
     * Label for the "Select all" row.
     * Default: "Select all".
     */
    selectAllLabel?: React.ReactNode;

    /**
     * Where to place the "Select all" row.
     * Default: "top".
     */
    selectAllPosition?: "top" | "bottom";

    /**
     * Custom renderer for each option row (checkbox + label).
     */
    renderOption?: (ctx: {
        item: NormalizedMultiItem;
        selected: boolean;
        index: number;
        option: React.ReactNode; // prebuilt row you can wrap
        click(): void;
    }) => React.ReactNode;

    /**
     * Custom renderer for the trigger summary.
     */
    renderValue?: (ctx: {
        selectedItems: NormalizedMultiItem[];
        placeholder?: React.ReactNode;
    }) => React.ReactNode;

    /**
     * Custom renderer for the checkbox.
     *
     * - item: the option item (or null for "select all")
     * - selected: whether this row is currently fully selected
     * - indeterminate: partially selected (used for "select all")
     * - isSelectAll: true for the "select all" row
     */
    renderCheckbox?: (ctx: {
        item: NormalizedMultiItem | null;
        selected: boolean;
        indeterminate: boolean;
        isSelectAll: boolean;
    }) => React.ReactNode;

    /**
     * Max height (in px) for the dropdown list before scrolling.
     * Default: 260.
     */
    maxListHeight?: number;

    /**
     * Wrapper class for the whole variant.
     */
    className?: string;

    /**
     * Extra classes for the trigger button.
     */
    triggerClassName?: string;

    /**
     * Extra classes for the popover content.
     */
    contentClassName?: string;
};

type MultiSelectDefaultModeProps = {
    mode?: "default";

    // Icons & controls (default mode only)
    leadingIcons?: React.ReactNode[];
    trailingIcons?: React.ReactNode[];
    icon?: React.ReactNode;
    iconGap?: number;
    leadingIconSpacing?: number;
    trailingIconSpacing?: number;

    leadingControl?: React.ReactNode;
    trailingControl?: React.ReactNode;
    leadingControlClassName?: string;
    trailingControlClassName?: string;

    joinControls?: boolean;
    extendBoxToControls?: boolean;

    // Not supported in default mode
    button?: never;
    children?: never;
    selectedBadge?: never;
    selectedBadgeHiddenWhenZero?: never;
    selectedBadgeClassName?: never;
    selectedBadgePlacement?: never;
};

type MultiSelectButtonModeButton =
    | React.ReactNode
    | ((ctx: {
          open: boolean;
          selectedItems: NormalizedMultiItem[];
          selectedCount: number;
      }) => React.ReactNode);

type MultiSelectButtonModeProps = {
    mode: "button";

    /**
     * Used when mode="button". If provided, this is the trigger.
     * If not provided, `children` is used.
     */
    button?: MultiSelectButtonModeButton;
    children?: MultiSelectButtonModeButton;

    /**
     * Selected-count badge (mode="button" only)
     */
    selectedBadge?: boolean;
    selectedBadgeHiddenWhenZero?: boolean;
    selectedBadgeClassName?: string;
    selectedBadgePlacement?: "end" | "corner";

    // Icons & controls NOT supported in button mode
    leadingIcons?: never;
    trailingIcons?: never;
    icon?: never;
    iconGap?: never;
    leadingIconSpacing?: never;
    trailingIconSpacing?: never;

    leadingControl?: never;
    trailingControl?: never;
    leadingControlClassName?: never;
    trailingControlClassName?: never;

    joinControls?: never;
    extendBoxToControls?: never;
};

export type ShadcnMultiSelectVariantProps = MultiSelectBaseProps &
    (MultiSelectDefaultModeProps | MultiSelectButtonModeProps);

// ─────────────────────────────────────────────
// Helpers
// ─────────────────────────────────────────────

function normalizeOptions(
    opts: readonly MultiSelectOption[] | undefined,
    config: Pick<
        ShadcnMultiSelectVariantProps,
        | "autoCap"
        | "optionLabel"
        | "optionValue"
        | "optionDescription"
        | "optionDisabled"
        | "optionKey"
        | "optionIcon"
    >
): NormalizedMultiItem[] {
    return globalNormalizeOptions(opts, config);
}

function triggerHeight(size?: Size) {
    switch (size) {
        case "sm":
            return "h-8 text-xs";
        case "lg":
            return "h-11 text-base";
        default:
            return "h-9 text-sm";
    }
}

function triggerPadding(density?: Density) {
    switch (density) {
        case "compact":
            return "py-1";
        case "loose":
            return "py-2";
        case "comfortable":
        default:
            return "py-1.5";
    }
}

// ─────────────────────────────────────────────
// Component
// ─────────────────────────────────────────────

export const ShadcnMultiSelectVariant = React.forwardRef<
    HTMLButtonElement,
    ShadcnMultiSelectVariantProps
>(function ShadcnMultiSelectVariant(props, _ref) {
    const {
        value,
        onValue,
        error,
        disabled,
        readOnly,
        size,
        density,

        options,

        autoCap,
        optionLabel,
        optionValue,
        optionDescription,
        optionDisabled,
        optionIcon,
        optionKey,

        searchable,
        searchPlaceholder,
        emptySearchText,

        placeholder,
        clearable,

        showSelectAll,
        selectAllLabel,
        selectAllPosition = "top",

        renderOption,
        renderValue,
        renderCheckbox,

        maxListHeight = 260,

        className,
        triggerClassName,
        contentClassName,

        // Mode
        mode = "default",

        // Icons & controls (default mode only)
        leadingIcons,
        trailingIcons,
        icon,
        iconGap,
        leadingIconSpacing,
        trailingIconSpacing,
        leadingControl,
        trailingControl,
        leadingControlClassName,
        trailingControlClassName,
        joinControls = true,
        extendBoxToControls = true,

        // Button mode only
        button,
        children,
        selectedBadge,
        selectedBadgeHiddenWhenZero,
        selectedBadgeClassName,
        selectedBadgePlacement = "end",
    } = props;

    const [open, setOpen] = React.useState(false);
    const [query, setQuery] = React.useState("");

    const items = React.useMemo(
        () =>
            normalizeOptions(options ?? [], {
                autoCap,
                optionLabel,
                optionValue,
                optionDescription,
                optionDisabled,
                optionKey,
                optionIcon,
            }),
        [
            options,
            autoCap,
            optionLabel,
            optionValue,
            optionDescription,
            optionDisabled,
            optionKey,
            optionIcon,
        ]
    );

    const selectedValues = React.useMemo(
        () => new Set<SelectPrimitive>((value ?? []) as SelectPrimitive[]),
        [value]
    );

    const selectedItems = React.useMemo(
        () => items.filter((it) => selectedValues.has(it.value)),
        [items, selectedValues]
    );

    const filteredItems = React.useMemo(() => {
        if (!query) return items;
        const q = query.toLowerCase();
        return items.filter((it) => it.labelText.toLowerCase().includes(q));
    }, [items, query]);

    const selectableItems = React.useMemo(
        () => items.filter((it) => !it.disabled),
        [items]
    );

    const allSelectableValues = React.useMemo(
        () => new Set<SelectPrimitive>(selectableItems.map((it) => it.value)),
        [selectableItems]
    );

    const allSelected =
        selectableItems.length > 0 &&
        selectableItems.every((it) => selectedValues.has(it.value));

    const someSelected =
        selectableItems.length > 0 &&
        !allSelected &&
        selectableItems.some((it) => selectedValues.has(it.value));

    const heightCls = triggerHeight(size as Size | undefined);
    const padCls = triggerPadding(density as Density | undefined);

    const showClear = clearable && (value?.length ?? 0) > 0;

    const disabledTrigger = disabled || readOnly;

    const handleToggleValue = React.useCallback(
        (primitive: SelectPrimitive) => {
            if (!onValue || disabled || readOnly) return;

            const current = (value ?? []) as SelectPrimitive[];
            const isSelected = current.some((v) => v === primitive);

            let next: SelectPrimitive[];
            if (isSelected) {
                next = current.filter((v) => v !== primitive);
            } else {
                next = [...current, primitive];
            }

            const final = next.length ? next : undefined;

            const detail: ChangeDetail = {
                source: "variant",
                raw: {
                    type: "toggle",
                    value: primitive,
                    next: final,
                },
                nativeEvent: undefined,
                meta: undefined,
            };

            onValue(final as any, detail);
        },
        [onValue, value, disabled, readOnly]
    );

    const handleSelectAll = React.useCallback(() => {
        if (!onValue || disabled || readOnly) return;

        const current = (value ?? []) as SelectPrimitive[];

        const allSelectableArr = Array.from(allSelectableValues);

        const currentlyAllSelected =
            allSelectableArr.length > 0 &&
            allSelectableArr.every((v) => selectedValues.has(v));

        let next: SelectPrimitive[];

        if (currentlyAllSelected) {
            // unselect all selectable ones, keep others (if any)
            next = current.filter((v) => !allSelectableValues.has(v));
        } else {
            // union of existing + all selectable
            const merged = new Set<SelectPrimitive>(current);
            for (const v of allSelectableArr) merged.add(v);
            next = Array.from(merged);
        }

        const final = next.length ? next : undefined;

        const detail: ChangeDetail = {
            source: "variant",
            raw: {
                type: "select-all",
                next: final,
            },
            nativeEvent: undefined,
            meta: {
                allSelected: !currentlyAllSelected,
            },
        };

        onValue(final as any, detail);
    }, [
        onValue,
        value,
        disabled,
        readOnly,
        allSelectableValues,
        selectedValues,
    ]);

    const handleClearAll = React.useCallback(() => {
        if (!onValue || disabled || readOnly) return;

        const detail: ChangeDetail = {
            source: "variant",
            raw: {
                type: "clear",
            },
            nativeEvent: undefined,
            meta: undefined,
        };

        onValue(undefined as any, detail);
    }, [onValue, disabled, readOnly]);

    const triggerSummary = renderValue ? (
        renderValue({ selectedItems, placeholder })
    ) : (
        <SelectionSummary
            selectedItems={selectedItems}
            placeholder={placeholder}
            onRemoveValue={(item) => {
                // whatever you already do to unselect a single value
                // e.g. toggleValue(value) if it adds/removes from the set
                // toggleValue(value);

                const updated = removeSelectValue(
                    selectedValues as unknown as SelectPrimitive[],
                    item.value
                );

                const detail: ChangeDetail = {
                    source: "variant",
                    raw: item,
                    nativeEvent: undefined,
                    meta: { action: "remove", removed: value },
                };

                onValue?.(updated, detail);
            }}
        />
    );

    // ─────────────────────────────────────────────
    // Icons setup (same semantics as select variant)
    // ─────────────────────────────────────────────

    const resolvedLeadingIcons: React.ReactNode[] = (() => {
        if (leadingIcons && leadingIcons.length) return leadingIcons;
        if (icon) return [icon];
        return [];
    })();

    const resolvedTrailingIcons: React.ReactNode[] = trailingIcons ?? [];

    const baseIconGap = iconGap ?? 4;
    const leadingGap = leadingIconSpacing ?? baseIconGap;
    const trailingGap = trailingIconSpacing ?? baseIconGap;

    const hasLeadingIcons = resolvedLeadingIcons.length > 0;
    const hasTrailingIcons = resolvedTrailingIcons.length > 0;

    const hasLeadingControl = !!leadingControl;
    const hasTrailingControl = !!trailingControl;
    const hasControls = hasLeadingControl || hasTrailingControl;

    const makeCheckboxNode = React.useCallback(
        (opts: {
            item: NormalizedMultiItem | null;
            selected: boolean;
            indeterminate: boolean;
            isSelectAll: boolean;
        }) => {
            if (renderCheckbox) {
                return renderCheckbox(opts);
            }

            return (
                <Checkbox
                    className="mr-2 mt-0.5"
                    checked={opts.indeterminate ? "none" : opts.selected}
                    aria-hidden="true"
                    // purely visual; click handled on row button
                    onCheckedChange={() => {}}
                />
            );
        },
        [renderCheckbox]
    );

    const baseBoxClasses = cn(
        "border-input w-full min-w-0 rounded-md border bg-transparent shadow-xs",
        "transition-[color,box-shadow] outline-none",
        "focus-within:border-ring focus-within:ring-ring/50 focus-within:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive"
    );

    // Trigger button body (icons + summary + clear + trailing icons + chevron)
    const DefaultTriggerButton = (
        <button
            ref={_ref}
            type="button"
            disabled={disabledTrigger}
            className={cn(
                "flex w-full items-center justify-between rounded-md border border-input bg-surfaces-input px-3 text-left shadow-xs",
                "focus-visible:outline-none focus-visible:ring-[3px] focus-visible:ring-ring/50 focus-visible:border-ring",
                "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
                heightCls,
                padCls,
                hasControls &&
                    joinControls &&
                    extendBoxToControls &&
                    "border-none shadow-none focus-visible:ring-0 focus-visible:outline-none",
                triggerClassName
            )}
        >
            <div className="flex w-full items-center justify-between gap-2">
                {/* Left side: leading icons + summary */}
                <div className="flex min-w-0 items-center grow gap-2">
                    {hasLeadingIcons && (
                        <span
                            className="flex items-center gap-1 shrink-0"
                            style={{ columnGap: leadingGap }}
                            data-slot="leading-icons"
                        >
                            {resolvedLeadingIcons.map((node, idx) => (
                                <span
                                    key={idx}
                                    className="flex items-center justify-center"
                                >
                                    {node}
                                </span>
                            ))}
                        </span>
                    )}

                    <div className="min-w-0 flex-1">{triggerSummary}</div>
                </div>

                {/* Right side: clear + trailing icons + chevron */}
                <div className="flex items-center gap-1 shrink-0">
                    {showClear && (
                        <button
                            type="button"
                            aria-label="Clear selection"
                            onClick={(e) => {
                                e.stopPropagation();
                                e.preventDefault();
                                handleClearAll();
                            }}
                            className="flex h-4 w-4 items-center justify-center rounded hover:bg-muted"
                            data-slot="clear"
                        >
                            <X className="h-3 w-3 pointer-events-none" />
                        </button>
                    )}

                    {hasTrailingIcons && (
                        <span
                            className="flex items-center gap-1"
                            style={{ columnGap: trailingGap }}
                            data-slot="trailing-icons"
                        >
                            {resolvedTrailingIcons.map((node, idx) => (
                                <span
                                    key={idx}
                                    className="flex items-center justify-center"
                                >
                                    {node}
                                </span>
                            ))}
                        </span>
                    )}

                    <ChevronDown className="h-4 w-4 text-muted-foreground" />
                </div>
            </div>
        </button>
    );

    // Button mode trigger
    const ButtonModeTrigger = React.useMemo(() => {
        if (mode !== "button") return null;

        const selectedCount = selectedItems.length;
        const content: React.ReactNode = (() => {
            const renderable = button ?? children;
            if (typeof renderable === "function") {
                return renderable({
                    open,
                    selectedItems,
                    selectedCount,
                });
            }
            return (
                renderable ?? (
                    <button
                        type="button"
                        className={cn(
                            "inline-flex items-center gap-2",
                            triggerClassName
                        )}
                    >
                        <span className="truncate">{triggerSummary}</span>
                        <ChevronDown className="h-4 w-4 text-muted-foreground" />
                    </button>
                )
            );
        })();

        if (!selectedBadge) return content;

        const hiddenZero = selectedBadgeHiddenWhenZero && selectedCount === 0;
        if (hiddenZero) return content;

        if (selectedBadgePlacement === "corner") {
            return (
                <span className="relative inline-block">
                    {content}
                    <Badge
                        className={cn(
                            "absolute -top-2 -right-2 h-5 min-w-5 px-1.5",
                            selectedBadgeClassName
                        )}
                    >
                        {selectedCount}
                    </Badge>
                </span>
            );
        }

        // default: end placement
        return (
            <span className="inline-flex items-center gap-2">
                {content}
                <Badge
                    className={cn(
                        "ml-1 h-5 min-w-5 px-1.5",
                        selectedBadgeClassName
                    )}
                >
                    {selectedCount}
                </Badge>
            </span>
        );
    }, [
        mode,
        button,
        children,
        triggerClassName,
        open,
        selectedItems,
        selectedBadge,
        selectedBadgeHiddenWhenZero,
        selectedBadgePlacement,
        selectedBadgeClassName,
        triggerSummary,
    ]);

    // Core multi-select element (Popover + list)
    const TriggerNode =
        mode === "button" ? ButtonModeTrigger : DefaultTriggerButton;
    const MultiSelectCore = (
        <Popover
            open={open && !disabledTrigger}
            onOpenChange={(next) => {
                if (disabledTrigger) return;
                setOpen(next);
                if (!next) setQuery("");
            }}
        >
            <PopoverTrigger asChild>{TriggerNode}</PopoverTrigger>

            <PopoverContent
                className={cn(
                    "w-(--radix-popover-trigger-width) p-0",
                    contentClassName
                )}
                align="start"
            >
                {/* Search bar */}
                {searchable && (
                    <div className="p-2 border-b border-border">
                        <Input
                            autoFocus
                            icon={<Search className="size-4" />}
                            value={query}
                            onChange={(e) => setQuery(e.target.value)}
                            placeholder={searchPlaceholder ?? "Search options…"}
                            size={size}
                            density={density}
                        />
                    </div>
                )}

                <div
                    className="py-1 overflow-auto"
                    style={{ maxHeight: maxListHeight }}
                >
                    {/* Optional "Select all" at top */}
                    {showSelectAll && selectAllPosition === "top" && (
                        <button
                            type="button"
                            className={cn(
                                "flex w-full items-center px-2 py-1.5 text-sm",
                                "hover:bg-muted/70",
                                "disabled:cursor-not-allowed disabled:opacity-50"
                            )}
                            onClick={handleSelectAll}
                        >
                            {makeCheckboxNode({
                                item: null,
                                selected: allSelected,
                                indeterminate: someSelected,
                                isSelectAll: true,
                            })}
                            <span className="truncate">
                                {selectAllLabel ?? "Select all"}
                            </span>
                        </button>
                    )}

                    {/* Options */}
                    {filteredItems.length === 0 ? (
                        <div className="px-2 py-1.5 text-xs text-muted-foreground">
                            {emptySearchText ?? "No results found"}
                        </div>
                    ) : (
                        filteredItems.map((item, index) => {
                            const selected = selectedValues.has(item.value);

                            const row = (
                                <button
                                    key={item.key}
                                    type="button"
                                    className={cn(
                                        "flex w-full items-start gap-2 px-2 py-1.5 text-sm",
                                        "hover:bg-muted/70",
                                        item.disabled &&
                                            "opacity-50 cursor-not-allowed"
                                    )}
                                    onClick={() => {
                                        if (item.disabled) return;
                                        handleToggleValue(item.value);
                                    }}
                                >
                                    {makeCheckboxNode({
                                        item,
                                        selected,
                                        indeterminate: false,
                                        isSelectAll: false,
                                    })}

                                    <div className="flex flex-1 items-start gap-2">
                                        {item.icon && (
                                            <span className="mt-0.5 shrink-0">
                                                {item.icon}
                                            </span>
                                        )}
                                        <div className="flex flex-col">
                                            <span>{item.labelNode}</span>
                                            {item.description && (
                                                <span className="text-xs text-muted-foreground">
                                                    {item.description}
                                                </span>
                                            )}
                                        </div>
                                    </div>
                                </button>
                            );

                            // Prefer per-option renderer (normalized) if present; fall back to global renderOption
                            const renderer = (item as any).render ?? renderOption;

                            if (!renderer) return row;

                            return renderer({
                                item,
                                selected,
                                index,
                                option: row,
                                click() {
                                    if (item.disabled) return;
                                    handleToggleValue(item.value);
                                },
                            });
                        })
                    )}

                    {/* Optional "Select all" at bottom */}
                    {showSelectAll && selectAllPosition === "bottom" && (
                        <button
                            type="button"
                            className={cn(
                                "mt-1 flex w-full items-center px-2 py-1.5 text-sm border-t border-border",
                                "hover:bg-muted/70",
                                "disabled:cursor-not-allowed disabled:opacity-50"
                            )}
                            onClick={handleSelectAll}
                        >
                            {makeCheckboxNode({
                                item: null,
                                selected: allSelected,
                                indeterminate: someSelected,
                                isSelectAll: true,
                            })}
                            <span className="truncate">
                                {selectAllLabel ?? "Select all"}
                            </span>
                        </button>
                    )}
                </div>
            </PopoverContent>
        </Popover>
    );

    // ─────────────────────────────────────────────
    // Layout modes (mirroring select variant)
    // ─────────────────────────────────────────────

    // CASE 1: button mode or no controls → just the multi-select
    if (mode === "button" || !hasControls) {
        return (
            <div
                data-slot="select-field"
                data-multi="true"
                className={cn(
                    "w-full",
                    disabled && "opacity-50 cursor-not-allowed",
                    className
                )}
                aria-disabled={disabled || undefined}
                aria-invalid={error ? "true" : undefined}
            >
                {MultiSelectCore}
            </div>
        );
    }

    // CASE 2: controls + joinControls → shared single box
    if (joinControls) {
        const groupClassName = cn(
            "flex items-stretch w-full",
            extendBoxToControls &&
                cn(
                    "relative",
                    baseBoxClasses // ring via :focus-within
                ),
            !extendBoxToControls &&
                "relative border-none shadow-none bg-transparent",
            className
        );

        return (
            <div
                data-slot="select-field"
                data-multi="true"
                className="w-full"
                aria-disabled={disabled || undefined}
                aria-invalid={error ? "true" : undefined}
            >
                <div
                    className={groupClassName}
                    data-slot="select-group"
                    data-disabled={disabled ? "true" : "false"}
                >
                    {hasLeadingControl && (
                        <div
                            className={cn(
                                "flex items-center px-2",
                                leadingControlClassName
                            )}
                            data-slot="leading-control"
                        >
                            {leadingControl}
                        </div>
                    )}

                    <div
                        className={cn("flex-1 min-w-0 flex items-stretch")}
                        data-slot="select-region"
                    >
                        {MultiSelectCore}
                    </div>

                    {hasTrailingControl && (
                        <div
                            className={cn(
                                "flex items-center px-2",
                                trailingControlClassName
                            )}
                            data-slot="trailing-control"
                        >
                            {trailingControl}
                        </div>
                    )}
                </div>
            </div>
        );
    }

    // CASE 3: controls present, but separate (no joined box)
    return (
        <div
            data-slot="select-field"
            data-multi="true"
            className={cn(
                "flex items-stretch w-full",
                disabled && "opacity-50 cursor-not-allowed",
                className
            )}
            aria-disabled={disabled || undefined}
            aria-invalid={error ? "true" : undefined}
        >
            {hasLeadingControl && (
                <div
                    className={cn(
                        "flex items-center mr-1",
                        leadingControlClassName
                    )}
                    data-slot="leading-control"
                >
                    {leadingControl}
                </div>
            )}

            <div className="flex-1 min-w-0" data-slot="select-region">
                {MultiSelectCore}
            </div>

            {hasTrailingControl && (
                <div
                    className={cn(
                        "flex items-center ml-1",
                        trailingControlClassName
                    )}
                    data-slot="trailing-control"
                >
                    {trailingControl}
                </div>
            )}
        </div>
    );
});

ShadcnMultiSelectVariant.displayName = "ShadcnMultiSelectVariant";

export default ShadcnMultiSelectVariant;
```

---
#### 23


` File: packages/form-palette/src/presets/shadcn-variants/number.tsx`  [↑ Back to top](#index)

```tsx
import React from "react";
import { InputNumber, InputNumberProps, InputNumberValueChangeEvent } from "../ui/number";
import { cn } from "@/lib/utils";
import { ChevronUp, ChevronDown, Plus, Minus } from "lucide-react";

// Wrapper-level props for the variant
export type ShadcnNumberVariantProps =
   // All the usual number stuff (mode, locale, prefix, suffix, etc.)
   Omit<InputNumberProps,
      | "onValueChange"
      | "onChange"
      | "leadingControl"
      | "trailingControl"
   >
   & {
      /**
       * Show +/- buttons around the numeric field.
       * Defaults to false.
       */
      showButtons?: boolean;

      /**
       * How the step buttons are laid out when showButtons is true.
       *
       * - 'inline': "-" on the left, "+" on the right
       * - 'stacked': vertical +/- stack on the right
       */
      buttonLayout?: "inline" | "stacked";
   };


export const ShadcnNumberVariant = React.forwardRef<
   HTMLInputElement,
   ShadcnNumberVariantProps
>(function ShadcnNumberVariant(props, forwardedRef) {
   const {
      showButtons,
      buttonLayout = "stacked",
      disabled, // Extract disabled to style buttons
      ...rest
   } = props;

   // we still want access to these for stepping logic
   const {
      step = 1,
      min,
      value,
      max,
      onValue: onValueChange,
      name,
      id,
      inputId,
   } = rest as ShadcnNumberVariantProps;

   const handleChange = React.useCallback(
      (e: InputNumberValueChangeEvent) => {
         if (onValueChange) {
            onValueChange(e.value as any, {
               source: "user",
               nativeEvent: e.originalEvent as any,
               raw: e.value,
            });
         }
      },
      [onValueChange]
   );

   const handleStep = React.useCallback(
      (direction: 1 | -1, originalEvent: React.SyntheticEvent<any>) => {
         if (disabled) return;

         const current = value ?? 0;
         let next = current + direction * step;

         if (typeof min === "number") next = Math.max(next, min);
         if (typeof max === "number") next = Math.min(next, max);

         // Prime-style event
         const e: InputNumberValueChangeEvent = {
            originalEvent,
            value: next,
            stopPropagation: () => originalEvent.stopPropagation(),
            preventDefault: () => originalEvent.preventDefault(),
            target: {
               name,
               id: id ?? inputId ?? null,
               value: next,
            },
         };

         handleChange(e)
      },
      [value, step, min, max, onValueChange, name, id, inputId, disabled, handleChange]
   );

   // --- Styles ---
   // Common styles for the interactive buttons
   const btnBase = "flex h-full items-center justify-center bg-transparent text-muted-foreground transition-colors hover:bg-accent hover:text-accent-foreground disabled:opacity-50 disabled:cursor-not-allowed";

   // Build controls based on layout
   let leadingControl: React.ReactNode | undefined;
   let trailingControl: React.ReactNode | undefined;

   if (showButtons) {
      if (buttonLayout === "inline") {
         // INLINE: "-" on the left, "+" on the right
         leadingControl = (
            <button
               type="button"
               tabIndex={-1} // Prevent tabbing to buttons
               disabled={disabled}
               onClick={(e) => handleStep(-1, e)}
               className={cn(btnBase, "border-r border-input px-3")}
               aria-label="Decrease value"
            >
               <Minus className="h-4 w-4" />
            </button>
         );

         trailingControl = (
            <button
               type="button"
               tabIndex={-1}
               disabled={disabled}
               onClick={(e) => handleStep(1, e)}
               className={cn(btnBase, "border-l border-input px-3")}
               aria-label="Increase value"
            >
               <Plus className="h-4 w-4" />
            </button>
         );
      } else {
         // STACKED: vertical +/- on the right
         trailingControl = (
            <div className="flex h-full flex-col border-l border-input">
               <button
                  type="button"
                  tabIndex={-1}
                  disabled={disabled}
                  onClick={(e) => handleStep(1, e)}
                  className={cn(btnBase, "h-1/2 px-2 border-b border-input")}
                  aria-label="Increase value"
               >
                  <ChevronUp className="h-3 w-3" />
               </button>
               <button
                  type="button"
                  tabIndex={-1}
                  disabled={disabled}
                  onClick={(e) => handleStep(-1, e)}
                  className={cn(btnBase, "h-1/2 px-2")}
                  aria-label="Decrease value"
               >
                  <ChevronDown className="h-3 w-3" />
               </button>
            </div>
         );
      }
   }

   return (
      <InputNumber
         ref={forwardedRef}
         value={value}
         disabled={disabled}
         {...rest}
         onValueChange={handleChange}
         leadingControl={leadingControl}
         trailingControl={trailingControl}
         extendBoxToControls
         // Ensure the controls sit flush inside the container
         leadingControlClassName={cn("flex h-full", rest.leadingControlClassName)}
         trailingControlClassName={cn("flex h-full", rest.trailingControlClassName)}
      />
   );
});
```

---
#### 24


` File: packages/form-palette/src/presets/shadcn-variants/password.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/password.tsx

import * as React from "react";

import type { VariantBaseProps, ChangeDetail } from "@/variants/shared";
import type { ShadcnTextVariantProps } from "@/presets/shadcn-variants/text";
import { Input } from "@/presets/ui/input";
import { cn } from "@/lib/utils";
import { Eye, EyeOff, Check } from "lucide-react";

type BaseProps = VariantBaseProps<string | undefined>;

/**
 * Options for the built-in password strength meter.
 *
 * NOTE: Score is always in the range 0–4 (inclusive).
 */
export interface StrengthOptions {
   /**
    * Custom scoring function.
    * Return a number in the range 0–4 (inclusive) where 0 = weakest, 4 = strongest.
    */
   calc?: (value: string) => number;

   /**
    * Labels for each score bucket (index 0..4).
    * Defaults to: ["Very weak", "Weak", "Okay", "Good", "Strong"]
    */
   labels?: [string, string, string, string, string];

   /**
    * Thresholds for score steps using a 0–100 bar.
    * Defaults to [0, 25, 50, 75, 100] mapping to scores 0..4 respectively.
    */
   thresholds?: [number, number, number, number, number];

   /**
    * Minimum score required to consider the password acceptable (0–4).
    * This is purely visual unless you enforce it in validate/onChange.
    * Default: 2
    */
   minScore?: number | 2;

   /**
    * Whether to show the textual label next to/under the bar.
    * Default: true
    */
   showLabel?: boolean;

   /**
    * Where to render the meter.
    * - "inline" → compact row under the input
    * - "block" → stacked with more spacing
    * Default: "inline"
    */
   display?: "inline" | "block";
}

/** Heuristic length/charset score: fast, dependency-free. Returns 0..4. */
function defaultScore(pw: string): number {
   if (!pw) return 0;
   let score = 0;

   // length
   if (pw.length >= 8) score++;
   if (pw.length >= 12) score++;

   // diversity
   const hasLower = /[a-z]/.test(pw);
   const hasUpper = /[A-Z]/.test(pw);
   const hasDigit = /\d/.test(pw);
   const hasSymbol = /[^A-Za-z0-9]/.test(pw);

   const variety = [hasLower, hasUpper, hasDigit, hasSymbol].filter(Boolean)
      .length;
   if (variety >= 2) score++;
   if (variety >= 3) score++;

   // Cap at 4
   return Math.max(0, Math.min(4, score));
}

const DEFAULT_LABELS: [string, string, string, string, string] = [
   "Very weak",
   "Weak",
   "Okay",
   "Good",
   "Strong",
];

const DEFAULT_THRESHOLDS: [number, number, number, number, number] = [
   0, 25, 50, 75, 100,
];

function normalizeStrengthOptions(
   raw: boolean | StrengthOptions | undefined,
): StrengthOptions | null {
   if (!raw) return null;

   const base: StrengthOptions = {
      calc: defaultScore,
      labels: DEFAULT_LABELS,
      thresholds: DEFAULT_THRESHOLDS,
      minScore: 2,
      showLabel: true,
      display: "inline",
   };

   if (raw === true) {
      return base;
   }

   return {
      ...base,
      ...raw,
      labels: raw.labels ?? base.labels,
      thresholds: raw.thresholds ?? base.thresholds,
      minScore: raw.minScore ?? base.minScore,
      showLabel: raw.showLabel ?? base.showLabel,
      display: raw.display ?? base.display,
   };
}

// ─────────────────────────────────────────────
// Definition map / rules
// ─────────────────────────────────────────────

export interface PasswordRuleConfig {
   /**
    * Pattern used to decide if the rule passes.
    */
   pattern: RegExp;

   /**
    * If true, the rule is considered optional (recommendation).
    * Default: false unless the rule name is not prefixed with "!".
    */
   optional?: boolean;

   /**
    * Weight in the scoring (relative importance).
    * Default: 1, doubled if the use key is prefixed with "!".
    */
   weight?: number;

   /**
    * Short label for the rule (e.g. "At least 8 characters").
    * Defaults to the map key if omitted.
    */
   label?: string;

   /**
    * Longer description, used in detailed rule view.
    */
   description?: string;
}

/**
 * A definition entry can be:
 * - string     → treated as a regex source
 * - RegExp     → used directly
 * - full config
 */
export type PasswordRuleDefinition =
   | string
   | RegExp
   | PasswordRuleConfig;

/**
 * Map of alias/keys → definition entries.
 */
export type PasswordDefinitionMap = Record<string, PasswordRuleDefinition>;

// Default rule definitions used by the meter.
const DEFAULT_RULE_DEFINITIONS: PasswordDefinitionMap = {
   "length-8": {
      pattern: /.{8,}/,
      label: "8+ chars",
      description: "Use at least 8 characters.",
   },
   "length-12": {
      pattern: /.{12,}/,
      optional: true,
      label: "12+ chars",
      description: "Use 12 or more characters for stronger security.",
   },
   lower: {
      pattern: /[a-z]/,
      label: "Lowercase",
      description: "Include at least one lowercase letter (a–z).",
   },
   upper: {
      pattern: /[A-Z]/,
      label: "Uppercase",
      description: "Include at least one uppercase letter (A–Z).",
   },
   digit: {
      pattern: /\d/,
      label: "Number",
      description: "Include at least one digit (0–9).",
   },
   symbol: {
      pattern: /[^A-Za-z0-9]/,
      label: "Symbol",
      description: "Include at least one symbol (e.g. !, @, #, ?).",
   },
   "no-space": {
      pattern: /^\S+$/,
      optional: true,
      label: "No spaces",
      description: "Avoid spaces in your password.",
   },
};

/**
 * Merge default → global → local rule definitions.
 *
 * - DEFAULT_RULE_DEFINITIONS
 * - window["form-palette"]?.ruleDefinition
 * - props.ruleDefinitions
 */
function getMergedRuleDefinitions(
   local?: PasswordDefinitionMap,
): PasswordDefinitionMap {
   let merged: PasswordDefinitionMap = { ...DEFAULT_RULE_DEFINITIONS };

   if (typeof window !== "undefined") {
      const fp = (window as any)["form-palette"];
      const globalDefs = fp?.ruleDefinition as
         | PasswordDefinitionMap
         | undefined;

      if (globalDefs && typeof globalDefs === "object") {
         merged = { ...merged, ...globalDefs };
      }
   }

   if (local && typeof local === "object") {
      merged = { ...merged, ...local };
   }

   return merged;
}

/**
 * Internal normalized state for a single rule.
 */
interface NormalizedRuleState {
   key: string;
   label: string;
   description?: string;
   optional: boolean;
   required: boolean;
   weight: number;
   passed: boolean;
}

/**
 * Props passed to custom meter renderers.
 */
export interface PasswordMeterRenderProps {
   /** Raw password value. */
   value: string;
   /** Bucket score 0..4 based on percent + thresholds. */
   score: number;
   /** 0–100 progress used for the bar. */
   percent: number;
   /** Human label for the current score. */
   label: string;
   /** Whether score >= minScore. */
   passed: boolean;
   /** Effective minScore after normalization. */
   minScore: number;
   /** Effective thresholds used for bucketing. */
   thresholds: [number, number, number, number, number];
   /** Effective labels used. */
   labels: [string, string, string, string, string];
   /** Rule-level details when using a definition map. */
   rules: NormalizedRuleState[];
}

/**
 * Password-only props (on top of Shadcn text UI props & VariantBaseProps).
 *
 * This is what the form runtime sees as VariantPropsFor<"password">.
 */
export interface PasswordVariantProps {
   /** Maximum number of characters permitted. */
   maxLength?: number;
   /** Browser autocomplete hint (e.g., "current-password", "new-password"). */
   autoComplete?: string;

   /** Show an eye button to toggle between obscured/plain text. (default: true) */
   revealToggle?: boolean;
   /** Start in the revealed (plain text) state. */
   defaultRevealed?: boolean;
   /** Called whenever the reveal state changes. */
   onRevealChange?(revealed: boolean): void;
   /** Override the icons used for hide/show. */
   renderToggleIcon?(revealed: boolean): React.ReactNode;
   /** Accessible label for the toggle button. */
   toggleAriaLabel?(revealed: boolean): string;

   /**
    * Extra className for the reveal toggle button.
    */
   toggleButtonClassName?: string;

   /**
    * Enable the built-in strength meter (boolean or options).
    *
    * - false / undefined → no built-in meter is shown
    * - true              → use defaults
    * - object            → merge with defaults
    */
   strengthMeter?: boolean | StrengthOptions;

   /**
    * Optional rule definition map.
    */
   ruleDefinitions?: PasswordDefinitionMap;

   /**
    * Selection of rule aliases to apply.
    *
    * - "length"  → use ruleDefinitions["length"] with default importance
    * - "!length" → same rule but treated as more important
    */
   ruleUses?: string[];

   /**
    * Built-in meter style:
    * - "simple" → single bar + label
    * - "rules"  → bar + per-rule checklist
    * Default: "simple"
    */
   meterStyle?: "simple" | "rules";

   /**
    * Optional custom meter renderer.
    */
   renderMeter?(props: PasswordMeterRenderProps): React.ReactNode;

   /**
    * ClassNames for the meter and rules UI.
    */
   meterWrapperClassName?: string;
   meterContainerClassName?: string;
   meterBarClassName?: string;
   meterLabelClassName?: string;

   rulesWrapperClassName?: string;
   rulesHeadingClassName?: string;
   rulesListClassName?: string;
   ruleItemClassName?: string;
   ruleIconClassName?: string;
   ruleLabelClassName?: string;

   /**
    * Extra className for the outer field wrapper.
    */
   className?: string;
}

// We still *type* against ShadcnTextVariantProps so password can reuse
// all the visual/text props. We take control of type, value, onValue & trailingControl.
type TextUiProps = Omit<
   ShadcnTextVariantProps,
   "type" | "inputMode" | "leadingControl" | "trailingControl" | "value" | "onValue"
>;

/**
 * Full props for the Shadcn-based password variant.
 */
export type ShadcnPasswordVariantProps = TextUiProps &
   PasswordVariantProps &
   Pick<BaseProps, "value" | "onValue" | "error">;

// ─────────────────────────────────────────────
// Rule normalization & scoring
// ─────────────────────────────────────────────

function normalizeRules(
   value: string,
   definitions?: PasswordDefinitionMap,
   uses?: string[],
): { rules: NormalizedRuleState[]; percent: number | null } {
   if (!definitions || Object.keys(definitions).length === 0) {
      return { rules: [], percent: null };
   }

   const useList =
      uses && uses.length ? uses : Object.keys(definitions);

   const rules: NormalizedRuleState[] = [];
   let totalWeight = 0;
   let passedWeight = 0;

   for (const rawKey of useList) {
      if (!rawKey) continue;

      const important = rawKey.startsWith("!");
      const key = important ? rawKey.slice(1) : rawKey;
      const def = definitions[key];
      if (!def) continue;

      let pattern: RegExp;
      let optional = !important;
      let weight = important ? 2 : 1;
      let label = key;
      let description: string | undefined;

      if (typeof def === "string") {
         pattern = new RegExp(def);
      } else if (def instanceof RegExp) {
         pattern = def;
      } else {
         pattern = def.pattern;
         if (def.optional !== undefined) optional = def.optional;
         if (def.weight !== undefined) weight = def.weight;
         if (def.label) label = def.label;
         if (def.description) description = def.description;
      }

      const passed = pattern.test(value);
      totalWeight += weight;
      if (passed) passedWeight += weight;

      rules.push({
         key,
         label,
         description,
         optional,
         required: !optional,
         weight,
         passed,
      });
   }

   if (totalWeight === 0) {
      return { rules, percent: null };
   }

   const percent = (passedWeight / totalWeight) * 100;
   return { rules, percent };
}

function clampScore(x: number): number {
   if (Number.isNaN(x)) return 0;
   return Math.max(0, Math.min(4, x));
}

function computeMeterState(
   value: string,
   strength: StrengthOptions,
   definitions?: PasswordDefinitionMap,
   uses?: string[],
): PasswordMeterRenderProps {
   const { rules, percent: rulesPercent } = normalizeRules(
      value,
      definitions,
      uses,
   );

   const labels = strength.labels ?? DEFAULT_LABELS;
   const thresholds = strength.thresholds ?? DEFAULT_THRESHOLDS;
   const minScore = (strength.minScore ?? 2) as number;

   let percent: number;
   let score: number;

   if (rulesPercent != null) {
      percent = rulesPercent;
   } else {
      const rawScore = clampScore(
         strength.calc ? strength.calc(value) : defaultScore(value),
      );
      percent = (rawScore / 4) * 100;
   }

   let bucketIndex = 0;
   for (let i = 0; i < thresholds.length; i++) {
      if (percent >= thresholds[i]) {
         bucketIndex = i;
      } else {
         break;
      }
   }
   score = bucketIndex;

   const label =
      labels[score] ??
      labels[labels.length - 1] ??
      DEFAULT_LABELS[DEFAULT_LABELS.length - 1];

   const passed = score >= minScore;

   return {
      value,
      score,
      percent,
      label,
      passed,
      minScore,
      thresholds: thresholds,
      labels,
      rules,
   };
}

function meterColor(score: number): string {
   if (score <= 1) return "bg-destructive";
   if (score === 2) return "bg-orange-500";
   if (score === 3) return "bg-amber-500";
   return "bg-emerald-500";
}

// ─────────────────────────────────────────────
// Main variant component
// ─────────────────────────────────────────────

export const ShadcnPasswordVariant = React.forwardRef<
   HTMLInputElement,
   ShadcnPasswordVariantProps
>(function ShadcnPasswordVariant(props, ref) {
   const {
      // base variant bits
      value,
      onValue,
      error,

      // password base props
      maxLength,
      autoComplete,
      revealToggle = true,
      defaultRevealed = false,
      onRevealChange,
      renderToggleIcon,
      toggleAriaLabel,
      toggleButtonClassName,

      // strength / rules
      strengthMeter,
      ruleDefinitions,
      ruleUses,
      meterStyle = "simple",
      renderMeter,
      meterWrapperClassName,
      meterContainerClassName,
      meterBarClassName,
      meterLabelClassName,
      rulesWrapperClassName,
      rulesHeadingClassName,
      rulesListClassName,
      ruleItemClassName,
      ruleIconClassName,
      ruleLabelClassName,

      className,

      // everything else from Shadcn text UI
      ...restTextProps
   } = props;

   const [revealed, setRevealed] = React.useState<boolean>(
      Boolean(defaultRevealed),
   );

   const normalizedStrength = React.useMemo(
      () => normalizeStrengthOptions(strengthMeter),
      [strengthMeter],
   );

   const effectiveRuleDefinitions = React.useMemo(
      () => getMergedRuleDefinitions(ruleDefinitions),
      [ruleDefinitions],
   );

   const meterState = React.useMemo<PasswordMeterRenderProps | null>(() => {
      if (!normalizedStrength) return null;
      const v = value ?? "";
      return computeMeterState(
         v,
         normalizedStrength,
         effectiveRuleDefinitions,
         ruleUses,
      );
   }, [normalizedStrength, value, ruleUses, effectiveRuleDefinitions]);

   const handleToggleReveal = React.useCallback(() => {
      setRevealed((prev) => {
         const next = !prev;
         onRevealChange?.(next);
         return next;
      });
   }, [onRevealChange]);

   const handleChange = React.useCallback(
      (event: React.ChangeEvent<HTMLInputElement>) => {
         const next = event.target.value ?? "";
         const detail: ChangeDetail<PasswordMeterRenderProps | undefined> = {
            source: "variant",
            raw: next,
            nativeEvent: event,
            meta: meterState ?? undefined,
         };
         onValue?.(next, detail);
      },
      [onValue, meterState],
   );

   const toggleLabel =
      toggleAriaLabel?.(revealed) ??
      (revealed ? "Hide password" : "Show password");

   const trailingControl =
      revealToggle === false ? undefined : (
         <button
            type="button"
            onClick={handleToggleReveal}
            aria-label={toggleLabel}
            tabIndex={-1}
            className={cn(
               "inline-flex h-full items-center justify-center px-3 text-muted-foreground transition-colors hover:text-foreground hover:bg-muted/50 focus-visible:outline-none focus-visible:bg-muted/50",
               toggleButtonClassName,
            )}
            data-slot="password-toggle"
         >
            {renderToggleIcon ? (
               renderToggleIcon(revealed)
            ) : revealed ? (
               <EyeOff className="h-4 w-4" />
            ) : (
               <Eye className="h-4 w-4" />
            )}
         </button>
      );

   const meterNode =
      normalizedStrength && meterState
         ? renderMeter?.(meterState) ??
         (strengthMeter && (
            <div
               className={cn(
                  normalizedStrength.display === "block"
                     ? "mt-2 space-y-2"
                     : "mt-1.5 flex flex-col gap-0",
                  meterWrapperClassName,
               )}
               data-slot="password-meter"
            >
               {/* Progress Bar Row */}
               <div
                  className={cn(
                     "flex w-full items-center gap-3",
                     meterContainerClassName,
                  )}
               >
                  <div className="flex-1">
                     {/* Reduced height from h-2 to h-1 */}
                     <div className="h-1 w-full overflow-hidden rounded-full bg-secondary">
                        <div
                           className={cn(
                              "h-full transition-all duration-300 ease-out",
                              meterColor(meterState.score),
                              meterBarClassName,
                           )}
                           style={{ width: `${meterState.percent}%` }}
                        />
                     </div>
                  </div>

                  {normalizedStrength.showLabel !== false && (
                     <div
                        className={cn(
                           "min-w-[4rem] text-right text-[10px] font-medium uppercase tracking-wider text-muted-foreground",
                           meterLabelClassName,
                        )}
                     >
                        {meterState.label}
                     </div>
                  )}
               </div>

               {/* New Modern Chips for Rules */}
               {meterStyle === "rules" &&
                  meterState.rules.length > 0 && (
                     <div
                        className={cn(
                           "flex flex-wrap gap-1.5 pt-1",
                           rulesWrapperClassName,
                        )}
                     >
                        {meterState.rules.map((rule) => (
                           <span
                              key={rule.key}
                              className={cn(
                                 "inline-flex items-center gap-1 rounded-full border px-2 py-0.5 text-[10px] font-medium transition-colors duration-200",
                                 rule.passed
                                    ? "border-emerald-500/30 bg-emerald-500/10 text-emerald-600 dark:border-emerald-400/20 dark:bg-emerald-400/10 dark:text-emerald-400"
                                    : "border-transparent bg-secondary text-muted-foreground",
                                 ruleItemClassName
                              )}
                           >
                              {rule.passed && (
                                 <Check className="h-3 w-3" strokeWidth={3} />
                              )}
                              {rule.label}
                           </span>
                        ))}
                     </div>
                  )}
            </div>
         ))
         : null;

   return (
      <div className={cn("group/password w-full", className)} data-slot="password-field">
         <Input
            ref={ref}
            {...restTextProps}
            type={revealed ? "text" : "password"}
            value={value ?? ""}
            onChange={handleChange}
            maxLength={maxLength}
            autoComplete={autoComplete}
            trailingControl={trailingControl}
            aria-invalid={error ? "true" : undefined}
         />
         {meterNode}
      </div>
   );
});

ShadcnPasswordVariant.displayName = "ShadcnPasswordVariant";

export default ShadcnPasswordVariant;
```

---
#### 25


` File: packages/form-palette/src/presets/shadcn-variants/phone.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/phone.tsx

import * as React from "react";

import type { VariantModule } from "@/schema/variant";
import type { VariantBaseProps, ChangeDetail } from "@/variants/shared";
import type { ShadcnTextVariantProps } from "@/presets/shadcn-variants/text";
import { Input } from "@/presets/ui/input";
import {
   Select,
   SelectTrigger,
   SelectValue,
   SelectContent,
   SelectItem,
} from "@/presets/ui/select";
import { cn } from "@/lib/utils";
import { getGlobalCountryList } from "@/lib/get-global-countries";
import { de } from "date-fns/locale";
import { getPaletteUtil } from "@/lib/register-global";

type BaseProps = VariantBaseProps<string | undefined>;

/**
 * Single-country phone config.
 *
 * - code: ISO 3166-1 alpha-2 ("NG", "US", "GB", ...)
 * - dial: dial code without "+" ("234", "1", "44", ...)
 * - mask: NATIONAL portion mask only (no dial), e.g. "999 999 9999"
 */
export interface PhoneCountry {
   code: string;
   label: string;
   dial: string;
   mask: string;
   flag?: React.ReactNode;
}

/**
 * How the variant emits the form value.
 *
 * - "masked"  → "+234 801 234 5678"
 * - "e164"    → "2348012345678"   (dial + national digits, no "+")
 * - "national"→ "8012345678"
 */
export type PhoneValueMode = "masked" | "e164" | "national";

export interface PhoneSpecificProps {
   countries?: PhoneCountry[];
   defaultCountry?: string;
   onCountryChange?: (country: PhoneCountry) => void;

   showCountry?: boolean;
   countryPlaceholder?: string;
   showFlag?: boolean;
   showSelectedLabel?: boolean;
   showSelectedDial?: boolean;
   showDialInList?: boolean;

   /**
    * Controls how the emitted value is shaped.
    *
    * Default mirrors legacy autoUnmask=true + emitE164=true → "e164".
    */
   valueMode?: PhoneValueMode;

   /**
    * When true, the national mask keeps placeholder characters
    * for not-yet-filled positions. When false, trailing mask
    * fragments are omitted.
    */
   keepCharPositions?: boolean;

   /**
    * Style hooks for the internal country selector.
    */
   countrySelectClassName?: string;
   countryTriggerClassName?: string;
   countryValueClassName?: string;
   countryContentClassName?: string;
   countryItemClassName?: string;
}

// We still *type* against ShadcnTextVariantProps so the phone variant exposes
// the same visual/text props (size, density, icon props, etc.), but we don't
// use the component itself anymore.
type TextUiProps = Omit<
   ShadcnTextVariantProps,
   // We control these for phone behaviour
   "type" | "inputMode" | "leadingControl" | "value" | "onValue"
>;

/**
 * Full props for the phone variant as seen by the form runtime.
 *
 * - Keeps the same `value`/`onValue` contract as other variants.
 * - Inherits visual/behavioural text props (size, density, className, etc.).
 * - Adds phone-specific configuration (countries, valueMode, etc.).
 */
export type ShadcnPhoneVariantProps = TextUiProps &
   PhoneSpecificProps &
   Pick<BaseProps, "value" | "onValue">;

// ———————————————————————————————
// Defaults
// ———————————————————————————————



// ———————————————————————————————
// Mask helpers (lightweight legacy port)
// ———————————————————————————————

const TOKEN_CHARS = new Set(["9", "a", "*"] as const);

interface CompiledMask {
   pattern: string;
   placeholderChar: string;
}

/**
 * Phone only ever really uses digit masks, so we keep this compact.
 */
function compileMask(pattern: string, placeholderChar = "_"): CompiledMask {
   return { pattern, placeholderChar };
}

/**
 * Apply a simple token-based mask:
 * - '9' → digit
 * - 'a' → letter
 * - '*' → alphanumeric
 *
 * `keepCharPositions` keeps literal chars/placeholders even when not filled.
 */
function applyMask(
   mask: CompiledMask,
   raw: string,
   keepCharPositions: boolean,
): string {
   const { pattern, placeholderChar } = mask;
   let result = "";
   let rawIndex = 0;
   const len = pattern.length;

   const hasTokenAhead = (pos: number): boolean => {
      for (let j = pos + 1; j < len; j++) {
         if (TOKEN_CHARS.has(pattern[j] as any)) return true;
      }
      return false;
   };

   for (let i = 0; i < len; i++) {
      const ch = pattern[i];
      const isToken = TOKEN_CHARS.has(ch as any);

      if (isToken) {
         if (rawIndex >= raw.length) {
            if (keepCharPositions) {
               result += placeholderChar;
               continue;
            }
            break;
         }
         const next = raw[rawIndex++];
         result += next;
         continue;
      }

      // Literal character in the mask.
      const rawRemaining = rawIndex < raw.length;
      const tokenAhead = hasTokenAhead(i);

      // No tokens ahead → trailing literal.
      if (!tokenAhead) {
         if (keepCharPositions) {
            result += ch;
            continue;
         }
         break;
      }

      if (rawRemaining) {
         // We still have digits to place → include the literal.
         result += ch;
      } else if (keepCharPositions) {
         // No digits left, but want full skeleton.
         result += ch;
      } else {
         // No digits left, and we don't keep skeleton → stop.
         break;
      }
   }

   return result;
}

/**
 * Strip everything except digits.
 */
function digitsOnly(input: string | undefined | null): string {
   return (input ?? "").replace(/\D+/g, "");
}

// ———————————————————————————————
// Value ↔ display helpers
// ———————————————————————————————

function dialPrefixFor(country: PhoneCountry): string {
   return `+${country.dial} `;
}

/**
 * From any stored value (masked, e164, or national) extract
 * the NATIONAL digits for a given country.
 *
 * Strategy: remove all non-digits, then strip leading dial code
 * if present.
 */
function valueToNationalDigits(
   value: string | undefined,
   country: PhoneCountry,
): string {
   const digits = digitsOnly(value);
   if (!digits) return "";
   if (digits.startsWith(country.dial)) {
      return digits.slice(country.dial.length);
   }
   return digits;
}

/**
 * Build the display string shown in the input for a given value.
 *
 * Always renders "+<dial> " plus an optionally masked national part.
 */
function computeDisplayFromValue(
   value: string | undefined,
   country: PhoneCountry,
   keepCharPositions: boolean,
): string {
   const prefix = dialPrefixFor(country);

   const national = valueToNationalDigits(value, country);
   if (!national) {
      return prefix;
   }

   const mask = compileMask(country.mask);
   const maskedNational = applyMask(mask, national, keepCharPositions);
   if (!maskedNational) {
      return prefix;
   }

   return prefix + maskedNational;
}

/**
 * Given raw user input in the field, compute:
 * - display string (what we show in the input)
 * - next form value (according to valueMode)
 * - nationalDigits (for metadata)
 */
function computeNextFromInput(
   rawInput: string,
   country: PhoneCountry,
   mode: PhoneValueMode,
   keepCharPositions: boolean,
): {
   display: string;
   nextValue: string | undefined;
   nationalDigits: string;
} {
   const prefix = dialPrefixFor(country);
   const allDigits = digitsOnly(rawInput);

   let national = allDigits;
   if (national.startsWith(country.dial)) {
      national = national.slice(country.dial.length);
   }

   const mask = compileMask(country.mask);
   const maskedNational = applyMask(mask, national, keepCharPositions);

   const display =
      national.length === 0 ? prefix : (prefix + maskedNational || prefix);

   let nextValue: string | undefined;
   if (!national.length) {
      nextValue = undefined;
   } else if (mode === "masked") {
      nextValue = display;
   } else if (mode === "e164") {
      nextValue = country.dial + national;
   } else {
      // "national"
      nextValue = national;
   }

   return { display, nextValue, nationalDigits: national };
}

/**
 * When the country changes, re-interpret the existing value's
 * digits into the new country's mask/dial.
 */
function remapToCountry(
   value: string | undefined,
   from: PhoneCountry,
   to: PhoneCountry,
   mode: PhoneValueMode,
   keepCharPositions: boolean,
): { display: string; nextValue: string | undefined } {
   if (!value) {
      const prefix = dialPrefixFor(to);
      return { display: prefix, nextValue: undefined };
   }

   const digitsAll = digitsOnly(value);

   let national = digitsAll;
   if (digitsAll.startsWith(from.dial)) {
      national = digitsAll.slice(from.dial.length);
   }

   const prefix = dialPrefixFor(to);
   const mask = compileMask(to.mask);
   const masked = applyMask(mask, national, keepCharPositions);

   const display =
      national.length === 0 ? prefix : (prefix + masked || prefix);

   let nextValue: string | undefined;
   if (!national.length) {
      nextValue = undefined;
   } else if (mode === "masked") {
      nextValue = display;
   } else if (mode === "e164") {
      nextValue = to.dial + national;
   } else {
      nextValue = national;
   }

   return { display, nextValue };
}

/**
 * If no placeholder is passed, we show the dial prefix plus an
 * underscore-skeleton version of the national mask.
 */
function buildPlaceholder(country: PhoneCountry): string {
   const prefix = dialPrefixFor(country);
   const skeleton = country.mask.replace(/[9a\*]/g, "_");
   return prefix + skeleton;
}

// ———————————————————————————————
// Country select (Shadcn Select)
// ———————————————————————————————

interface CountrySelectProps {
   countries: PhoneCountry[];
   value: string;
   onChange: (code: string) => void;
   showFlag: boolean;
   showSelectedLabel: boolean;
   showSelectedDial: boolean;
   showDialInList: boolean;

   countrySelectClassName?: string;
   countryTriggerClassName?: string;
   countryValueClassName?: string;
   countryContentClassName?: string;
   countryItemClassName?: string;
}

const CountrySelect: React.FC<CountrySelectProps> = ({
   countries,
   value,
   onChange,
   showFlag,
   showSelectedLabel,
   showSelectedDial,
   showDialInList,
   countrySelectClassName,
   countryTriggerClassName,
   countryValueClassName,
   countryContentClassName,
   countryItemClassName,
}) => {
   const selected =
      countries.find((c) => c.code === value) ?? countries[0] ?? null;

   const triggerLabel = selected
      ? [
         showFlag && selected.flag ? selected.flag : null,
         showSelectedDial ? `+${selected.dial}` : null,
         showSelectedLabel ? selected.label : null,
      ]
         .filter(Boolean)
         .join(" ")
      : "";

   return (
      <div className={countrySelectClassName}>
         <Select value={selected?.code ?? ""} onValueChange={onChange}>
            <SelectTrigger
               className={cn(
                  "h-full min-w-18 px-2 focus-visible:ring-0 py-0 shadow-none rounded-none border-l-0 border-t-0 border-b-0 border-r text-xs whitespace-nowrap",
                  countryTriggerClassName,
               )}
            >
               <SelectValue
                  placeholder="Code"
                  className={countryValueClassName}
               >
                  {triggerLabel || selected?.code || "—"}
               </SelectValue>
            </SelectTrigger>
            <SelectContent className={countryContentClassName}>
               {countries.map((c) => {
                  const parts: string[] = [];

                  if (showFlag && c.flag) {
                     parts.push(String(c.flag));
                  }

                  if (showDialInList) {
                     parts.push(`+${c.dial}`);
                  }

                  parts.push(c.label);

                  return (
                     <SelectItem
                        key={c.code}
                        value={c.code}
                        className={countryItemClassName}
                     >
                        {parts.join(" ")}
                     </SelectItem>
                  );
               })}
            </SelectContent>
         </Select>
      </div>
   );
};




// ———————————————————————————————
// Main variant component
// ———————————————————————————————

export const ShadcnPhoneVariant = React.forwardRef<
   HTMLInputElement,
   ShadcnPhoneVariantProps
>(function ShadcnPhoneVariant(props, ref) {
   const {
      countries: countriesProp,
      defaultCountry,
      onCountryChange,
      showCountry = true,
      showFlag = true,
      showSelectedLabel = false,
      showSelectedDial = false,
      showDialInList = true,
      valueMode = "e164",
      keepCharPositions = false,
      value,
      onValue,
      countryPlaceholder: placeholder,
      error,

      countrySelectClassName,
      countryTriggerClassName,
      countryValueClassName,
      countryContentClassName,
      countryItemClassName,

      ...restTextProps
   } = props;

   let DEFAULT_COUNTRIES = getGlobalCountryList();
   const defaultCountries =
      countriesProp && countriesProp.length > 0
         ? countriesProp
         : DEFAULT_COUNTRIES;

   const [loadedCountries, setLoadedCountries] = React.useState<PhoneCountry[]>(defaultCountries);

   React.useEffect(() => {
      const loader = getPaletteUtil("countries");
      if (loader) {
         Promise.resolve(loader).then((list) => {
            setLoadedCountries(list);
         });
      }
   }, []);

   const countries = React.useMemo(() => {
      return defaultCountries;
   }, [loadedCountries, countriesProp]);


   const [country, setCountry] = React.useState<PhoneCountry>(() => {
      if (defaultCountry) {
         const found = countries.find((c) => c.code === defaultCountry);
         if (found) return found;
      }
      return countries[0] ?? DEFAULT_COUNTRIES[0];
   });

   // Keep active country in sync if list/default changes.
   React.useEffect(() => {
      setCountry((prev) => {
         if (defaultCountry) {
            const found = countries.find((c) => c.code === defaultCountry);
            if (found) return found;
         }
         const stillThere = countries.find((c) => c.code === prev.code);
         return stillThere ?? countries[0] ?? prev;
      });
   }, [countries, defaultCountry]);

   const [local, setLocal] = React.useState<string>(() =>
      computeDisplayFromValue(value, country, keepCharPositions),
   );

   // Sync local display when external value or country changes.
   React.useEffect(() => {
      setLocal(computeDisplayFromValue(value, country, keepCharPositions));
   }, [value, country, keepCharPositions]);

   const handleInputChange = React.useCallback(
      (event: React.ChangeEvent<HTMLInputElement>) => {
         const rawInput = event.target.value ?? "";
         const { display, nextValue, nationalDigits } = computeNextFromInput(
            rawInput,
            country,
            valueMode,
            keepCharPositions,
         );

         setLocal(display);

         if (onValue) {
            const detail: ChangeDetail<{
               country: PhoneCountry;
               nationalDigits: string;
            }> = {
               source: "variant",
               raw: rawInput,
               nativeEvent: event,
               meta: {
                  country,
                  nationalDigits,
               },
            };
            onValue(nextValue, detail);
         }
      },
      [country, valueMode, keepCharPositions, onValue],
   );

   const handleCountryChange = React.useCallback(
      (nextCode: string) => {
         const nextCountry =
            countries.find((c) => c.code === nextCode) ?? countries[0];

         if (!nextCountry) return;

         setCountry(nextCountry);
         onCountryChange?.(nextCountry);

         const { display, nextValue } = remapToCountry(
            value,
            country,
            nextCountry,
            valueMode,
            keepCharPositions,
         );

         setLocal(display);

         if (onValue) {
            const detail: ChangeDetail<{
               from: PhoneCountry;
               to: PhoneCountry;
            }> = {
               source: "variant",
               raw: undefined,
               meta: {
                  from: country,
                  to: nextCountry,
               },
            };
            onValue(nextValue, detail);
         }
      },
      [
         countries,
         country,
         keepCharPositions,
         onCountryChange,
         onValue,
         value,
         valueMode,
      ],
   );

   const effectivePlaceholder =
      placeholder ?? buildPlaceholder(country);

   const leadingControl = showCountry ? (
      <CountrySelect
         countries={countries}
         value={country.code}
         onChange={handleCountryChange}
         showFlag={showFlag}
         showSelectedLabel={showSelectedLabel}
         showSelectedDial={showSelectedDial}
         showDialInList={showDialInList}
         countrySelectClassName={countrySelectClassName}
         countryTriggerClassName={countryTriggerClassName}
         countryValueClassName={countryValueClassName}
         countryContentClassName={countryContentClassName}
         countryItemClassName={countryItemClassName}
      />
   ) : undefined;

   return (
      <Input
         ref={ref}
         {...restTextProps}
         type="tel"
         inputMode="tel"
         value={local}
         onChange={handleInputChange}
         leadingControl={leadingControl}
         placeholder={effectivePlaceholder}
         aria-invalid={error ? "true" : undefined}
      />
   );
});
```

---
#### 26


` File: packages/form-palette/src/presets/shadcn-variants/radio.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/radio.tsx
// noinspection GrazieInspection

import * as React from "react";
import type { VariantBaseProps, ChangeDetail } from "@/variants/shared";
import { buildGroupLayoutClasses } from "@/lib/group-layout";

// Adjust path if your radio group lives elsewhere
import { RadioGroup, RadioGroupItem } from "@/presets/ui/radio-group";
import { globalNormalizeCheckBasedOptions } from "@/lib/normalise-options";

// ─────────────────────────────────────────────
// Types
// ─────────────────────────────────────────────

/**
 * Visual size of the radio UI.
 */
export type RadioSize = "sm" | "md" | "lg";

/**
 * Vertical density of each radio row.
 *
 * Names aligned with your FieldDensity, but local to this variant.
 */
export type RadioDensity = "compact" | "comfortable" | "loose";

/**
 * Layout mode for the group.
 *
 * - "list" → stacked rows
 * - "grid" → CSS grid with `columns`
 */
export type RadioLayoutMode = "list" | "grid";

/**
 * Base radio item shape.
 */
export interface RadioItem<TValue> {
    value: TValue;
    label: React.ReactNode;
    description?: React.ReactNode;
    disabled?: boolean;
    key?: React.Key;

    /**
     * Option-level renderer (provided by the normaliser).
     * If present, it overrides the variant-level `renderOption` for this item.
     */
    render?: (ctx: RadioRenderOptionContext<TValue>) => React.ReactNode;
}

/**
 * Mapping functions used when TItem is not `RadioItem<TValue>`.
 */
export interface RadioMappers<TItem, TValue> {
    getValue: (item: TItem, index: number) => TValue;
    getLabel: (item: TItem, index: number) => React.ReactNode;
    getDescription?: (item: TItem, index: number) => React.ReactNode;
    isDisabled?: (item: TItem, index: number) => boolean;
    getKey?: (item: TItem, index: number) => React.Key;
}

/**
 * Context passed to a custom renderOption callback.
 */
export interface RadioRenderOptionContext<TValue> {
    item: RadioItem<TValue>;
    index: number;
    selected: boolean;
    disabled: boolean;
    size: RadioSize;
    density: RadioDensity;
    click(): void;
    /**
     * DOM id of this option (tied to the underlying RadioGroupItem).
     */
    optionId?: string;

    /**
     * Prebuilt radio control for convenience.
     * You can ignore this and render your own if you want.
     */
    radio: React.ReactNode;
}

/**
 * UI-specific radio props (independent of VariantBaseProps).
 */
export interface ShadcnRadioUiProps<TItem, TValue> {
    /**
     * Items to render as choices.
     *
     * Can be:
     * - `RadioItem<TValue>[]`, or
     * - any custom TItem[] when used with mapping functions
     *   or optionValue/optionLabel keys.
     * - primitive arrays such as `string[]` or `number[]` (fallback).
     */
    options?: readonly TItem[];
    items?: readonly TItem[];

    /**
     * Mapping functions for TItem → value/label/etc.
     *
     * Takes precedence over optionValue/optionLabel if provided.
     */
    mappers?: RadioMappers<TItem, TValue>;

    /**
     * Property name on TItem that holds the **value**.
     *
     * Example:
     *   items = [{ id: "free", title: "Free" }]
     *   optionValue = "id"
     */
    optionValue?: keyof TItem | string;

    /**
     * Property name on TItem that holds the **label**.
     *
     * Example:
     *   items = [{ id: "free", title: "Free" }]
     *   optionLabel = "title"
     */
    optionLabel?: keyof TItem | string;

    /**
     * Optional custom renderer for each option.
     *
     * If provided, the default label/description layout is skipped and
     * this function is responsible for rendering the row.
     */
    renderOption?: (ctx: RadioRenderOptionContext<TValue>) => React.ReactNode;

    /**
     * Layout mode for the group.
     * Default: "list".
     */
    layout?: RadioLayoutMode;

    /**
     * Number of columns in grid mode.
     * Default: 2.
     */
    columns?: number;

    /**
     * Gap between items (list rows or grid cells) in px.
     * If omitted, Tailwind gaps/classes can handle spacing.
     */
    itemGapPx?: number;

    /**
     * Visual size of the radios.
     * Default: "md".
     */
    size?: RadioSize;

    /**
     * Vertical density (padding) of each row.
     * Default: "comfortable".
     */
    density?: RadioDensity;

    /**
     * When true, capitalizes the **first letter** of the label
     * (only applied when the label is a string).
     */
    autoCap?: boolean;

    /**
     * ARIA overrides for the group.
     */
    "aria-label"?: string;
    "aria-labelledby"?: string;

    /**
     * Wrapper class for the whole radio group.
     */
    groupClassName?: string;

    /**
     * Extra classes for each radio option row.
     */
    optionClassName?: string;

    /**
     * Extra classes for the option label node.
     */
    labelClassName?: string;

    /**
     * Extra classes for the description text under the label.
     */
    descriptionClassName?: string;
}

/**
 * Full props for the Shadcn-based radio variant.
 */
export type ShadcnRadioVariantProps<
    TValue,
    TItem = RadioItem<TValue>,
> = ShadcnRadioUiProps<TItem, TValue> &
    Pick<
        VariantBaseProps<TValue | undefined>,
        "value" | "onValue" | "error" | "disabled" | "required"
    > & {
        id?: string;
        name?: string;
        className?: string; // alias for groupClassName
        "aria-describedby"?: string;
    };

/**
 * Convenience type for the concrete React component.
 */
export interface ShadcnRadioVariantComponent<
    TValue,
    TItem = RadioItem<TValue>,
> extends React.ForwardRefExoticComponent<
    ShadcnRadioVariantProps<TValue, TItem> & React.RefAttributes<HTMLDivElement>
> {}

// ─────────────────────────────────────────────
// Helpers
// ─────────────────────────────────────────────

function paddingForDensity(density: RadioDensity): string {
    switch (density) {
        case "compact":
            return "py-1.5";
        case "loose":
            return "py-3";
        case "comfortable":
        default:
            return "py-1";
    }
}

function labelTextSize(size: RadioSize): string {
    switch (size) {
        case "sm":
            return "text-xs";
        case "lg":
            return "text-base";
        case "md":
        default:
            return "text-sm";
    }
}

function descriptionTextSize(size: RadioSize): string {
    switch (size) {
        case "sm":
            return "text-[0.7rem]";
        case "lg":
            return "text-sm";
        case "md":
        default:
            return "text-xs";
    }
}

function capitalizeFirst(label: string): string {
    if (!label) return label;
    return label.charAt(0).toUpperCase() + label.slice(1);
}

/**
 * Normalise TItem[] into RadioItem<TValue>[] using one of:
 * - explicit mappers
 * - optionValue/optionLabel keys
 * - native RadioItem fields
 * - primitive arrays (string[] / number[] / boolean[])
 */
function normalizeItems<TItem, TValue>(
    items: readonly TItem[],
    mappers?: RadioMappers<TItem, TValue>,
    optionValueKey?: keyof TItem,
    optionLabelKey?: keyof TItem
): RadioItem<TValue>[] {
    // 1) Full mappers win – most explicit
    if (mappers) {
        return items.map((item, index) => ({
            value: mappers.getValue(item, index),
            label: mappers.getLabel(item, index),
            description: mappers.getDescription
                ? mappers.getDescription(item, index)
                : undefined,
            disabled: mappers.isDisabled
                ? mappers.isDisabled(item, index)
                : false,
            key: mappers.getKey ? mappers.getKey(item, index) : index,
        }));
    }

    // 2) optionValue / optionLabel keys
    if (optionValueKey || optionLabelKey) {
        return items.map((item, index) => {
            return globalNormalizeCheckBasedOptions(
                item as any,
                index,
                optionLabelKey,
                optionValueKey
            );
        });
    }

    // 3) Fallbacks:
    //    - primitive arrays (string[] / number[] / boolean[])
    //    - already-shaped RadioItem<TValue>[]
    return items.map((item, index) => {
        // Primitive → use as both value and label
        if (
            typeof item === "string" ||
            typeof item === "number" ||
            typeof item === "boolean"
        ) {
            const v = item as unknown as TValue;
            return {
                value: v,
                label: String(item),
                description: undefined,
                disabled: false,
                key: index,
            } satisfies RadioItem<TValue>;
        }

        // Assume it's already a RadioItem<TValue>-like object
        return item as unknown as RadioItem<TValue>;
    });
}

/**
 * Shallow-ish equality for values.
 */
function isEqualValue(a: unknown, b: unknown): boolean {
    return Object.is(a, b);
}

// ─────────────────────────────────────────────
// Component
// ─────────────────────────────────────────────

const InnerShadcnRadioVariant = <TValue, TItem = RadioItem<TValue>>(
    props: ShadcnRadioVariantProps<TValue, TItem>,
    ref: React.Ref<HTMLDivElement>
) => {
    const {
        // variant base
        value,
        onValue,
        error,
        disabled,
        required,

        // radio UI
        items,
        options,
        mappers,
        optionValue,
        optionLabel,
        renderOption,
        layout = "list",
        columns = 2,
        itemGapPx,
        size = "md",
        density = "comfortable",
        autoCap = false,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-describedby": ariaDescribedBy,
        name,

        groupClassName,
        optionClassName,
        labelClassName,
        descriptionClassName,

        className, // alias for groupClassName
        id,

        // passthrough to RadioGroup
        ...restGroupProps
    } = props;

    const hasError = !!error;

    const normalized = React.useMemo(
        () =>
            normalizeItems<TItem, TValue>(
                (items ?? options)!,
                mappers,
                //@ts-ignore
                optionValue,
                optionLabel
            ),
        [items, options, mappers, optionValue, optionLabel]
    );

    // Map TValue → string for RadioGroup
    const selectedString = React.useMemo(() => {
        if (value === undefined) return undefined;
        const found = normalized.find((item) =>
            isEqualValue(item.value, value)
        );
        return found ? String(found.value) : undefined;
    }, [normalized, value]);

    const handleSelect = React.useCallback(
        (next: TValue) => {
            if (!onValue || disabled) return;

            const detail: ChangeDetail = {
                source: "variant",
                raw: next,
                nativeEvent: undefined,
                meta: undefined,
            };

            onValue(next, detail);
        },
        [onValue, disabled]
    );

    const handleRadioChange = React.useCallback(
        (raw: string) => {
            const found = normalized.find((item) => String(item.value) === raw);
            if (!found) return;
            handleSelect(found.value);
        },
        [normalized, handleSelect]
    );

    const {
        groupStyle,
        groupClasses,
        baseOptionClass,
        labelClassesBase,
        descriptionClassesBase,
    } = buildGroupLayoutClasses({
        layout,
        columns,
        itemGapPx,
        groupClassName,
        className,
        optionClassName,
        labelClassName,
        descriptionClassName,
        densityPaddingClass: paddingForDensity(density),
        labelTextSizeClass: labelTextSize(size),
        descriptionTextSizeClass: descriptionTextSize(size),
    });

    return (
        <RadioGroup
            ref={ref}
            id={id}
            name={name}
            value={selectedString}
            onValueChange={handleRadioChange}
            disabled={disabled}
            aria-label={ariaLabel}
            aria-labelledby={ariaLabelledBy}
            aria-describedby={ariaDescribedBy}
            aria-invalid={hasError || undefined}
            aria-required={required || undefined}
            className={groupClasses}
            style={groupStyle}
            data-slot="radio-group"
            {...restGroupProps}
        >
            {normalized.map((item, index) => {
                const itemString = String(item.value);
                const selected = selectedString === itemString;
                const optionDisabled = !!disabled || !!item.disabled;
                const optionKey = item.key ?? index;
                const optionId = id ? `${id}-option-${optionKey}` : undefined;

                // Apply autoCap to string labels for display
                let displayItem: RadioItem<TValue> = item;
                if (autoCap && typeof item.label === "string") {
                    displayItem = {
                        ...item,
                        label: capitalizeFirst(item.label),
                    };
                }

                const radioNode = (
                    <RadioGroupItem
                        id={optionId}
                        value={itemString}
                        disabled={optionDisabled}
                        className="mt-1"
                    />
                );

                const renderer = (item as RadioItem<TValue>).render ?? renderOption;

                // Custom renderer path
                if (renderer) {
                    return (
                        <div
                            key={optionKey}
                            data-slot="radio-option"
                            data-checked={selected ? "true" : "false"}
                            data-disabled={optionDisabled ? "true" : "false"}
                            className={baseOptionClass}
                        >
                            {renderer({
                                item: displayItem,
                                index,
                                selected,
                                disabled: optionDisabled,
                                size,
                                density,
                                optionId,
                                click() {
                                    if (optionDisabled) return;
                                    handleSelect(displayItem.value);
                                },
                                radio: radioNode,
                            })}
                        </div>
                    );
                }

                // Default rendering
                return (
                    <div
                        key={optionKey}
                        data-slot="radio-option"
                        data-checked={selected ? "true" : "false"}
                        data-disabled={optionDisabled ? "true" : "false"}
                        className={baseOptionClass}
                    >
                        <label
                            htmlFor={optionId}
                            className="flex cursor-pointer items-start gap-3 w-full"
                        >
                            {radioNode}

                            <div className="flex flex-col min-w-0">
                                <span className={labelClassesBase}>
                                    {displayItem.label}
                                </span>
                                {displayItem.description != null && (
                                    <span className={descriptionClassesBase}>
                                        {displayItem.description}
                                    </span>
                                )}
                            </div>
                        </label>
                    </div>
                );
            })}
        </RadioGroup>
    );
};

/**
 * Concrete Shadcn radio variant component.
 *
 * Cast to a generic-friendly type so TS can still infer TValue/TItem.
 */
export const ShadcnRadioVariant = React.forwardRef(
    InnerShadcnRadioVariant
) as unknown as <TValue, TItem = RadioItem<TValue>>(
    props: ShadcnRadioVariantProps<TValue, TItem> & {
        ref?: React.Ref<HTMLDivElement>;
    }
) => React.ReactElement | null;

export default ShadcnRadioVariant;
```

---
#### 27


` File: packages/form-palette/src/presets/shadcn-variants/select.tsx`  [↑ Back to top](#index)

```tsx
// noinspection DuplicatedCode

import * as React from "react";
import type { VariantBaseProps, ChangeDetail } from "@/variants/shared";
import { cn } from "@/lib/utils";
import {
    Select,
    SelectTrigger,
    SelectContent,
    SelectItem,
} from "@/presets/ui/select";
import { Input } from "@/presets/ui/input";
import { Search, X } from "lucide-react";
import { globalNormalizeOptions } from "@/lib/normalise-options";

type SelectPrimitive = string | number;

type Size = "sm" | "md" | "lg";
type Density = "compact" | "comfortable" | "loose";

export type SelectOption =
    | SelectPrimitive
    | {
          label?: React.ReactNode;
          value?: SelectPrimitive;
          description?: React.ReactNode;
          disabled?: boolean;
          [key: string]: any;
      };

type NormalizedSelectItem = {
    key: string;
    value: SelectPrimitive;
    labelNode: React.ReactNode;
    labelText: string;
    description?: React.ReactNode;
    disabled?: boolean;
    icon?: React.ReactNode;
    /** Option-level renderer (falls back to global renderOption) */
    render?: (...args: any[]) => React.ReactNode;
    raw: SelectOption;
};

/**
 * Shadcn-based Select variant.
 */
export interface SelectBaseProps extends Pick<
    VariantBaseProps<SelectPrimitive | undefined>,
    "value" | "onValue" | "error" | "disabled" | "readOnly" | "size" | "density"
> {
    /**
     * Options for the select.
     *
     * You can pass:
     * - primitives: ["ng", "gh", "ke"]
     * - objects:    [{ label, value, ...extra }]
     */
    options?: SelectOption[];

    /**
     * Automatically capitalise the first letter of the label
     * (when the resolved label is a string).
     */
    autoCap?: boolean;

    /**
     * How to read the label from each option.
     *
     * - string → key on the option object
     * - function → custom mapper
     * - omitted → tries `label`, else String(value)
     */
    optionLabel?: string | ((item: SelectOption) => React.ReactNode);

    /**
     * How to read the value from each option.
     *
     * - string → key on the option object
     * - function → custom mapper
     * - omitted → uses `value`, or `id`, or `key`, or index
     */
    optionValue?: string | ((item: SelectOption) => SelectPrimitive);

    /**
     * Optional description line under the label.
     */
    optionDescription?: string | ((item: SelectOption) => React.ReactNode);

    /**
     * How to determine if an option is disabled.
     */
    optionDisabled?: string | ((item: SelectOption) => boolean);

    /**
     * How to extract an icon for each option.
     *
     * - string → key on the option object (default "icon")
     * - function → custom mapper
     */
    optionIcon?: string | ((item: SelectOption) => React.ReactNode);

    /**
     * How to compute the React key for each option.
     */
    optionKey?: string | ((item: SelectOption, index: number) => React.Key);

    /**
     * Enable inline search inside the dropdown.
     */
    searchable?: boolean;

    /**
     * Placeholder for the search input.
     */
    searchPlaceholder?: string;

    /**
     * Label shown when there are no options available at all.
     *
     * If omitted, falls back to `emptySearchText` or a default message.
     */
    emptyLabel?: React.ReactNode;

    /**
     * Text to show when search yields no results
     * (but there *are* options in general).
     */
    emptySearchText?: React.ReactNode;

    /**
     * Show a small clear button in the trigger when a value is selected.
     */
    clearable?: boolean;

    /**
     * Placeholder when nothing is selected.
     */
    placeholder?: React.ReactNode;

    /**
     * Wrapper class for the whole variant.
     */
    className?: string;

    /**
     * Extra classes for the SelectTrigger.
     */
    triggerClassName?: string;

    /**
     * Extra classes for the SelectContent popover.
     */
    contentClassName?: string;

    /**
     * Custom renderer for each option row.
     */
    renderOption?: (ctx: {
        item: NormalizedSelectItem;
        selected: boolean;
        index: number;
        option: React.ReactNode; // prebuilt <SelectItem> you can wrap
        click(): void;
    }) => React.ReactNode;

    /**
     * Custom renderer for the trigger value.
     */
    renderValue?: (ctx: {
        selectedItem: NormalizedSelectItem | null;
        placeholder?: React.ReactNode;
    }) => React.ReactNode;

    // ─────────────────────────────────────────────
    // Icons & controls (mirror text variant concepts)
    // ─────────────────────────────────────────────

    // (moved to default-mode props)

    /**
     * Icons displayed on the right side of the trigger,
     * near the clear button / chevron area.
     */
    trailingIcons?: React.ReactNode[];

    /**
     * Convenience single-icon prop for the left side.
     */
    icon?: React.ReactNode;

    /**
     * Base gap between icons and text.
     * Defaults to 4px-ish via `gap-1`.
     */
    iconGap?: number;

    /**
     * Extra spacing to apply between leading icons and the text.
     */
    leadingIconSpacing?: number;

    /**
     * Extra spacing to apply between trailing icons and the clear button.
     */
    trailingIconSpacing?: number;

    /**
     * Arbitrary React node rendered before the select (e.g. a button).
     */
    leadingControl?: React.ReactNode;

    /**
     * Arbitrary React node rendered after the select (e.g. a button).
     */
    trailingControl?: React.ReactNode;

    /**
     * Extra classes for the leading control wrapper.
     */
    leadingControlClassName?: string;

    /**
     * Extra classes for the trailing control wrapper.
     */
    trailingControlClassName?: string;

    /**
     * If true and there are controls, the select trigger + controls share
     * a single visual box (borders, radius, focus states).
     */
    joinControls?: boolean;

    /**
     * When joinControls is true, whether the box styling extends over controls
     * (true) or controls are visually separate (false).
     */
    extendBoxToControls?: boolean;

    // ─────────────────────────────────────────────
    // Virtual-scroll-ish incremental rendering
    // ─────────────────────────────────────────────

    /**
     * Enable incremental rendering for large option lists.
     *
     * When true, only a page of options is rendered initially,
     * and more are revealed as the user scrolls down.
     */
    virtualScroll?: boolean;

    /**
     * Number of options to render per "page" when virtualScroll is enabled.
     * Default: 50.
     */
    virtualScrollPageSize?: number;

    /**
     * Distance from the bottom (in px) at which the next page loads.
     * Default: 48px.
     */
    virtualScrollThreshold?: number;
}

type SelectDefaultModeProps = {
    mode?: "default";

    // Icons & controls (default mode only)
    leadingIcons?: React.ReactNode[];
    trailingIcons?: React.ReactNode[];
    icon?: React.ReactNode;
    iconGap?: number;
    leadingIconSpacing?: number;
    trailingIconSpacing?: number;

    leadingControl?: React.ReactNode;
    trailingControl?: React.ReactNode;
    leadingControlClassName?: string;
    trailingControlClassName?: string;

    joinControls?: boolean;
    extendBoxToControls?: boolean;

    // Not supported in default mode
    button?: never;
    children?: never;
};

type SelectButtonModeButton =
    | React.ReactNode
    | ((ctx: {
          open: boolean;
          selectedItem: NormalizedSelectItem | null;
          selectedValue: SelectPrimitive | undefined;
          placeholder?: React.ReactNode;
      }) => React.ReactNode);

type SelectButtonModeProps = {
    mode: "button";

    /**
     * Used when mode="button". If provided, this is the trigger.
     * If not provided, `children` is used.
     */
    button?: SelectButtonModeButton;
    children?: SelectButtonModeButton;

    // Icons & controls NOT supported in button mode
    leadingIcons?: never;
    trailingIcons?: never;
    icon?: never;
    iconGap?: never;
    leadingIconSpacing?: never;
    trailingIconSpacing?: never;

    leadingControl?: never;
    trailingControl?: never;
    leadingControlClassName?: never;
    trailingControlClassName?: never;

    joinControls?: never;
    extendBoxToControls?: never;
};

export type ShadcnSelectVariantProps = SelectBaseProps &
    (SelectDefaultModeProps | SelectButtonModeProps);

// ─────────────────────────────────────────────
// Helpers
// ─────────────────────────────────────────────

function normalizeOptions(
    opts: readonly SelectOption[] | undefined,
    config: Pick<
        SelectBaseProps,
        | "autoCap"
        | "optionLabel"
        | "optionValue"
        | "optionDescription"
        | "optionDisabled"
        | "optionKey"
        | "optionIcon"
    >,
): NormalizedSelectItem[] {
    return globalNormalizeOptions(opts, config);
}

function triggerHeight(size?: Size) {
    switch (size) {
        case "sm":
            return "h-8 text-xs";
        case "lg":
            return "h-11 text-base";
        default:
            return "h-9 text-sm";
    }
}

function triggerPadding(density?: Density) {
    switch (density) {
        case "compact":
            return "py-1";
        case "loose":
            return "py-2";
        case "comfortable":
        default:
            return "py-1.5";
    }
}

// ─────────────────────────────────────────────
// Component
// ─────────────────────────────────────────────

export const ShadcnSelectVariant = React.forwardRef<
    HTMLButtonElement,
    ShadcnSelectVariantProps
>(function ShadcnSelectVariant(props, _ref) {
    const {
        value,
        onValue,
        error,
        disabled,
        readOnly,
        size,
        density,

        options,

        autoCap,
        optionLabel,
        optionValue,
        optionDescription,
        optionDisabled,
        optionIcon,
        optionKey,

        searchable,
        searchPlaceholder,

        emptyLabel,
        emptySearchText,

        clearable,

        placeholder,

        className,
        triggerClassName,
        contentClassName,

        renderOption,
        renderValue,

        // Mode
        mode = "default",

        // Icons & controls
        leadingIcons,
        trailingIcons,
        icon,
        iconGap,
        leadingIconSpacing,
        trailingIconSpacing,
        leadingControl,
        trailingControl,
        leadingControlClassName,
        trailingControlClassName,
        joinControls = true,
        extendBoxToControls = true,

        // Button mode only
        button,
        children,

        // Virtual scroll / incremental render
        virtualScroll = false,
        virtualScrollPageSize = 50,
        virtualScrollThreshold = 48,
    } = props;

    const isButtonMode = mode === "button";

    const [open, setOpen] = React.useState(false);
    const [query, setQuery] = React.useState("");

    const items = React.useMemo(
        () =>
            normalizeOptions(options ?? [], {
                autoCap,
                optionLabel,
                optionValue,
                optionDescription,
                optionDisabled,
                optionKey,
                optionIcon,
            }),
        [
            options,
            autoCap,
            optionLabel,
            optionValue,
            optionDescription,
            optionDisabled,
            optionKey,
            optionIcon,
        ],
    );

    const valueMap = React.useMemo(() => {
        const map = new Map<string, SelectPrimitive>();
        for (const item of items) {
            map.set(String(item.value), item.value);
        }
        return map;
    }, [items]);

    const selectedItem =
        value == null ? null : (items.find((it) => it.value === value) ?? null);

    const filteredItems = React.useMemo(() => {
        if (!query) return items;
        const q = query.toLowerCase();
        return items.filter((it) => it.labelText.toLowerCase().includes(q));
    }, [items, query]);

    // ─────────────────────────────────────────────
    // Incremental render state
    // ─────────────────────────────────────────────

    const [visibleCount, setVisibleCount] = React.useState(() =>
        virtualScroll
            ? Math.min(virtualScrollPageSize, filteredItems.length)
            : filteredItems.length,
    );

    const listRef = React.useRef<HTMLDivElement | null>(null);

    // Reset visibleCount when list / filter / toggle changes
    React.useEffect(() => {
        if (!virtualScroll) {
            setVisibleCount(filteredItems.length);
            return;
        }

        setVisibleCount(Math.min(virtualScrollPageSize, filteredItems.length));
    }, [virtualScroll, filteredItems.length, virtualScrollPageSize]);

    const handleListScroll = React.useCallback(() => {
        if (!virtualScroll) return;
        const el = listRef.current;
        if (!el) return;

        const { scrollTop, scrollHeight, clientHeight } = el;
        const distanceFromBottom = scrollHeight - (scrollTop + clientHeight);

        if (distanceFromBottom <= virtualScrollThreshold) {
            setVisibleCount((prev) => {
                if (prev >= filteredItems.length) return prev;
                const next = prev + virtualScrollPageSize;
                return Math.min(next, filteredItems.length);
            });
        }
    }, [
        virtualScroll,
        filteredItems.length,
        virtualScrollPageSize,
        virtualScrollThreshold,
    ]);

    const renderedItems = React.useMemo(
        () =>
            virtualScroll
                ? filteredItems.slice(0, visibleCount)
                : filteredItems,
        [filteredItems, visibleCount, virtualScroll],
    );

    const handleChange = React.useCallback(
        (rawKey: string) => {
            if (!onValue) return;

            const primitive =
                valueMap.get(rawKey) ?? (rawKey as unknown as SelectPrimitive);

            const item =
                items.find((it) => String(it.value) === String(primitive)) ??
                null;

            const detail: ChangeDetail = {
                source: "variant",
                raw: item?.raw ?? primitive,
                nativeEvent: undefined,
                meta: undefined,
            };

            onValue(primitive, detail);
        },
        [onValue, valueMap, items],
    );

    const currentKey = selectedItem != null ? String(selectedItem.value) : "";

    const heightCls = triggerHeight(size as Size | undefined);
    const padCls = triggerPadding(density as Density | undefined);

    const showClear = clearable && value != null;

    // ─────────────────────────────────────────────
    // Icons setup (similar to text variant)
    // ─────────────────────────────────────────────

    const resolvedLeadingIcons: React.ReactNode[] = (() => {
        if (isButtonMode) return [];
        if (leadingIcons && leadingIcons.length) return leadingIcons;
        if (icon) return [icon];
        return [];
    })();

    const resolvedTrailingIcons: React.ReactNode[] = isButtonMode
        ? []
        : (trailingIcons ?? []);

    const baseIconGap = iconGap ?? 4;
    const leadingGap = leadingIconSpacing ?? baseIconGap;
    const trailingGap = trailingIconSpacing ?? baseIconGap;

    const hasLeadingIcons = resolvedLeadingIcons.length > 0;
    const hasTrailingIcons = resolvedTrailingIcons.length > 0;

    const hasLeadingControl = !isButtonMode && !!leadingControl;
    const hasTrailingControl = !isButtonMode && !!trailingControl;
    const hasControls = hasLeadingControl || hasTrailingControl;

    const triggerInner = renderValue ? (
        renderValue({
            selectedItem,
            placeholder,
        })
    ) : selectedItem ? (
        <span className="truncate flex items-center gap-2">
            {selectedItem.icon && (
                <span className="shrink-0">{selectedItem.icon}</span>
            )}
            <span className="truncate">{selectedItem.labelNode}</span>
        </span>
    ) : (
        <span className="truncate text-muted-foreground">
            {placeholder ?? "Select..."}
        </span>
    );

    const baseBoxClasses = cn(
        "border-input w-full min-w-0 rounded-md border bg-transparent shadow-xs",
        "transition-[color,box-shadow] outline-none",
        "focus-within:border-ring focus-within:ring-ring/50 focus-within:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
    );

    const ButtonModeTrigger = React.useMemo(() => {
        if (!isButtonMode) return null;

        const selectedValue = value as SelectPrimitive | undefined;
        const renderable = button ?? children;

        const content: React.ReactNode = (() => {
            if (typeof renderable === "function") {
                return renderable({
                    open,
                    selectedItem,
                    selectedValue,
                    placeholder,
                });
            }

            if (renderable != null) return renderable;

            // Default fallback:
            // - if options have icons, show selected icon (or first icon)
            // - else show simple label
            const iconNode =
                selectedItem?.icon ?? items.find((it) => it.icon)?.icon ?? null;

            if (iconNode) {
                return (
                    <span className="inline-flex items-center justify-center">
                        {iconNode}
                    </span>
                );
            }

            return (
                <span className="truncate">
                    {selectedItem?.labelNode ?? placeholder ?? "Select..."}
                </span>
            );
        })();

        // Important: SelectTrigger wants a single element child when asChild.
        // Use a button by default to keep it accessible.
        return (
            <button
                ref={_ref}
                type="button"
                disabled={disabled || readOnly}
                className={cn(
                    "inline-flex items-center justify-center",
                    "focus-visible:outline-none focus-visible:ring-[3px] focus-visible:ring-ring/50",
                    triggerClassName,
                )}
                aria-label={
                    selectedItem?.labelText
                        ? `Selected: ${selectedItem.labelText}`
                        : "Select"
                }
            >
                {content}
            </button>
        );
    }, [
        isButtonMode,
        button,
        children,
        open,
        selectedItem,
        value,
        placeholder,
        items,
        disabled,
        readOnly,
        triggerClassName,
        _ref,
    ]);
    // Trigger content (inner layout: icons + label + clear + trailing icons)
    const TriggerBody = isButtonMode ? (
        <SelectTrigger asChild>{ButtonModeTrigger}</SelectTrigger>
    ) : (
        <SelectTrigger
            onPointerDown={(e) => {
                if (e.target instanceof HTMLButtonElement) {
                    if (e.target.getAttribute("data-slot") == "clear") {
                        e.preventDefault();
                        e.stopPropagation();
                        if (!onValue) return;
                        const detail: ChangeDetail = {
                            source: "variant",
                            raw: undefined,
                            nativeEvent: undefined,
                            meta: { action: "clear" },
                        };
                        onValue(undefined, detail);
                    }
                }
            }}
            className={cn(
                "w-full justify-between",
                heightCls,
                padCls,
                hasControls && joinControls && extendBoxToControls
                    ? "border-none shadow-none focus:ring-0 focus:outline-none"
                    : "",
                triggerClassName,
            )}
        >
            <div className="flex w-full items-center justify-between gap-2">
                {/* Left side: leading icons + label */}
                <div className="flex min-w-0 items-center gap-2">
                    {hasLeadingIcons && (
                        <span
                            className="flex items-center gap-1 shrink-0"
                            style={{ columnGap: leadingGap }}
                            data-slot="leading-icons"
                        >
                            {resolvedLeadingIcons.map((node, idx) => (
                                <span
                                    key={idx}
                                    className="flex items-center justify-center"
                                >
                                    {node}
                                </span>
                            ))}
                        </span>
                    )}
                    <div className="min-w-0 flex-1">{triggerInner}</div>
                </div>

                {/* Right side: clear button + trailing icons */}
                <div className="flex items-center gap-1 shrink-0">
                    {showClear && (
                        <button
                            data-slot={"clear"}
                            type="button"
                            aria-label="Clear selection"
                            className="flex h-4 w-4 items-center justify-center rounded hover:bg-muted"
                        >
                            <X className="h-3 w-3 pointer-events-none" />
                        </button>
                    )}

                    {hasTrailingIcons && (
                        <span
                            className="flex items-center gap-1"
                            style={{ columnGap: trailingGap }}
                            data-slot="trailing-icons"
                        >
                            {resolvedTrailingIcons.map((node, idx) => (
                                <span
                                    key={idx}
                                    className="flex items-center justify-center"
                                >
                                    {node}
                                </span>
                            ))}
                        </span>
                    )}
                </div>
            </div>
        </SelectTrigger>
    );

    const SelectWithTrigger = (
        <Select
            value={currentKey}
            onValueChange={handleChange}
            disabled={disabled || readOnly}
            open={open}
            onOpenChange={(nextOpen) => {
                setOpen(nextOpen);
                if (!nextOpen) setQuery("");
            }}
        >
            {TriggerBody}

            <SelectContent className={cn("min-w-32", contentClassName)}>
                {searchable && (
                    <div className="p-1">
                        <Input
                            autoFocus
                            icon={<Search className="size-4" />}
                            value={query}
                            onChange={(e) => setQuery(e.target.value)}
                            placeholder={searchPlaceholder ?? "Search..."}
                            size={size}
                            density={density}
                        />
                    </div>
                )}

                {/* CASE 1: no options at all */}
                {items.length === 0 ? (
                    <div className="px-2 py-1.5 text-xs text-muted-foreground">
                        {emptyLabel ??
                            emptySearchText ??
                            "No options available"}
                    </div>
                ) : /* CASE 2: have options, but search filters everything out */ filteredItems.length ===
                  0 ? (
                    <div className="px-2 py-1.5 text-xs text-muted-foreground">
                        {emptySearchText ?? "No results found"}
                    </div>
                ) : (
                    // CASE 3: normal list, possibly virtually paged
                    <div
                        ref={listRef}
                        className="max-h-60 overflow-auto"
                        onScroll={handleListScroll}
                    >
                        {renderedItems.map((item, index) => {
                            const optionNode = (
                                <SelectItem
                                    key={item.key}
                                    value={String(item.value)}
                                    disabled={item.disabled}
                                >
                                    <div className="flex items-start gap-2">
                                        {item.icon && (
                                            <span className="mt-0.5 shrink-0">
                                                {item.icon}
                                            </span>
                                        )}
                                        <div className="flex flex-col">
                                            <span>{item.labelNode}</span>
                                            {item.description && (
                                                <span className="text-xs text-muted-foreground">
                                                    {item.description}
                                                </span>
                                            )}
                                        </div>
                                    </div>
                                </SelectItem>
                            );

                            // Prefer per-option renderer (normalized) if present; fall back to global renderOption
                            const renderer =
                                (item as any).render ?? renderOption;

                            if (!renderer) return optionNode;

                            return renderer({
                                item,
                                selected:
                                    selectedItem != null &&
                                    String(selectedItem.value) ===
                                        String(item.value),
                                index,
                                option: optionNode,
                                click() {
                                    if (disabled || readOnly || item.disabled)
                                        return;
                                    handleChange(String(item.value));
                                    setOpen(false);
                                    setQuery("");
                                },
                            });
                        })}

                        {virtualScroll &&
                            renderedItems.length < filteredItems.length && (
                                <div className="px-2 py-1 text-[10px] text-muted-foreground text-center">
                                    Scroll to load more…
                                </div>
                            )}
                    </div>
                )}
            </SelectContent>
        </Select>
    );

    // ─────────────────────────────────────────────
    // Layout modes:
    // - no controls
    // - controls + joinControls
    // - controls, separate boxes
    // ─────────────────────────────────────────────

    // CASE 1: button mode OR no controls → just the select
    if (isButtonMode || !hasControls) {
        return (
            <div
                data-slot="select-field"
                className={cn(
                    "w-full",
                    disabled && "opacity-50 cursor-not-allowed",
                    className,
                )}
                aria-disabled={disabled || undefined}
                aria-invalid={error ? "true" : undefined}
            >
                {SelectWithTrigger}
            </div>
        );
    }

    // CASE 2: controls + joinControls → share single box like text variant
    if (joinControls) {
        const groupClassName = cn(
            "flex items-stretch w-full",
            extendBoxToControls &&
                cn(
                    "relative",
                    baseBoxClasses, // ring via :focus-within
                ),
            !extendBoxToControls &&
                "relative border-none shadow-none bg-transparent",
            className,
        );

        return (
            <div
                data-slot="select-field"
                className="w-full"
                aria-disabled={disabled || undefined}
                aria-invalid={error ? "true" : undefined}
            >
                <div
                    className={groupClassName}
                    data-slot="select-group"
                    data-disabled={disabled ? "true" : "false"}
                >
                    {hasLeadingControl && (
                        <div
                            className={cn(
                                "flex items-center px-2",
                                leadingControlClassName,
                            )}
                            data-slot="leading-control"
                        >
                            {leadingControl}
                        </div>
                    )}

                    <div
                        className={cn("flex-1 min-w-0 flex items-stretch")}
                        data-slot="select-region"
                    >
                        {SelectWithTrigger}
                    </div>

                    {hasTrailingControl && (
                        <div
                            className={cn(
                                "flex items-center px-2",
                                trailingControlClassName,
                            )}
                            data-slot="trailing-control"
                        >
                            {trailingControl}
                        </div>
                    )}
                </div>
            </div>
        );
    }

    // CASE 3: controls present, but separate (no joined box)
    return (
        <div
            data-slot="select-field"
            className={cn(
                "flex items-stretch w-full",
                disabled && "opacity-50 cursor-not-allowed",
                className,
            )}
            aria-disabled={disabled || undefined}
            aria-invalid={error ? "true" : undefined}
        >
            {hasLeadingControl && (
                <div
                    className={cn(
                        "flex items-center mr-1",
                        leadingControlClassName,
                    )}
                    data-slot="leading-control"
                >
                    {leadingControl}
                </div>
            )}

            <div className="flex-1 min-w-0">{SelectWithTrigger}</div>

            {hasTrailingControl && (
                <div
                    className={cn(
                        "flex items-center ml-1",
                        trailingControlClassName,
                    )}
                    data-slot="trailing-control"
                >
                    {trailingControl}
                </div>
            )}
        </div>
    );
});

ShadcnSelectVariant.displayName = "ShadcnSelectVariant";

export default ShadcnSelectVariant;
```

---
#### 28


` File: packages/form-palette/src/presets/shadcn-variants/slider.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/slider.tsx

import * as React from "react";
import type { VariantBaseProps, ChangeDetail } from "@/variants/shared";
import { cn } from "@/lib/utils";
import { Slider } from "@/presets/ui/slider";

type SliderValue = number | undefined;

type Size = "sm" | "md" | "lg";
type Density = "compact" | "comfortable" | "loose";

export interface ShadcnSliderVariantProps
   extends Pick<
      VariantBaseProps<SliderValue>,
      | "value"
      | "onValue"
      | "error"
      | "disabled"
      | "readOnly"
      | "size"
      | "density"
   > {
   /**
    * Minimum value for the slider.
    * Default: 0
    */
   min?: number;

   /**
    * Maximum value for the slider.
    * Default: 100
    */
   max?: number;

   /**
    * Step between values.
    * Default: 1
    */
   step?: number;

   /**
    * Show the current value as text next to the slider.
    * Default: true
    */
   showValue?: boolean;

   /**
    * Where to place the value label, relative to the slider.
    * - "end"   → right of the slider (horizontal)
    * - "start" → left of the slider
    *
    * Default: "end"
    */
   valuePlacement?: "start" | "end";

   /**
    * Custom formatter for the numeric value.
    * If omitted, uses the raw number.
    */
   formatValue?: (value: SliderValue) => React.ReactNode;

   /**
    * Wrapper class for the entire slider field.
    */
   className?: string;

   /**
    * Extra classes for the Slider root.
    */
   sliderClassName?: string;

   /**
    * Extra classes for the value label.
    */
   valueClassName?: string;

   // ─────────────────────────────────────────────
   // Icons & controls (mirror text / select variants)
   // ─────────────────────────────────────────────

   /**
    * One or more icons displayed inside the slider region, on the left.
    *
    * If not provided and `icon` is set, that single icon
    * is treated as `leadingIcons[0]`.
    */
   leadingIcons?: React.ReactNode[];

   /**
    * Icons displayed on the right side of the slider region
    * (before/after the value label depending on placement).
    */
   trailingIcons?: React.ReactNode[];

   /**
    * Convenience single-icon prop for the left side.
    */
   icon?: React.ReactNode;

   /**
    * Base gap between icons and slider/value.
    * Defaults to 4px-ish via `gap-1`.
    */
   iconGap?: number;

   /**
    * Extra spacing to apply between leading icons and the slider track.
    */
   leadingIconSpacing?: number;

   /**
    * Extra spacing to apply between trailing icons and the value label.
    */
   trailingIconSpacing?: number;

   /**
    * Arbitrary React node rendered before the slider (e.g. a button).
    */
   leadingControl?: React.ReactNode;

   /**
    * Arbitrary React node rendered after the slider (e.g. a button).
    */
   trailingControl?: React.ReactNode;

   /**
    * Extra classes for the leading control wrapper.
    */
   leadingControlClassName?: string;

   /**
    * Extra classes for the trailing control wrapper.
    */
   trailingControlClassName?: string;

   /**
    * If true and there are controls, the slider + controls share
    * a single visual box (borders, radius, focus states).
    * Default: true (to match text/select behaviour).
    */
   joinControls?: boolean;

   /**
    * When joinControls is true, whether the box styling extends over controls
    * (true) or controls are visually separate (false).
    * Default: true.
    */
   extendBoxToControls?: boolean;

   // ─────────────────────────────────────────────
   // Built-in +/- control variants
   // ─────────────────────────────────────────────

   /**
    * Built-in +/- controls around the slider.
    *
    * - "none"  → no built-in step buttons (default)
    * - "boxed" → +/- inside the same frame as the slider
    * - "edge"  → loose layout: "- [ slider ] +"
    */
   controlVariant?: "none" | "boxed" | "edge";

   /**
    * Step used when clicking the +/- controls.
    * Defaults to `step`.
    */
   controlStep?: number;

   /**
    * Custom node for the decrement control. Default: "−".
    */
   controlDecrementIcon?: React.ReactNode;

   /**
    * Custom node for the increment control. Default: "+".
    */
   controlIncrementIcon?: React.ReactNode;
}

// ─────────────────────────────────────────────
// Helpers
// ─────────────────────────────────────────────

function sliderHeight(size?: Size): string {
   switch (size) {
      case "sm":
         return "h-7 text-xs";
      case "lg":
         return "h-10 text-base";
      case "md":
      default:
         return "h-9 text-sm";
   }
}

function sliderPadding(density?: Density): string {
   switch (density) {
      case "compact":
         return "py-1";
      case "loose":
         return "py-3";
      case "comfortable":
      default:
         return "py-2";
   }
}

function defaultFormatValue(value: SliderValue): React.ReactNode {
   if (value == null) return "—";
   return value;
}

function clampToRange(v: number, min: number, max: number): number {
   if (v < min) return min;
   if (v > max) return max;
   return v;
}

// ─────────────────────────────────────────────
// Component
// ─────────────────────────────────────────────

export const ShadcnSliderVariant = React.forwardRef<
   HTMLDivElement,
   ShadcnSliderVariantProps
>(function ShadcnSliderVariant(props, _ref) {
   const {
      value,
      onValue,
      error,
      disabled,
      readOnly,
      size,
      density,

      min = 0,
      max = 100,
      step = 1,

      showValue = true,
      valuePlacement = "end",
      formatValue,

      className,
      sliderClassName,
      valueClassName,

      // Icons & controls
      leadingIcons,
      trailingIcons,
      icon,
      iconGap,
      leadingIconSpacing,
      trailingIconSpacing,
      leadingControl,
      trailingControl,
      leadingControlClassName,
      trailingControlClassName,
      joinControls = true,
      extendBoxToControls = true,

      // Built-in +/- controls
      controlVariant = "none",
      controlStep,
      controlDecrementIcon,
      controlIncrementIcon,
   } = props;

   const numericValue: number =
      typeof value === "number" ? value : min;

   const isDisabled = !!(disabled || readOnly);

   const handleChange = React.useCallback(
      (vals: number[]) => {
         if (!onValue) return;
         const next = clampToRange(vals[0], min, max);

         const detail: ChangeDetail = {
            source: "variant",
            raw: next,
            nativeEvent: undefined,
            meta: undefined,
         };

         onValue(next, detail);
      },
      [onValue, min, max]
   );

   const stepAmount = controlStep ?? step;

   const applyStep = React.useCallback(
      (direction: -1 | 1) => {
         if (!onValue || isDisabled) return;

         const current =
            typeof value === "number" ? value : min;
         const candidate = current + direction * stepAmount;
         const next = clampToRange(candidate, min, max);

         const detail: ChangeDetail = {
            source: "variant",
            raw: next,
            nativeEvent: undefined,
            meta: {
               action: direction > 0 ? "increment" : "decrement",
            },
         };

         onValue(next, detail);
      },
      [onValue, value, isDisabled, min, max, stepAmount]
   );

   const heightCls = sliderHeight(size as Size | undefined);
   const paddingCls = sliderPadding(density as Density | undefined);

   const displayValue =
      (formatValue ?? defaultFormatValue)(value ?? numericValue);

   // Icons resolution (same idea as text/select)
   const resolvedLeadingIcons: React.ReactNode[] = (() => {
      if (leadingIcons && leadingIcons.length) return leadingIcons;
      if (icon) return [icon];
      return [];
   })();

   const resolvedTrailingIcons: React.ReactNode[] = trailingIcons ?? [];

   const baseIconGap = iconGap ?? 4;
   const leadingGap = leadingIconSpacing ?? baseIconGap;
   const trailingGap = trailingIconSpacing ?? baseIconGap;

   const hasLeadingIcons = resolvedLeadingIcons.length > 0;
   const hasTrailingIcons = resolvedTrailingIcons.length > 0;

   // Value label
   const valueNode =
      showValue ? (
         <div
            className={cn(
               "text-xs text-muted-foreground whitespace-nowrap",
               valueClassName
            )}
            data-slot="slider-value"
         >
            {displayValue}
         </div>
      ) : null;

   const baseBoxClasses = cn(
      "border-input w-full min-w-0 rounded-md border bg-transparent shadow-xs",
      "transition-[color,box-shadow] outline-none",
      "focus-within:border-ring focus-within:ring-ring/50 focus-within:ring-[3px]",
      "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive"
   );

   // ─────────────────────────────────────────────
   // Built-in +/- controls → map to leading/trailingControl
   // ─────────────────────────────────────────────

   let effectiveLeadingControl = leadingControl;
   let effectiveTrailingControl = trailingControl;
   let effectiveJoinControls = joinControls;

   if (controlVariant === "boxed" || controlVariant === "edge") {
      const decLabel =
         controlDecrementIcon ?? <span className="text-base">−</span>;
      const incLabel =
         controlIncrementIcon ?? <span className="text-base">+</span>;

      const decButton = (
         <button
            type="button"
            onClick={() => applyStep(-1)}
            disabled={isDisabled}
            className={cn(
               "inline-flex items-center justify-center px-2 text-sm",
               "disabled:opacity-50 disabled:cursor-not-allowed"
            )}
         >
            {decLabel}
         </button>
      );

      const incButton = (
         <button
            type="button"
            onClick={() => applyStep(1)}
            disabled={isDisabled}
            className={cn(
               "inline-flex items-center justify-center px-2 text-sm",
               "disabled:opacity-50 disabled:cursor-not-allowed"
            )}
         >
            {incLabel}
         </button>
      );

      // Only auto-wire if caller didn't override them.
      if (!effectiveLeadingControl) {
         effectiveLeadingControl = decButton;
      }
      if (!effectiveTrailingControl) {
         effectiveTrailingControl = incButton;
      }

      // Edge variant → loose layout: "- [ slider ] +"
      if (controlVariant === "edge") {
         effectiveJoinControls = false;
      }
   }

   const hasLeadingControl = !!effectiveLeadingControl;
   const hasTrailingControl = !!effectiveTrailingControl;
   const hasControls = hasLeadingControl || hasTrailingControl;

   // Inner slider+icons+value layout (no outer controls)
   const SliderRegion = (
      <div
         className={cn(
            "flex w-full items-center gap-2",
            heightCls,
            paddingCls
         )}
         data-slot="slider-region"
      >
         {/* value before slider */}
         {valuePlacement === "start" && valueNode && (
            <div className="shrink-0 mr-1">{valueNode}</div>
         )}

         {/* leading icons */}
         {hasLeadingIcons && (
            <span
               className="flex items-center gap-1 shrink-0"
               style={{ columnGap: leadingGap }}
               data-slot="leading-icons"
            >
               {resolvedLeadingIcons.map((node, idx) => (
                  <span
                     key={idx}
                     className="flex items-center justify-center"
                  >
                     {node}
                  </span>
               ))}
            </span>
         )}

         {/* slider track */}
         <div className="flex-1 min-w-0" data-slot="slider-track">
            <Slider
               value={[numericValue]}
               onValueChange={handleChange}
               min={min}
               max={max}
               step={step}
               disabled={isDisabled}
               className={cn("w-full", sliderClassName)}
            />
         </div>

         {/* trailing icons */}
         {hasTrailingIcons && (
            <span
               className="flex items-center gap-1 shrink-0"
               style={{ columnGap: trailingGap }}
               data-slot="trailing-icons"
            >
               {resolvedTrailingIcons.map((node, idx) => (
                  <span
                     key={idx}
                     className="flex items-center justify-center"
                  >
                     {node}
                  </span>
               ))}
            </span>
         )}

         {/* value after slider */}
         {valuePlacement === "end" && valueNode && (
            <div className="shrink-0 ml-1">{valueNode}</div>
         )}
      </div>
   );

   // ─────────────────────────────────────────────
   // Layout cases
   // ─────────────────────────────────────────────

   // CASE 1: no controls → just slider region
   if (!hasControls) {
      return (
         <div
            data-slot="slider-field"
            className={cn(
               "w-full flex items-center",
               isDisabled && "opacity-50 cursor-not-allowed",
               className
            )}
            aria-disabled={isDisabled || undefined}
            aria-invalid={error ? "true" : undefined}
         >
            {SliderRegion}
         </div>
      );
   }

   // CASE 2: controls + joinControls → single shared box (sketch #1: boxed)
   if (effectiveJoinControls) {
      const groupClassName = cn(
         "flex items-stretch w-full",
         extendBoxToControls &&
         cn(
            "relative",
            baseBoxClasses // focus ring via :focus-within
         ),
         !extendBoxToControls &&
         "relative border-none shadow-none bg-transparent",
         className
      );

      return (
         <div
            data-slot="slider-field"
            className="w-full"
            aria-disabled={isDisabled || undefined}
            aria-invalid={error ? "true" : undefined}
         >
            <div
               className={groupClassName}
               data-slot="slider-group"
               data-disabled={isDisabled ? "true" : "false"}
            >
               {hasLeadingControl && (
                  <div
                     className={cn(
                        "flex items-center px-2",
                        leadingControlClassName
                     )}
                     data-slot="leading-control"
                  >
                     {effectiveLeadingControl}
                  </div>
               )}

               <div
                  className="flex-1 min-w-0 flex items-stretch"
                  data-slot="slider-region-wrapper"
               >
                  {SliderRegion}
               </div>

               {hasTrailingControl && (
                  <div
                     className={cn(
                        "flex items-center px-2",
                        trailingControlClassName
                     )}
                     data-slot="trailing-control"
                  >
                     {effectiveTrailingControl}
                  </div>
               )}
            </div>
         </div>
      );
   }

   // CASE 3: controls present but separate boxes (sketch #2: edge)
   return (
      <div
         data-slot="slider-field"
         className={cn(
            "flex items-stretch w-full",
            isDisabled && "opacity-50 cursor-not-allowed",
            className
         )}
         aria-disabled={isDisabled || undefined}
         aria-invalid={error ? "true" : undefined}
      >
         {hasLeadingControl && (
            <div
               className={cn(
                  "flex items-center mr-1",
                  leadingControlClassName
               )}
               data-slot="leading-control"
            >
               {effectiveLeadingControl}
            </div>
         )}

         <div
            className="flex-1 min-w-0"
            data-slot="slider-region-outer"
         >
            {SliderRegion}
         </div>

         {hasTrailingControl && (
            <div
               className={cn(
                  "flex items-center ml-1",
                  trailingControlClassName
               )}
               data-slot="trailing-control"
            >
               {effectiveTrailingControl}
            </div>
         )}
      </div>
   );
});

ShadcnSliderVariant.displayName = "ShadcnSliderVariant";

export default ShadcnSliderVariant;
```

---
#### 29


` File: packages/form-palette/src/presets/shadcn-variants/text.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/ui/shadcn-variants/text.tsx
// noinspection GrazieInspection

import * as React from "react";

import { Input } from "@/presets/ui/input";
import type {
    ChangeDetail,
    ExtraFieldProps,
    VariantBaseProps,
} from "@/variants/shared";
import type { InputMaskChangeEvent } from "../ui/input-mask";

type MaskMode = "raw" | "masked";

/**
 * Mask-related props for the Shadcn text variant.
 *
 * These are forwarded to the underlying <Input>, which in turn wires
 * them into the InputMask implementation.
 */
export interface ShadcnTextMaskProps {
    /**
     * Mask pattern – Primereact style.
     * Example: "99/99/9999", "(999) 999-9999"
     */
    mask?: string;

    /**
     * Per-symbol definitions for slots.
     * Kept for future custom engine; not used by the current
     * react-input-mask implementation.
     */
    maskDefinitions?: Record<string, RegExp>;

    /**
     * Character used to visually represent an empty slot.
     * Default: "_".
     */
    slotChar?: string;

    /**
     * If true, when the value is effectively "empty" (no unmasked chars),
     * we emit an empty string "" instead of a fully-masked placeholder.
     *
     * NOTE: This behaviour is implemented in the variant, not Input,
     * so we preserve your existing semantics.
     */
    autoClear?: boolean;

    /**
     * Whether the *model* value is raw or masked.
     *
     * - "raw" or true   → onValue receives unmasked value
     * - "masked" or false/undefined → onValue receives full masked string
     *
     * NOTE: detail.raw is **always** the masked string.
     */
    unmask?: MaskMode | boolean;

    /**
     * Placeholder for future caret-mode logic when we go back
     * to a custom engine. Currently unused, kept for API compatibility.
     */
    maskInsertMode?: "stream" | "caret";
}

/**
 * Extra UI props for the Shadcn text input (pure HTML-level).
 *
 * These are forwarded straight to the underlying <Input />.
 */
export type ShadcnTextUiProps = Omit<
    React.InputHTMLAttributes<HTMLInputElement>,
    "value" | "defaultValue" | "onChange" | "size"
> & {
    /**
     * Extra classes applied only to the *inner* input element
     * (the actual <input>, not the wrapper box).
     */
    inputClassName?: string;

    /**
     * Fixed prefix rendered as part of the input value, NOT as an icon.
     * E.g. "₦", "ID: ".
     *
     * The underlying <Input> will:
     *  - take the model value (without prefix),
     *  - render prefix + value,
     *  - expose the full visible string in event.target.value.
     */
    prefix?: string;

    /**
     * Fixed suffix rendered as part of the input value, NOT as an icon.
     * E.g. "%", "kg".
     */
    suffix?: string;

    /**
     * If true (default), we strip the prefix from the value
     * before emitting it via `onValue`.
     */
    stripPrefix?: boolean;

    /**
     * If true (default), we strip the suffix from the value
     * before emitting it via `onValue`.
     */
    stripSuffix?: boolean;
} & ShadcnTextMaskProps;

/**
 * Props for the Shadcn-based text variant.
 *
 * This is a *form* wrapper around the base <Input />:
 *  - Handles value ↔ ChangeDetail mapping.
 *  - Delegates all visual concerns (masking, affixes, icons, controls,
 *    size, density) to the Input component.
 */
export type ShadcnTextVariantProps = ExtraFieldProps<
    VariantBaseProps<string | undefined>
> & {
    /**
     * If true and there are controls, the input + controls share one box
     * (borders, radius, focus states).
     *
     * Delegated to the underlying <Input />.
     */
    joinControls?: boolean;

    /**
     * When joinControls is true, whether the box styling extends over controls
     * (true) or controls are visually separate (false).
     */
    extendBoxToControls?: boolean;
} & ShadcnTextUiProps;

export const ShadcnTextVariant = React.forwardRef<
    HTMLInputElement,
    ShadcnTextVariantProps & ShadcnTextUiProps
>(function ShadcnTextVariant(props, forwardedRef) {
    const {
        // form-level props
        value,
        onValue,
        disabled,
        readOnly,
        required,
        error,
        size,
        density,

        // extras from VariantBaseProps / ExtraFieldProps
        leadingIcons,
        trailingIcons,
        icon,
        iconGap,
        leadingIconSpacing,
        trailingIconSpacing,
        leadingControl,
        trailingControl,
        leadingControlClassName,
        trailingControlClassName,
        px,
        py,
        ps,
        pe,
        pb,

        joinControls = true,
        extendBoxToControls = true,

        // masking
        mask,
        maskDefinitions,
        slotChar,
        autoClear,
        unmask,
        maskInsertMode,

        // affixes
        prefix,
        suffix,
        stripPrefix = true,
        stripSuffix = true,

        // visual props
        inputClassName,
        className,
        style,
        ...rest
    } = props;

    const isMasked = Boolean(mask);

    // ─────────────────────────────────────────────
    // Plain change handler (unmasked <Input />)
    // ─────────────────────────────────────────────

    const handlePlainChange = React.useCallback(
        (e: React.ChangeEvent<HTMLInputElement>) => {
            const displayed = e.target.value ?? "";

            let modelValue = displayed;

            // strip prefix if configured
            if (prefix && stripPrefix && modelValue.startsWith(prefix)) {
                modelValue = modelValue.slice(prefix.length);
            }

            // strip suffix if configured
            if (suffix && stripSuffix && modelValue.endsWith(suffix)) {
                modelValue = modelValue.slice(
                    0,
                    modelValue.length - suffix.length
                );
            }

            const detail: ChangeDetail = {
                source: "variant",
                raw: displayed, // actual visible value (with affixes)
                nativeEvent: e,
                meta: {
                    prefix,
                    suffix,
                    stripPrefix,
                    stripSuffix,
                    model: modelValue,
                },
            };

            onValue?.(modelValue, detail);
        },
        [onValue, prefix, suffix, stripPrefix, stripSuffix]
    );

    // ─────────────────────────────────────────────
    // Masked change handler (InputMask under <Input />)
    // ─────────────────────────────────────────────

    const handleMaskedChange = React.useCallback(
        (e: InputMaskChangeEvent) => {
            const maskedValue = e.value ?? "";

            // Same heuristic as your original variant:
            // "Unmasked" = characters that would normally be accepted by masks.
            const unmaskedInner =
                maskedValue.match(/[0-9A-Za-z]/g)?.join("") ?? "";

            const mode: MaskMode =
                unmask === true || unmask === "raw" ? "raw" : "masked";

            // IMPORTANT: detail.raw is ALWAYS the masked value.
            const detail: ChangeDetail = {
                source: "variant",
                raw: maskedValue,
                nativeEvent: e.originalEvent as any,
                meta: {
                    masked: maskedValue,
                    unmasked: unmaskedInner,
                    mode,
                    prefix,
                    suffix,
                },
            };

            let emitValue = mode === "raw" ? unmaskedInner : maskedValue;

            // autoClear: if nothing "real" was typed, treat as empty.
            if (autoClear && unmaskedInner.length === 0) {
                emitValue = "";
            }

            onValue?.(emitValue, detail);
        },
        [onValue, unmask, autoClear, prefix, suffix]
    );

    // Variant-level "model" is always the raw value you store.
    // The underlying <Input> is responsible for visually applying prefix/suffix
    // or mask literals on top of this model.
    const modelValue = value ?? "";

    return (
        <Input
            ref={forwardedRef}
            // visual & sizing
            className={className}
            style={style}
            size={size as any}
            density={density as any}
            inputClassName={inputClassName}
            // flags
            disabled={disabled}
            readOnly={readOnly}
            required={required}
            aria-invalid={error ? "true" : undefined}
            // masking
            mask={mask}
            maskDefinitions={maskDefinitions}
            slotChar={slotChar}
            autoClear={autoClear}
            unmask={unmask}
            maskInsertMode={maskInsertMode}
            // affixes (value-level, not icons)
            prefix={prefix}
            suffix={suffix}
            stripPrefix={stripPrefix}
            stripSuffix={stripSuffix}
            // icons & controls
            leadingIcons={leadingIcons}
            trailingIcons={trailingIcons}
            icon={icon}
            iconGap={iconGap}
            leadingIconSpacing={leadingIconSpacing}
            trailingIconSpacing={trailingIconSpacing}
            leadingControl={leadingControl}
            trailingControl={trailingControl}
            leadingControlClassName={leadingControlClassName}
            trailingControlClassName={trailingControlClassName}
            joinControls={joinControls}
            extendBoxToControls={extendBoxToControls}
            px={px}
            py={py}
            ps={ps}
            pe={pe}
            pb={pb}
            // value & event mapping
            value={modelValue}
            onChange={
                isMasked
                    ? (handleMaskedChange as any)
                    : (handlePlainChange as any)
            }
            {...rest}
        />
    );
});

ShadcnTextVariant.displayName = "ShadcnTextVariant";

export default ShadcnTextVariant;
```

---
#### 30


` File: packages/form-palette/src/presets/shadcn-variants/textarea.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/textarea.tsx

import * as React from "react";

import type { VariantBaseProps, ChangeDetail } from "@/variants/shared";
import { Textarea } from "@/presets/ui/textarea";
import type { TextareaProps as UiTextareaProps } from "@/presets/ui/textarea";

type TextareaValue = string | undefined;
type BaseProps = VariantBaseProps<TextareaValue>;

/**
 * Full props for the Shadcn-based textarea variant.
 *
 * - Reuses all UI-level behaviour from `Textarea` (autoResize, upperControl,
 *   leading/trailing controls, icons, size/density, padding knobs, etc.).
 * - Takes over `value` / `onChange` so it can emit through `onValue` with
 *   a `ChangeDetail`.
 */
export interface ShadcnTextareaVariantProps
   extends Omit<UiTextareaProps, "value" | "defaultValue" | "onChange">,
   Pick<BaseProps, "value" | "onValue" | "error"> { }

export const ShadcnTextareaVariant = React.forwardRef<
   HTMLTextAreaElement,
   ShadcnTextareaVariantProps
>(function ShadcnTextareaVariant(props, ref) {
   const {
      value,
      onValue,
      error,
      // everything else goes straight to the UI Textarea
      ...rest
   } = props;

   const handleChange = React.useCallback(
      (event: React.ChangeEvent<HTMLTextAreaElement>) => {
         const next = event.target.value ?? "";

         const detail: ChangeDetail = {
            source: "variant",
            raw: next,
            nativeEvent: event,
            meta: undefined,
         };

         // empty string → undefined, same convention as text/chips
         onValue?.(next.length ? next : undefined, detail);
      },
      [onValue],
   );

   return (
      <Textarea
         ref={ref}
         {...rest}
         value={value ?? ""}
         onChange={handleChange}
         aria-invalid={error ? "true" : undefined}
      />
   );
});

ShadcnTextareaVariant.displayName = "ShadcnTextareaVariant";

export default ShadcnTextareaVariant;
```

---
#### 31


` File: packages/form-palette/src/presets/shadcn-variants/toggle-group.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/toggle.tsx

import * as React from "react";
import type { VariantBaseProps, ChangeDetail } from "@/variants/shared";
import { cn } from "@/lib/utils";
import { ToggleGroup, ToggleGroupItem } from "@/presets/ui/toggle-group";
import {
    Tooltip,
    TooltipContent,
    TooltipProvider,
    TooltipTrigger,
} from "@/presets/ui/tooltip";

// ─────────────────────────────────────────────
// Types
// ─────────────────────────────────────────────

export interface ToggleOption {
    label: React.ReactNode;
    value: string;
    icon?: React.ReactNode;
    disabled?: boolean;
    tooltip?: React.ReactNode;
    meta?: any;
}

/**
 * Allow primitive options as shorthand:
 * - "free" → { value: "free", label: "free" }
 */
export type ToggleOptionInput = ToggleOption | string | number | boolean;

export interface ShadcnToggleVariantProps
    extends Pick<
        VariantBaseProps<string | string[]>,
        | "value"
        | "onValue"
        | "error"
        | "disabled"
        | "readOnly"
        | "size"
        | "density"
    > {
    /**
     * Options for the toggle group.
     *
     * Can be:
     * - ToggleOption objects
     * - Primitive strings/numbers/booleans (shorthand)
     * - Objects using option* keys (optionValue, optionLabel, etc.)
     */
    options: ToggleOptionInput[];

    multiple?: boolean;
    variant?: "default" | "outline";
    layout?: "horizontal" | "vertical" | "grid";
    gridCols?: number;
    fillWidth?: boolean;

    /**
     * Property name to read the option value from, when using
     * custom option objects.
     *
     * If omitted, falls back to:
     *   - obj.value
     *   - or the primitive itself (for primitive options)
     */
    optionValue?: string;

    /**
     * Property name to read the option label from, when using
     * custom option objects.
     *
     * If omitted, falls back to:
     *   - obj.label
     *   - or String(value)
     */
    optionLabel?: string;

    /**
     * Property name to read an icon node from, when using
     * custom option objects.
     *
     * If omitted, falls back to obj.icon.
     */
    optionIcon?: string;

    /**
     * Property name to read disabled flag from, when using
     * custom option objects.
     *
     * If omitted, falls back to obj.disabled.
     */
    optionDisabled?: string;

    /**
     * Property name to read tooltip content from, when using
     * custom option objects.
     *
     * If omitted, falls back to obj.tooltip.
     */
    optionTooltip?: string;

    /**
     * Property name to read meta from, when using custom option objects.
     *
     * If omitted, falls back to obj.meta.
     */
    optionMeta?: string;

    /**
     * Optional custom renderer for each option.
     * Receives the normalized ToggleOption and selected state.
     */
    renderOption?: (
        option: ToggleOption,
        isSelected: boolean
    ) => React.ReactNode;

    className?: string;

    /** Base class for all items */
    itemClassName?: string;

    /** Class applied ONLY to selected items (overrides/merges with default active styles) */
    activeClassName?: string;

    /**
     * When true, capitalizes the first letter of the label
     * (only applied when the label is a string).
     */
    autoCap?: boolean;

    /**
     * Gap between buttons in pixels.
     *
     * - Applies to both flex (horizontal/vertical) and grid layouts.
     * - If omitted, falls back to Tailwind gap classes.
     */
    gap?: number;
}

// Internal normalized shape, tracking original item
interface NormalizedToggle<T = ToggleOptionInput> {
    ui: ToggleOption;
    raw: T;
}

// ─────────────────────────────────────────────
// Helpers
// ─────────────────────────────────────────────

function mapSizeToToggleSize(size?: "sm" | "md" | "lg") {
    switch (size) {
        case "sm":
            return "sm";
        case "lg":
            return "lg";
        case "md":
        default:
            return "default";
    }
}

function normalizeValue(
    val: string | string[] | undefined | null,
    multiple: boolean
): string | string[] {
    if (multiple) {
        if (Array.isArray(val)) return val;
        if (typeof val === "string") return [val];
        return [];
    }
    // Single mode
    if (Array.isArray(val)) return val[0] || "";
    return val || "";
}

function capitalizeFirst(label: string): string {
    if (!label) return label;
    return label.charAt(0).toUpperCase() + label.slice(1);
}

/**
 * Normalize a ToggleOptionInput into a full ToggleOption,
 * using option* keys when present.
 *
 * autoCap is only applied to string labels for display.
 */
function normalizeOption(
    input: ToggleOptionInput,
    {
        optionValue,
        optionLabel,
        optionIcon,
        optionDisabled,
        optionTooltip,
        optionMeta,
    }: {
        optionValue?: string;
        optionLabel?: string;
        optionIcon?: string;
        optionDisabled?: string;
        optionTooltip?: string;
        optionMeta?: string;
    },
    autoCap: boolean
): NormalizedToggle {
    const anyInput = input as any;

    // 1) Custom object with option* keys
    if (
        optionValue ||
        optionLabel ||
        optionIcon ||
        optionDisabled ||
        optionTooltip ||
        optionMeta
    ) {
        const rawValue =
            optionValue != null
                ? anyInput[optionValue]
                : (anyInput.value ?? input);
        const value = String(rawValue);

        let label: React.ReactNode;
        if (optionLabel != null) {
            label = anyInput[optionLabel];
        } else if (anyInput.label != null) {
            label = anyInput.label;
        } else {
            label = String(rawValue ?? value);
        }

        if (autoCap && typeof label === "string") {
            label = capitalizeFirst(label);
        }

        const icon =
            optionIcon != null
                ? anyInput[optionIcon]
                : (anyInput.icon ?? undefined);
        const disabled =
            optionDisabled != null
                ? !!anyInput[optionDisabled]
                : !!anyInput.disabled;
        const tooltip =
            optionTooltip != null
                ? anyInput[optionTooltip]
                : (anyInput.tooltip ?? undefined);
        const meta =
            optionMeta != null
                ? anyInput[optionMeta]
                : (anyInput.meta ?? undefined);

        return {
            ui: {
                value,
                label,
                icon,
                disabled,
                tooltip,
                meta,
            },
            raw: input,
        };
    }

    // 2) Primitive shorthand
    if (
        typeof input === "string" ||
        typeof input === "number" ||
        typeof input === "boolean"
    ) {
        const value = String(input);
        let label: React.ReactNode = value;
        if (autoCap && typeof label === "string") {
            label = capitalizeFirst(label);
        }

        return {
            ui: {
                value,
                label,
            },
            raw: input,
        };
    }

    // 3) Already a ToggleOption-like object
    const baseValue = anyInput.value ?? String(anyInput.label ?? "");
    const value = String(baseValue);

    let label: React.ReactNode =
        anyInput.label != null ? anyInput.label : String(value);
    if (autoCap && typeof label === "string") {
        label = capitalizeFirst(label);
    }

    return {
        ui: {
            value,
            label,
            icon: anyInput.icon,
            disabled: !!anyInput.disabled,
            tooltip: anyInput.tooltip,
            meta: anyInput.meta,
        },
        raw: input,
    };
}

// ─────────────────────────────────────────────
// Component
// ─────────────────────────────────────────────

export const ShadcnToggleVariant = React.forwardRef<
    HTMLDivElement,
    ShadcnToggleVariantProps
>(function ShadcnToggleVariant(props, ref) {
    const {
        value,
        onValue,
        disabled,
        readOnly,
        error,
        size = "md",

        options = [],
        multiple = false,
        variant = "default",
        layout = "horizontal",
        gridCols = 2,
        fillWidth: fullWidth = false,

        optionValue,
        optionLabel,
        optionIcon,
        optionDisabled,
        optionTooltip,
        optionMeta,

        renderOption,
        className,
        itemClassName,
        activeClassName,
        autoCap = false,
        gap: itemGapPx,
    } = props;

    const isDisabled = Boolean(disabled || readOnly);
    const toggleSize = mapSizeToToggleSize(size as any);
    const currentValue = normalizeValue(value, multiple);

    const normalizedOptions = React.useMemo(
        () =>
            options.map((opt) =>
                normalizeOption(
                    opt,
                    {
                        optionValue,
                        optionLabel,
                        optionIcon,
                        optionDisabled,
                        optionTooltip,
                        optionMeta,
                    },
                    autoCap
                )
            ),
        [
            options,
            optionValue,
            optionLabel,
            optionIcon,
            optionDisabled,
            optionTooltip,
            optionMeta,
            autoCap,
        ]
    );

    // ─────────────────────────────────────────────
    // Handlers
    // ─────────────────────────────────────────────

    const handleChange = React.useCallback(
        (val: string | string[]) => {
            if (readOnly) return;
            if (!onValue) return;

            let rawSelection:
                | ToggleOptionInput
                | ToggleOptionInput[]
                | undefined;

            if (Array.isArray(val)) {
                const selected = normalizedOptions.filter((entry) =>
                    val.includes(entry.ui.value)
                );
                rawSelection = selected.map((entry) => entry.raw);
            } else {
                const found = normalizedOptions.find(
                    (entry) => entry.ui.value === val
                );
                rawSelection = found?.raw;
            }

            const detail: ChangeDetail = {
                source: "variant",
                raw: rawSelection, // original item(s)
                nativeEvent: undefined,
                meta: { action: "toggle" },
            };

            onValue(val, detail);
        },
        [onValue, readOnly, normalizedOptions]
    );

    // ─────────────────────────────────────────────
    // Layout Logic
    // ─────────────────────────────────────────────

    const layoutClasses = cn(
        layout === "horizontal" && "flex flex-wrap",
        layout === "vertical" && "flex flex-col items-stretch",
        layout === "grid" && "grid",
        fullWidth && "w-full",
        fullWidth && layout === "horizontal" && "[&>*]:flex-1",
        fullWidth && layout === "vertical" && "[&>*]:w-full",
        className
    );

    console.log(layoutClasses, fullWidth, autoCap);
    const groupStyle: React.CSSProperties | undefined = React.useMemo(() => {
        const style: React.CSSProperties = {};

        if (layout === "grid") {
            style.gridTemplateColumns = `repeat(${gridCols}, minmax(0, 1fr))`;
        }

        if (typeof itemGapPx === "number") {
            style.gap = itemGapPx;
        }

        return Object.keys(style).length ? style : undefined;
    }, [layout, gridCols, itemGapPx]);

    // ─────────────────────────────────────────────
    // Render
    // ─────────────────────────────────────────────

    return (
        <ToggleGroup
            ref={ref}
            type={multiple ? "multiple" : "single"}
            value={currentValue as any}
            onValueChange={handleChange}
            disabled={isDisabled}
            variant={variant}
            size={toggleSize}
            className={layoutClasses}
            style={groupStyle}
            aria-invalid={!!error}
        >
            {normalizedOptions.map(({ ui: opt }) => {
                const isSelected = multiple
                    ? (currentValue as string[]).includes(opt.value)
                    : currentValue === opt.value;

                const contentNode = renderOption ? (
                    renderOption(opt, isSelected)
                ) : (
                    <div className="flex items-center gap-2 truncate">
                        {opt.icon && (
                            <span className="shrink-0">{opt.icon}</span>
                        )}
                        <span className="truncate">{opt.label}</span>
                    </div>
                );

                const itemNode = (
                    <ToggleGroupItem
                        key={opt.value}
                        value={opt.value}
                        disabled={opt.disabled}
                        aria-label={
                            typeof opt.label === "string"
                                ? opt.label
                                : opt.value
                        }
                        className={cn(
                            // Base Transitions
                            "transition-all",

                            // Default Active State (Shadcn defaults)
                            "data-[state=on]:bg-primary data-[state=on]:text-primary-foreground",

                            // Error State
                            error &&
                                "border-destructive/50 hover:bg-destructive/10 data-[state=on]:bg-destructive data-[state=on]:text-destructive-foreground",

                            // Variant: Outline specific tweaks
                            variant === "outline" &&
                                layout === "horizontal" &&
                                !fullWidth &&
                                "first:rounded-l-md last:rounded-r-md rounded-none border-l-0 first:border-l",

                            // Layout tweaks
                            fullWidth && "justify-center",

                            // Custom Item Class
                            itemClassName,

                            // Active Class Name (Applied only when selected)
                            isSelected && activeClassName
                        )}
                    >
                        {contentNode}
                    </ToggleGroupItem>
                );

                if (opt.tooltip && !isDisabled) {
                    return (
                        <TooltipProvider key={opt.value} delayDuration={300}>
                            <Tooltip>
                                <TooltipTrigger asChild>
                                    {itemNode}
                                </TooltipTrigger>
                                <TooltipContent>
                                    <p>{opt.tooltip}</p>
                                </TooltipContent>
                            </Tooltip>
                        </TooltipProvider>
                    );
                }

                return itemNode;
            })}
        </ToggleGroup>
    );
});

ShadcnToggleVariant.displayName = "ShadcnToggleVariant";
export default ShadcnToggleVariant;
```

---
#### 32


` File: packages/form-palette/src/presets/shadcn-variants/toggle.tsx`  [↑ Back to top](#index)

```tsx
// src/presets/shadcn-variants/toggle.tsx

import * as React from "react";

import type { VariantBaseProps, ChangeDetail } from "@/variants/shared";
import { cn } from "@/lib/utils";
import { Switch } from "@/presets/ui/switch"; // adjust path if your Switch lives elsewhere

type ToggleValue = boolean | undefined;
type BaseProps = VariantBaseProps<ToggleValue>;

type Size = "sm" | "md" | "lg";
type Density = "default" | "dense";

/**
 * UI props specific to the Shadcn-based toggle.
 *
 * This uses Switch as the underlying control, but we keep
 * the API surface small and focused.
 */
export interface ShadcnToggleUiProps
   extends Omit<
      React.ComponentProps<typeof Switch>,
      "checked" | "onCheckedChange" | "className" | 'defaultValue' | 'onChange'
   > {
   /**
    * Visual size of the switch / text.
    * Default: "md".
    */
   size?: Size;

   /**
    * Row density (vertical padding & gap).
    * Default: "default".
    */
   density?: Density;

   /**
    * Place the switch on the left or right of the state text.
    * Default: "left".
    */
   controlPlacement?: "left" | "right";

   /**
    * Optional state text shown next to the control when ON.
    */
   onText?: React.ReactNode;

   /**
    * Optional state text shown next to the control when OFF.
    */
   offText?: React.ReactNode;

   /**
    * Wrapper class for the whole toggle row.
    */
   className?: string;

   /**
    * Extra classes for the Switch root.
    */
   switchClassName?: string;

   /**
    * Extra classes for the Switch thumb.
    * (Your patched Switch should support thumbClassName.)
    */
   switchThumbClassName?: string;
}

/**
 * Full props for the Shadcn-based toggle variant.
 *
 * We only pick value/onValue/error from the variant base props;
 * everything else (id, disabled, aria-*) flows via Switch props.
 */
export type ShadcnToggleVariantProps = ShadcnToggleUiProps &
   Pick<BaseProps, "value" | "onValue" | "error">;

// ─────────────────────────────────────────────
// Helpers
// ─────────────────────────────────────────────

function rowGap(density: Density) {
   return density === "dense" ? "gap-2" : "gap-3";
}

function rowPadding(density: Density) {
   return density === "dense" ? "py-0.5" : "py-1";
}

function textSize(size: Size) {
   if (size === "sm") return "text-sm";
   if (size === "lg") return "text-base";
   return "text-sm";
}

// Map size → Switch track + thumb sizing
function switchRootSize(size: Size) {
   if (size === "sm") return "h-5 w-9";
   if (size === "lg") return "h-7 w-12";
   // default shadcn-ish base
   return "h-[1.15rem] w-8";
}

function switchThumbSize(size: Size) {
   if (size === "sm") return "size-3.5";
   if (size === "lg") return "size-5";
   return "size-4";
}

// ─────────────────────────────────────────────
// Component
// ─────────────────────────────────────────────

export const ShadcnToggleVariant = React.forwardRef<
   HTMLButtonElement,
   ShadcnToggleVariantProps
>(function ShadcnToggleVariant(props, _ref) {
   const {
      // variant bits
      value,
      onValue,
      error,

      // UI config
      size = "md",
      density = "default",
      controlPlacement = "left",
      onText,
      offText,
      className,
      switchClassName,
      switchThumbClassName,

      // Switch passthroughs
      disabled,
      id,
      "aria-describedby": describedBy,
      ...restSwitchProps
   } = props;

   const checked = !!value;

   const handleToggle = React.useCallback(
      (next: boolean) => {
         const nextVal = !!next;
         const detail: ChangeDetail = {
            source: "variant",
            raw: nextVal,
            nativeEvent: undefined,
            meta: undefined,
         };
         onValue?.(nextVal, detail);
      },
      [onValue],
   );

   const rowCls = cn(
      "flex w-fit items-center",
      rowGap(density),
      rowPadding(density),
   );

   const stateText =
      onText != null || offText != null ? (
         <span
            className={cn("select-none text-muted-foreground", textSize(size))}
         >
            {checked ? onText : offText}
         </span>
      ) : null;

   const switchEl = (
      <Switch
         id={id}
         checked={checked}
         onCheckedChange={handleToggle}
         disabled={disabled}
         aria-describedby={describedBy}
         aria-checked={checked}
         className={cn(switchRootSize(size), switchClassName)}
         thumbClassName={cn(switchThumbSize(size), switchThumbClassName)}
         {...restSwitchProps}
      />
   );

   return (
      <div
         data-slot="toggle-field"
         className={cn(
            "w-fit",
            disabled && "opacity-50 cursor-not-allowed",
            className,
         )}
         aria-disabled={disabled || undefined}
         aria-invalid={error ? "true" : undefined}
      >
         <div className={rowCls}>
            {controlPlacement === "left" ? (
               <>
                  {switchEl}
                  {stateText}
               </>
            ) : (
               <>
                  {stateText}
                  {switchEl}
               </>
            )}
         </div>
      </div>
   );
});

ShadcnToggleVariant.displayName = "ShadcnToggleVariant";

export default ShadcnToggleVariant;
```

---
#### 33


` File: packages/form-palette/src/presets/shadcn-variants/tree-select-types.ts`  [↑ Back to top](#index)

```ts
import React from "react";

export type TreeKey = string | number;
export type TreeValue = TreeKey | TreeKey[] | undefined;

export type TreeSelectOption =
    | TreeKey
    | {
          label?: React.ReactNode;
          value?: TreeKey;
          description?: React.ReactNode;
          disabled?: boolean;
          icon?: React.ReactNode;
          children?: TreeSelectOption[];
          [key: string]: any;
      };

export type NormalizedTreeItem = {
    key: string;
    value: TreeKey;
    labelNode: React.ReactNode;
    labelText: string;
    description?: React.ReactNode;
    disabled?: boolean;
    icon?: React.ReactNode;
    level: number;
    parentValue?: TreeKey;
    path: TreeKey[]; // ancestors only (not including self)
    hasChildren: boolean;
    children: NormalizedTreeItem[];
    raw: TreeSelectOption;
};
```

---
#### 34


` File: packages/form-palette/src/presets/shadcn-variants/treeselect.tsx`  [↑ Back to top](#index)

```tsx
import * as React from "react";
import type { VariantBaseProps, ChangeDetail } from "@/variants/shared";
import { cn } from "@/lib/utils";
import { Checkbox } from "@/presets/ui/checkbox";
import { Badge } from "@/presets/ui/badge";
import { Popover, PopoverTrigger, PopoverContent } from "@/presets/ui/popover";
import {
    ChevronDown,
    ChevronRight,
    Search,
    X,
    Folder,
    FolderOpen,
    File,
    Check,
} from "lucide-react";
import { normalizeTree, type NormalizedTreeItemWithRender } from "@/lib/normalise-options";
import {
    NormalizedTreeItem,
    TreeKey,
    TreeSelectOption,
    TreeValue,
} from "@/presets/shadcn-variants/tree-select-types";

type Size = "sm" | "md" | "lg";
type Density = "compact" | "comfortable" | "loose";

// ─────────────────────────────────────────────
// Helpers
// ─────────────────────────────────────────────

function flattenTree(
    nodes: NormalizedTreeItemWithRender[]
): NormalizedTreeItemWithRender[] {
    const result: NormalizedTreeItemWithRender[] = [];
    function recurse(list: NormalizedTreeItemWithRender[]) {
        for (const node of list) {
            result.push(node);
            if (node.children.length) recurse(node.children);
        }
    }
    recurse(nodes);
    return result;
}

function toggleInArray(
    arr: TreeKey[] | undefined,
    key: TreeKey
): TreeKey[] | undefined {
    const list = arr ?? [];
    const idx = list.findIndex((v) => v === key);
    if (idx === -1) return [...list, key];
    const next = [...list];
    next.splice(idx, 1);
    return next.length ? next : undefined;
}

function densityClasses(density?: Density) {
    switch (density) {
        case "compact":
            return {
                triggerPy: "py-1",
                searchPy: "py-2",
                rowPy: "py-1",
                rowGap: "gap-1.5",
            };
        case "loose":
            return {
                triggerPy: "py-2.5",
                searchPy: "py-3",
                rowPy: "py-2",
                rowGap: "gap-2.5",
            };
        default:
            return {
                triggerPy: "py-2",
                searchPy: "py-2.5",
                rowPy: "py-1.5",
                rowGap: "gap-2",
            };
    }
}

function triggerHeight(size?: Size) {
    switch (size) {
        case "sm":
            return "min-h-8 text-xs";
        case "lg":
            return "min-h-11 text-base";
        default:
            return "min-h-9 text-sm";
    }
}

type BadgeVariant = "default" | "secondary" | "destructive" | "outline";

// ─────────────────────────────────────────────
// Props
// ─────────────────────────────────────────────

type TreeSelectBaseProps = Pick<
    VariantBaseProps<TreeValue>,
    "value" | "onValue" | "error" | "disabled" | "readOnly" | "size" | "density"
> & {
    options?: TreeSelectOption[];

    /**
     * If true, allows multiple selection (checkboxes).
     * If false, allows single selection (no checkboxes, closes on select).
     * Default: true
     */
    multiple?: boolean;

    autoCap?: boolean;
    optionLabel?: string | ((item: TreeSelectOption) => React.ReactNode);
    optionValue?: string | ((item: TreeSelectOption) => TreeKey);
    optionDescription?: string | ((item: TreeSelectOption) => React.ReactNode);
    optionDisabled?: string | ((item: TreeSelectOption) => boolean);
    optionIcon?: string | ((item: TreeSelectOption) => React.ReactNode);
    optionKey?: string | ((item: TreeSelectOption, index: number) => React.Key);

    searchable?: boolean;
    searchPlaceholder?: string;
    emptyLabel?: React.ReactNode;
    emptySearchText?: React.ReactNode;
    clearable?: boolean;
    placeholder?: React.ReactNode;

    className?: string;
    triggerClassName?: string;
    contentClassName?: string;

    renderOption?: (ctx: {
        item: NormalizedTreeItem;
        selected: boolean;
        index: number;
        option: React.ReactNode;
        click(): void;
    }) => React.ReactNode;

    renderValue?: (ctx: {
        selectedItems: NormalizedTreeItem[];
        placeholder?: React.ReactNode;
    }) => React.ReactNode;

    expandAll?: boolean;
    defaultExpandedValues?: TreeKey[];
    leafOnly?: boolean;
};

type TreeSelectDefaultModeProps = {
    mode?: "default";

    // Icons & controls (default mode only)
    leadingIcons?: React.ReactNode[];
    trailingIcons?: React.ReactNode[];
    icon?: React.ReactNode;
    iconGap?: number;
    leadingIconSpacing?: number;
    trailingIconSpacing?: number;

    leadingControl?: React.ReactNode;
    trailingControl?: React.ReactNode;
    leadingControlClassName?: string;
    trailingControlClassName?: string;

    joinControls?: boolean;
    extendBoxToControls?: boolean;

    // Not supported in default mode
    button?: never;
    children?: never;
    selectedBadge?: never;
    selectedBadgeHiddenWhenZero?: never;
    selectedBadgeVariant?: never;
    selectedBadgeClassName?: never;
    selectedBadgePlacement?: never;
};

type TreeSelectButtonModeButton =
    | React.ReactNode
    | ((ctx: {
          open: boolean;
          selectedItems: NormalizedTreeItem[];
          selectedCount: number;
      }) => React.ReactNode);

type TreeSelectButtonModeProps = {
    mode: "button";

    /**
     * Used when mode="button". If provided, this is the trigger.
     * If not provided, `children` is used.
     */
    button?: TreeSelectButtonModeButton;

    children?: TreeSelectButtonModeButton;

    /**
     * Selected-count badge (mode="button" only)
     */
    selectedBadge?: boolean;
    selectedBadgeHiddenWhenZero?: boolean;
    selectedBadgeVariant?: BadgeVariant;
    selectedBadgeClassName?: string;
    selectedBadgePlacement?: "end" | "corner";

    // Icons & controls NOT supported in button mode
    leadingIcons?: never;
    trailingIcons?: never;
    icon?: never;
    iconGap?: never;
    leadingIconSpacing?: never;
    trailingIconSpacing?: never;

    leadingControl?: never;
    trailingControl?: never;
    leadingControlClassName?: never;
    trailingControlClassName?: never;

    joinControls?: never;
    extendBoxToControls?: never;
};

export type ShadcnTreeSelectVariantProps = TreeSelectBaseProps &
    (TreeSelectDefaultModeProps | TreeSelectButtonModeProps);

// ─────────────────────────────────────────────
// Component
// ─────────────────────────────────────────────

export const ShadcnTreeSelectVariant = React.forwardRef<
    HTMLButtonElement,
    ShadcnTreeSelectVariantProps
>(function ShadcnTreeSelectVariant(props, ref) {
    const {
        value,
        onValue,
        disabled,
        readOnly,
        size,
        density,

        options,
        multiple = true,

        autoCap,
        optionLabel,
        optionValue,
        optionDescription,
        optionDisabled,
        optionIcon,
        optionKey,

        searchable = true,
        searchPlaceholder,

        emptyLabel,
        emptySearchText,

        clearable = true,
        placeholder,

        className,
        triggerClassName,
        contentClassName,

        renderOption,
        renderValue,

        expandAll = false,
        defaultExpandedValues,
        leafOnly = false,

        // Icons & controls
        leadingIcons,
        trailingIcons,
        icon,
        iconGap,
        leadingIconSpacing,
        trailingIconSpacing,
        leadingControl,
        trailingControl,
        leadingControlClassName,
        trailingControlClassName,
        joinControls = true,
        extendBoxToControls = true,

        mode = "default",
        button,
        children,

        selectedBadge = true,
        selectedBadgeHiddenWhenZero = true,
        selectedBadgeVariant = "secondary",
        selectedBadgeClassName,
        selectedBadgePlacement = "corner",
    } = props;

    const [open, setOpen] = React.useState(false);
    const [query, setQuery] = React.useState("");

    const isDisabled = disabled || readOnly;
    const d = React.useMemo(
        () => densityClasses(density as Density),
        [density]
    );

    // Normalize tree
    const tree = React.useMemo(
        () =>
            normalizeTree(options ?? [], {
                autoCap,
                optionLabel,
                optionValue,
                optionDescription,
                optionDisabled,
                optionIcon,
                optionKey,
            }),
        [
            options,
            autoCap,
            optionLabel,
            optionValue,
            optionDescription,
            optionDisabled,
            optionIcon,
            optionKey,
        ]
    );

    const allNodesFlat = React.useMemo(() => flattenTree(tree), [tree]);

    // Expanded tracking (derive)
    const computedInitialExpanded = React.useMemo(() => {
        if (expandAll) {
            return new Set<TreeKey>(
                allNodesFlat.filter((n) => n.hasChildren).map((n) => n.value)
            );
        }
        if (defaultExpandedValues?.length) {
            return new Set<TreeKey>(defaultExpandedValues);
        }
        return new Set<TreeKey>();
    }, [expandAll, defaultExpandedValues, allNodesFlat]);

    const [expanded, setExpanded] = React.useState<Set<TreeKey>>(
        computedInitialExpanded
    );

    // Re-sync expanded when inputs/options change
    React.useEffect(() => {
        setExpanded(computedInitialExpanded);
    }, [computedInitialExpanded]);

    const toggleExpanded = React.useCallback((key: TreeKey) => {
        setExpanded((prev) => {
            const next = new Set(prev);
            if (next.has(key)) next.delete(key);
            else next.add(key);
            return next;
        });
    }, []);

    const displayedNodes = React.useMemo(() => {
        if (query) {
            const q = query.toLowerCase();
            const matchSet = new Set<TreeKey>();

            const checkMatch = (node: NormalizedTreeItem): boolean => {
                const selfMatch = node.labelText.toLowerCase().includes(q);
                const childMatch = node.children.some(checkMatch);
                if (selfMatch || childMatch) {
                    matchSet.add(node.value);
                    node.path.forEach((p) => matchSet.add(p));
                    return true;
                }
                return false;
            };

            tree.forEach(checkMatch);
            return allNodesFlat.filter((n) => matchSet.has(n.value));
        }

        return allNodesFlat.filter((node) => {
            if (node.level === 0) return true;
            for (const ancestorKey of node.path) {
                if (!expanded.has(ancestorKey)) return false;
            }
            return true;
        });
    }, [allNodesFlat, query, tree, expanded]);

    // Selection normalization
    const selectedValues = React.useMemo<TreeKey[]>(() => {
        if (value === undefined || value === null) return [];
        if (Array.isArray(value)) {
            return multiple ? value : value.length ? [value[0] as TreeKey] : [];
        }
        return [value];
    }, [value, multiple]);

    const selectedItems = React.useMemo(
        () =>
            allNodesFlat.filter((node) => selectedValues.includes(node.value)),
        [allNodesFlat, selectedValues]
    );

    const selectedCount = selectedItems.length;

    const handleToggleValue = React.useCallback(
        (item: NormalizedTreeItem) => {
            if (isDisabled) return;

            // In leafOnly mode, parents toggle expansion instead of selection
            if (leafOnly && item.hasChildren) {
                if (!item.disabled) toggleExpanded(item.value);
                return;
            }

            let nextValue: TreeValue;

            if (multiple) {
                nextValue = toggleInArray(selectedValues, item.value);
            } else {
                nextValue = item.value;
                setOpen(false);
            }

            const nextSelectedValues = Array.isArray(nextValue)
                ? nextValue
                : nextValue !== undefined && nextValue !== null
                  ? [nextValue]
                  : [];

            const detail: ChangeDetail = {
                source: "variant",
                raw: item.raw,
                nativeEvent: undefined,
                meta: {
                    toggled: item.value,
                    selectedValues: nextSelectedValues,
                },
            };

            onValue?.(nextValue, detail);
        },
        [
            isDisabled,
            leafOnly,
            multiple,
            selectedValues,
            onValue,
            toggleExpanded,
        ]
    );

    const handleClear = React.useCallback(() => {
        if (!onValue) return;
        const detail: ChangeDetail = {
            source: "variant",
            raw: undefined,
            nativeEvent: undefined,
            meta: { action: "clear" },
        };
        onValue(undefined, detail);
    }, [onValue]);

    const resolvedLeadingIcons =
        leadingIcons && leadingIcons.length ? leadingIcons : icon ? [icon] : [];
    const resolvedTrailingIcons = trailingIcons ?? [];
    const baseIconGap = iconGap ?? 4;
    const leadingGap = leadingIconSpacing ?? baseIconGap;
    const trailingGap = trailingIconSpacing ?? baseIconGap;

    const hasLeadingControl = !!leadingControl;
    const hasTrailingControl = !!trailingControl;
    const hasControls = hasLeadingControl || hasTrailingControl;

    const showClear =
        mode === "default" &&
        clearable &&
        !isDisabled &&
        selectedValues.length > 0;

    // ─────────────────────────────────────────────
    // Trigger rendering
    // ─────────────────────────────────────────────

    const renderDefaultTriggerContent = () => {
        if (!selectedItems.length) {
            return (
                <span className="text-muted-foreground">
                    {placeholder ?? "Select..."}
                </span>
            );
        }

        if (!multiple && selectedItems.length === 1) {
            return (
                <span className="text-foreground">
                    {selectedItems[0].labelNode}
                </span>
            );
        }

        if (selectedItems.length <= 3) {
            return (
                <div className="flex flex-wrap gap-1">
                    {selectedItems.map((item) => (
                        <Badge
                            key={item.key}
                            variant="secondary"
                            className="px-1.5 h-5 text-[10px] font-medium border-border/50 bg-secondary/50"
                        >
                            {item.labelNode}
                        </Badge>
                    ))}
                </div>
            );
        }

        return (
            <div className="flex items-center gap-1">
                <Badge
                    variant="secondary"
                    className="px-1.5 h-5 text-[10px] bg-secondary/50"
                >
                    {selectedItems.length} selected
                </Badge>
            </div>
        );
    };

    const triggerContent = renderValue
        ? renderValue({ selectedItems, placeholder })
        : renderDefaultTriggerContent();

    const baseBoxClasses = cn(
        "flex items-center justify-between border-input w-full min-w-0 rounded-md border bg-background text-sm shadow-xs ring-offset-background",
        "placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
        "disabled:cursor-not-allowed disabled:opacity-50",
        "aria-invalid:border-destructive",
        d.triggerPy
    );

    const DefaultTriggerButton = (
        <button
            ref={ref}
            type="button"
            disabled={isDisabled}
            className={cn(
                triggerHeight(size as Size),
                hasControls && extendBoxToControls
                    ? "border-none shadow-none focus:outline-none bg-transparent w-full text-left"
                    : baseBoxClasses,
                triggerClassName
            )}
        >
            <div className="flex w-full items-center justify-between gap-2 overflow-hidden">
                <div className="flex flex-1 items-center gap-2 overflow-hidden">
                    {resolvedLeadingIcons.length > 0 && (
                        <span
                            className="flex items-center shrink-0"
                            style={{ columnGap: leadingGap }}
                        >
                            {resolvedLeadingIcons.map((node, idx) => (
                                <span key={idx}>{node}</span>
                            ))}
                        </span>
                    )}
                    <div className="truncate w-full text-left">
                        {triggerContent}
                    </div>
                </div>

                <div className="flex items-center gap-1.5 shrink-0">
                    {showClear && (
                        <button
                            type="button"
                            onClick={(e) => {
                                e.stopPropagation();
                                handleClear();
                            }}
                            className="text-muted-foreground hover:text-foreground p-0.5 rounded-sm hover:bg-muted transition-colors"
                            aria-label="Clear selection"
                        >
                            <X className="h-3.5 w-3.5" />
                        </button>
                    )}

                    {resolvedTrailingIcons.length > 0 && (
                        <span
                            className="flex items-center"
                            style={{ columnGap: trailingGap }}
                        >
                            {resolvedTrailingIcons.map((node, idx) => (
                                <span key={idx}>{node}</span>
                            ))}
                        </span>
                    )}

                    <ChevronDown className="h-4 w-4 opacity-50" />
                </div>
            </div>
        </button>
    );

    const ButtonModeTrigger = React.useMemo(() => {
        if (mode !== "button") return null;

        const ctx = { open, selectedItems, selectedCount };
        const triggerNode =
            typeof button === "function"
                ? button(ctx)
                : (button ??
                  (typeof children === "function" ? children(ctx) : children));

        const shouldShowBadge =
            Boolean(selectedBadge) &&
            (!selectedBadgeHiddenWhenZero || selectedCount > 0);

        const badgeEl = shouldShowBadge ? (
            <Badge
                variant={selectedBadgeVariant as any}
                className={cn(
                    "text-[10px] h-5 px-1.5 leading-none",
                    selectedBadgePlacement === "corner" &&
                        "absolute -top-2 -right-2",
                    selectedBadgeClassName
                )}
            >
                {selectedCount}
            </Badge>
        ) : null;

        const wrapWithBadge = (inner: React.ReactNode) => {
            if (!badgeEl) return inner;
            if (selectedBadgePlacement === "end") {
                return (
                    <span className="inline-flex items-center gap-2">
                        <span className="min-w-0">{inner}</span>
                        {badgeEl}
                    </span>
                );
            }
            return (
                <span className="relative inline-flex">
                    {inner}
                    {badgeEl}
                </span>
            );
        };

        // If user gave us a real element, use it directly (PopoverTrigger will clone props)
        if (React.isValidElement(triggerNode)) {
            return wrapWithBadge(triggerNode);
        }

        // Fallback: wrap text/anything in a plain button
        return wrapWithBadge(
            <button
                type="button"
                disabled={isDisabled}
                className={cn(triggerClassName)}
            >
                {triggerNode ?? <span>Select…</span>}
            </button>
        );
    }, [
        mode,
        open,
        button,
        children,
        selectedItems,
        selectedCount,
        selectedBadge,
        selectedBadgeHiddenWhenZero,
        selectedBadgeVariant,
        selectedBadgeClassName,
        selectedBadgePlacement,
        isDisabled,
        triggerClassName,
    ]);

    const TriggerNode =
        mode === "button" ? ButtonModeTrigger : DefaultTriggerButton;

    // ─────────────────────────────────────────────
    // Tree Body
    // ─────────────────────────────────────────────

    const TreeBody = (
        <div className="max-h-80 w-full overflow-y-auto overflow-x-hidden py-1">
            {emptyLabel && tree.length === 0 && !query && (
                <div className="px-4 py-3 text-sm text-center text-muted-foreground">
                    {emptyLabel}
                </div>
            )}

            {tree.length > 0 && displayedNodes.length === 0 && (
                <div className="px-4 py-3 text-sm text-center text-muted-foreground">
                    {emptySearchText ?? "No results found"}
                </div>
            )}

            {displayedNodes.map((item, index) => {
                const selected = selectedValues.includes(item.value);
                const isExpanded = expanded.has(item.value);
                const parentInLeafOnly = leafOnly && item.hasChildren;

                const optionNode = (
                    <div
                        className={cn(
                            "relative flex items-center px-2 text-sm outline-none select-none",
                            d.rowGap,
                            d.rowPy,
                            item.disabled
                                ? "opacity-50"
                                : "hover:bg-accent hover:text-accent-foreground cursor-pointer",
                            selected && !multiple && "bg-accent",
                            selected && multiple && "bg-accent/50"
                        )}
                        style={{ paddingLeft: 12 + item.level * 20 }}
                        onClick={(e) => {
                            e.preventDefault();
                            if (!item.disabled) handleToggleValue(item);
                        }}
                    >
                        {/* Guidelines */}
                        {item.level > 0 &&
                            Array.from({ length: item.level }).map((_, i) => (
                                <div
                                    key={i}
                                    className="absolute border-l border-border/40 h-full top-0"
                                    style={{ left: 19 + i * 20 }}
                                />
                            ))}

                        {/* Expander */}
                        <button
                            type="button"
                            disabled={!!item.disabled || !item.hasChildren}
                            onClick={(e) => {
                                e.stopPropagation();
                                if (item.disabled) return;
                                toggleExpanded(item.value);
                            }}
                            className={cn(
                                "z-10 flex h-5 w-5 shrink-0 items-center justify-center rounded-sm text-muted-foreground hover:bg-muted hover:text-foreground transition-colors",
                                !item.hasChildren &&
                                    "opacity-0 pointer-events-none"
                            )}
                            aria-label={isExpanded ? "Collapse" : "Expand"}
                        >
                            {isExpanded ? (
                                <ChevronDown className="h-3.5 w-3.5" />
                            ) : (
                                <ChevronRight className="h-3.5 w-3.5" />
                            )}
                        </button>

                        {/* Checkbox (Multi Only, hide for parent nodes in leafOnly mode) */}
                        {multiple && !parentInLeafOnly && (
                            <Checkbox
                                checked={selected}
                                className="shrink-0 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground"
                                style={{ pointerEvents: "none" }}
                            />
                        )}

                        {/* Icon */}
                        {item.icon ? (
                            <span className="text-muted-foreground">
                                {item.icon}
                            </span>
                        ) : item.hasChildren ? (
                            isExpanded ? (
                                <FolderOpen className="h-4 w-4 text-blue-400/80 fill-blue-400/20" />
                            ) : (
                                <Folder className="h-4 w-4 text-blue-400/80 fill-blue-400/20" />
                            )
                        ) : (
                            <File className="h-4 w-4 text-muted-foreground/60" />
                        )}

                        {/* Label */}
                        <div className="flex flex-col min-w-0 flex-1">
                            <span className="truncate font-medium leading-none">
                                {item.labelNode}
                            </span>
                            {item.description && (
                                <span className="text-xs text-muted-foreground truncate mt-0.5">
                                    {item.description}
                                </span>
                            )}
                        </div>

                        {/* Checkmark (Single Only) */}
                        {!multiple && selected && (
                            <Check className="h-4 w-4 text-primary ml-auto" />
                        )}
                    </div>
                );

                // Prefer per-option renderer (normalized) if present; fall back to global renderOption
                const renderer = (item as any).render ?? renderOption;

                if (!renderer) {
                    return (
                        <React.Fragment key={item.key}>
                            {optionNode}
                        </React.Fragment>
                    );
                }

                const rendered = renderer({
                    item,
                    selected,
                    index,
                    option: optionNode,
                    click() {
                        if (!item.disabled) handleToggleValue(item);
                    },
                });

                return (
                    <React.Fragment key={item.key}>{rendered}</React.Fragment>
                );
            })}
        </div>
    );

    const SelectBody = (
        <Popover
            open={open}
            onOpenChange={(next) => {
                setOpen(next);
                if (!next) setQuery("");
            }}
            modal={true}
        >
            <PopoverTrigger asChild>{TriggerNode as any}</PopoverTrigger>

            <PopoverContent
                className={cn(
                    "p-0 w-(--radix-popover-trigger-width) min-w-75",
                    contentClassName
                )}
                align="start"
            >
                {searchable && (
                    <div
                        className={cn(
                            "flex items-center border-b px-3",
                            d.searchPy
                        )}
                    >
                        <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
                        <input
                            autoFocus
                            className="flex h-4 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50"
                            value={query}
                            onChange={(e) => setQuery(e.target.value)}
                            placeholder={searchPlaceholder ?? "Search..."}
                        />
                    </div>
                )}
                {TreeBody}
            </PopoverContent>
        </Popover>
    );

    if (!hasControls) {
        return (
            <div
                data-slot="tree-select-field"
                className={cn("w-full", className)}
            >
                {SelectBody}
            </div>
        );
    }

    if (joinControls) {
        return (
            <div
                data-slot="tree-select-field"
                className={cn("w-full", className)}
            >
                <div
                    className={cn(
                        "flex items-center w-full rounded-md border border-input bg-background shadow-xs focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2 ring-offset-background",
                        isDisabled && "opacity-50 cursor-not-allowed bg-muted"
                    )}
                >
                    {hasLeadingControl && (
                        <div
                            className={cn(
                                "pl-3 pr-1 text-muted-foreground",
                                leadingControlClassName
                            )}
                        >
                            {leadingControl}
                        </div>
                    )}
                    <div className="flex-1 min-w-0">{SelectBody}</div>
                    {hasTrailingControl && (
                        <div
                            className={cn(
                                "pr-3 pl-1 text-muted-foreground",
                                trailingControlClassName
                            )}
                        >
                            {trailingControl}
                        </div>
                    )}
                </div>
            </div>
        );
    }

    return (
        <div className={cn("flex items-center gap-2 w-full", className)}>
            {hasLeadingControl && leadingControl}
            <div className="flex-1 min-w-0">{SelectBody}</div>
            {hasTrailingControl && trailingControl}
        </div>
    );
});

ShadcnTreeSelectVariant.displayName = "ShadcnTreeSelectVariant";

export default ShadcnTreeSelectVariant;
```

---
#### 35


` File: packages/form-palette/src/variants/core/checkbox.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/checkbox.ts

import type { VariantModuleFor } from "@/schema/variant";
import { ShadcnCheckboxVariant } from "@/presets/shadcn-variants/checkbox";
import type {
   ShadcnCheckboxVariantPublicProps,
   CheckboxVariantPublicValue,
} from "@/presets/shadcn-variants/checkbox";
import type { VariantBaseProps } from "@/variants/shared";
import { toggleLayoutDefaults } from "./toggle";

/**
 * Public props type you can import elsewhere:
 *
 *   import type { CheckboxVariantProps } from "@/variants/core/checkbox";
 */
export type CheckboxVariantProps = ShadcnCheckboxVariantPublicProps;

/**
 * Concrete Variant component type, if you need it:
 *
 *   VariantBaseProps<CheckboxVariantPublicValue> & CheckboxVariantProps
 */
type CheckboxVariantComponentProps =
   VariantBaseProps<CheckboxVariantPublicValue> & CheckboxVariantProps;

/**
 * Runtime module for the "checkbox" variant.
 *
 * This wires the Shadcn preset into the core registry with sensible defaults.
 */
export const checkboxModule: VariantModuleFor<"checkbox"> = {
   variant: "checkbox",

   // ShadcnCheckboxVariant is generic; we fix it to the public aliases
   // via this cast. At call sites you'll still get strong typing because
   // the registry types know the concrete value/props.
   Variant: ShadcnCheckboxVariant as unknown as React.ComponentType<CheckboxVariantComponentProps>,

   resolveLayout({ props }) {
      if (props.single) {
         return toggleLayoutDefaults
      }

      return {};
   },

   meta: {
      label: "Checkbox",
      description:
         "Single or group checkboxes with optional per-item tri-state support.",
      tags: ["checkbox", "group", "boolean", "tri-state"],
   },
};
```

---
#### 36


` File: packages/form-palette/src/variants/core/chips.tsx`  [↑ Back to top](#index)

```tsx
import ShadcnChipsVariant from "@/presets/shadcn-variants/chips";
import { VariantModuleFor } from "@/schema/variant";


export const chipVariant: VariantModuleFor<"chips"> = {
   variant: "chips",
   Variant: ShadcnChipsVariant as any,
   // Optional layout defaults – tweak as you like
   defaults: {
      layout: {
         fullWidth: true,
         // You can set defaultSize/defaultDensity here if you want:
         // defaultSize: "md",
         // defaultDensity: "normal",
      },
   },
   meta: {
      label: "Chips",
      description: "Chips input allowing multiple selections.",
      tags: ["chips", "multi-select", "tags"],
   },
}
```

---
#### 37


` File: packages/form-palette/src/variants/core/color.tsx`  [↑ Back to top](#index)

```tsx
// ———————————————————————————————
// VariantModule wiring

import { ShadcnColorVariant } from "@/presets/shadcn-variants/color";
import { VariantModule } from "@/schema/variant";

// ———————————————————————————————
export const ColorVariantModule: VariantModule<"color"> = {
   variant: "color",
   Variant: ShadcnColorVariant,
   meta: {
      label: "Phone",
      description: "Phone number input with country code and masking.",
      tags: ["phone", "tel", "contact"],
   },
};
```

---
#### 38


` File: packages/form-palette/src/variants/core/custom.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/custom.tsx

import type { VariantModule } from "@/schema/variant";
import { ShadcnCustomVariant } from "@/presets/shadcn-variants/custom";

/**
 * Core "custom" variant module.
 *
 * - Delegates all UI to ShadcnCustomVariant.
 * - No layout defaults, no built-in validation.
 * - Consumers can override layout via InputField props if needed.
 */
export const customVariant: VariantModule<"custom"> = {
   variant: "custom",
   Variant: ShadcnCustomVariant,
};

export default customVariant;
```

---
#### 39


` File: packages/form-palette/src/variants/core/date.tsx`  [↑ Back to top](#index)

```tsx
import ShadcnDateVariant from "@/presets/shadcn-variants/date";
import { VariantModuleFor } from "@/schema/variant";


export const dateVariant: VariantModuleFor<"date"> = {
   variant: "date",
   Variant: ShadcnDateVariant as any,

   // Optional layout defaults – tweak as you like
   defaults: {
      layout: {
         fullWidth: true,
         // You can set defaultSize/defaultDensity here if you want:
         // defaultSize: "md",
         // defaultDensity: "normal",
      },
   },

   meta: {
      label: "Date",
      description:
         "Date input with calendar picker.",
      tags: ["date", "calendar", "picker"],
   },
}
```

---
#### 40


` File: packages/form-palette/src/variants/core/editor.ts`  [↑ Back to top](#index)

```ts
import { VariantModule } from "@/schema/variant";
import { ShadcnEditorVariant } from "@/presets/shadcn-variants/editor";

export const shadcnEditorVariant: VariantModule<"editor"> = {
    variant: "editor",
    Variant: ShadcnEditorVariant,
    meta: {
        label: "Editor",
        description: "Toast UI Editor (vanilla @toast-ui/editor).",
        tags: ["editor", "rich-text", "markdown", "toast-ui"],
    },
};
```

---
#### 41


` File: packages/form-palette/src/variants/core/file.tsx`  [↑ Back to top](#index)

```tsx
import ShadcnFileVariant from "@/presets/shadcn-variants/file";
import { VariantModule } from "@/schema/variant";



export const fileManagerModule: VariantModule<'file'> = {
   Variant: ShadcnFileVariant as any,
   variant: 'file'
}
```

---
#### 42


` File: packages/form-palette/src/variants/core/json-editor.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/json-editor.tsx

import type { VariantModule } from "@/schema/variant";
import ShadcnJsonEditorVariant from "@/presets/shadcn-variants/json-editor";
import type { ShadcnJsonEditorProps } from "@/presets/shadcn-variants/json-editor/types";
import Ajv from "ajv";

const ajv = new Ajv({
    allErrors: true,
    strict: false,
});

/**
 * Core JSON Editor variant module.
 */
export const jsonEditorVariant: VariantModule<"json-editor"> = {
    variant: "json-editor",

    // Visual component: Shadcn-based JSON editor
    Variant: ShadcnJsonEditorVariant as any,

    // Validation logic
    validate(value, { props }) {
        const { schema } = props;
        let resolvedSchema = schema;

        // If schema is a string, try to parse it as JSON
        if (typeof schema === "string") {
            try {
                resolvedSchema = JSON.parse(schema);
            } catch (e) {
                // If it's not valid JSON, we can't use it for validation
                // It might be a schema ID/name, so we skip AJV validation here
                resolvedSchema = null;
            }
        }

        // Only try a validation if the schema property is provided (as an object)
        if (resolvedSchema && typeof resolvedSchema === "object") {
            try {
                const validate = ajv.compile(resolvedSchema);
                const valid = validate(value);

                if (!valid) {
                    // Return the first error message or a generic one
                    const error = validate.errors?.[0];
                    return error ? `${error.instancePath} ${error.message}`.trim() : "Invalid JSON structure";
                }
            } catch (e) {
                // Compilation error (e.g. invalid schema format)
                return `Schema Error: ${e instanceof Error ? e.message : String(e)}`;
            }
        }

        return true;
    },

    // Layout defaults for this variant
    defaults: {
        layout: {
            labelPlacement: "top",
            sublabelPlacement: "right",
            descriptionPlacement: "below",
            helpTextPlacement: "below",
            errorTextPlacement: "below",
            inline: false,
            fullWidth: true,
            defaultSize: "md",
            defaultDensity: "comfortable",
        },
    },

    meta: {
        label: "JSON Editor",
        description: "Advanced JSON editor with visual and raw modes",
        tags: ["json", "editor", "object", "array"],
    },
};

export default jsonEditorVariant;
```

---
#### 43


` File: packages/form-palette/src/variants/core/keyvalue.tsx`  [↑ Back to top](#index)

```tsx
import ShadcnKeyValueVariant from "@/presets/shadcn-variants/keyvalue";
import { VariantModule } from "@/schema/variant";


export const keyValueModule: VariantModule<'keyvalue'> = {
   variant: 'keyvalue',
   Variant: ShadcnKeyValueVariant,

   meta: {
      label: ''
   }
}
```

---
#### 44


` File: packages/form-palette/src/variants/core/lister.tsx`  [↑ Back to top](#index)

```tsx
import { VariantModule } from "@/schema/variant";
import ShadcnListerVariant from "@/presets/shadcn-variants/lister";

const module: VariantModule<"lister"> = {
    variant: "lister",
    Variant: ShadcnListerVariant,

    // Layout defaults for this variant
    defaults: {
        layout: {
            labelPlacement: "top",
            sublabelPlacement: "right",
            descriptionPlacement: "below",
            helpTextPlacement: "below",
            errorTextPlacement: "below",
            inline: false,
            fullWidth: true,
            defaultSize: "md",
            defaultDensity: "comfortable",
        },
    },

    meta: {
        label: "Lister",
        description:
            "Select/multi-select powered by the Lister runtime (popover body only).",
        tags: ["select", "multiselect", "popover", "lister"],
    },
};

export default module;
```

---
#### 45


` File: packages/form-palette/src/variants/core/multiselect.tsx`  [↑ Back to top](#index)

```tsx


// src/variants/multi-select.ts

import type { VariantModule } from "@/schema/variant";
import {
   ShadcnMultiSelectVariant,
   type ShadcnMultiSelectVariantProps,
} from "@/presets/shadcn-variants/multiselect";

export type MultiSelectValue = (string | number)[] | undefined;


/**
 * Variant module for "multi-select".
 *
 * No defaults / layout overrides here — layout is driven by InputField +
 * host overrides, same as your other variants.
 */
export const multiSelectVariantModule: VariantModule<"multi-select"> = {
   variant: "multi-select",
   Variant: ShadcnMultiSelectVariant,
   meta: {
      
   }
};

export default multiSelectVariantModule;
```

---
#### 46


` File: packages/form-palette/src/variants/core/number.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/text.tsx

import * as React from "react";

import type { Dict } from "@/schema/core";
import type { VariantModule } from "@/schema/variant";
import type { ValidateResult } from "@/schema/input-field";
import { ShadcnTextVariant } from "@/presets/shadcn-variants/text";
import type { ShadcnTextUiProps } from "@/presets/shadcn-variants/text";
import { ShadcnNumberVariant, ShadcnNumberVariantProps } from "@/presets/shadcn-variants/number";

/**
 * Text variant props (core layer).
 *
 * - Extends Dict so it can cleanly participate in the Variants registry.
 * - Extends the Shadcn UI props so the core variant can pass everything
 *   straight through to the underlying visual component.
 *
 * This is where we hang *semantic* flags that drive validation.
 */
export interface TextVariantProps extends Dict, ShadcnTextUiProps {
   /**
    * If true, the value will be trimmed before validation.
    * (Visual value is still whatever the user types; this is just for
    * validation semantics.)
    */
   trim?: boolean;

   /**
    * Minimum allowed string length (after optional trimming).
    */
   minLength?: number;

   /**
    * Maximum allowed string length (after optional trimming).
    */
   maxLength?: number;
}

/**
 * Simple validation helper for the text variant.
 */
function validateText(
   value: number | undefined,
   ctx: {
      required?: boolean;
      props: ShadcnNumberVariantProps;
   }
): ValidateResult {
   const { required, props } = ctx;
   const { minLength, maxLength } = props;

   const raw = (value ?? "") + "";
   const v = raw.trim();

   // required
   if (required && v.length === 0) {
      return "This field is required.";
   }

   // minLength
   if (typeof minLength === "number" && v.length > 0 && v.length < minLength) {
      return `Please enter at least ${minLength} characters.`;
   }

   // maxLength
   if (typeof maxLength === "number" && v.length > maxLength) {
      return `Please enter no more than ${maxLength} characters.`;
   }

   return true;
}

/**
 * Core text variant module.
 *
 * - Uses ShadcnTextVariant as the visual component.
 * - Adds simple length-based validation.
 * - Provides layout defaults for InputField to use.
 */
export const numberVariant: VariantModule<"number"> = {
   variant: "number",

   // Visual component: Shadcn-based text input
   Variant: ShadcnNumberVariant as any,

   // Validation logic (runs before/alongside per-field onValidate)
   validate(value, { required, props, field, form }) {
      // field + form are available if you need them later.
      return validateText(value, { required, props });
   },

   // Layout defaults for this variant
   defaults: {
      layout: {
         labelPlacement: "top",
         sublabelPlacement: "right",
         descriptionPlacement: "below",
         helpTextPlacement: "below",
         errorTextPlacement: "below",
         inline: false,
         fullWidth: true,
         defaultSize: "md",
         defaultDensity: "comfortable",
      },
   },

   meta: {
      label: "Number",
      description: "Single-line number input",
      tags: ["number", "input", "integer", "float"],
   },
};

export default numberVariant;
```

---
#### 47


` File: packages/form-palette/src/variants/core/password.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/password.tsx

import type { VariantModuleFor } from "@/schema/variant";
import { ShadcnPasswordVariant } from "@/presets/shadcn-variants/password";

/**
 * Core module for the "password" variant.
 *
 * - Uses the ShadcnPasswordVariant UI (Input + reveal toggle + strength meter).
 * - Value type is string | undefined (from Variants["password"].value).
 * - Props are ShadcnPasswordVariantProps (from Variants["password"].props).
 */
export const passwordVariant: VariantModuleFor<"password"> = {
   variant: "password",
   Variant: ShadcnPasswordVariant,

   // Optional layout defaults – tweak as you like
   defaults: {
      layout: {
         fullWidth: true,
         // You can set defaultSize/defaultDensity here if you want:
         // defaultSize: "md",
         // defaultDensity: "normal",
      },
   },

   meta: {
      label: "Password",
      description:
         "Password input with reveal toggle and optional strength meter.",
      tags: ["auth", "security", "password"],
   },
};

export default passwordVariant;
```

---
#### 48


` File: packages/form-palette/src/variants/core/phone.tsx`  [↑ Back to top](#index)

```tsx
// ———————————————————————————————
// VariantModule wiring

import { ShadcnPhoneVariant } from "@/presets/shadcn-variants/phone";
import { VariantModule } from "@/schema/variant";

// ———————————————————————————————
export const PhoneVariantModule: VariantModule<"phone"> = {
   variant: "phone",
   Variant: ShadcnPhoneVariant,
   meta: {
      label: "Phone",
      description: "Phone number input with country code and masking.",
      tags: ["phone", "tel", "contact"],
   },
};
```

---
#### 49


` File: packages/form-palette/src/variants/core/radio.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/radio.ts

import type { VariantModuleFor } from "@/schema/variant";
import { ShadcnRadioVariant } from "@/presets/shadcn-variants/radio";

/**
 * Built-in "radio" variant module.
 *
 * Uses the Shadcn-based implementation in presets/shadcn-variants/radio.tsx
 */
export const radioVariantModule: VariantModuleFor<"radio"> = {
   variant: "radio",
   // Note: registry-level typing uses unknown, but the component itself is generic.
   Variant: ShadcnRadioVariant as any,
   defaults: {
      layout: {
         // Standard stacked field layout; the smart renderer still
         // handles ordering/relative roots for helpers.
         labelPlacement: "top",
         sublabelPlacement: "right",
         descriptionPlacement: "below",
         helpTextPlacement: "below",
         errorTextPlacement: "below",
         inline: false,
         fullWidth: true,

         // Explicit layout hints
         defaultSize: "md",
         defaultDensity: "comfortable", // ← uses your FieldDensity union
      },
   },
   meta: {
      label: "Radio group",
      description:
         "Choose one option from a list of mutually exclusive choices.",
      tags: ["choice", "select", "exclusive", "radio"],
   },
};
```

---
#### 50


` File: packages/form-palette/src/variants/core/select.tsx`  [↑ Back to top](#index)

```tsx
import ShadcnSelectVariant, { ShadcnSelectVariantProps } from "@/presets/shadcn-variants/select";
import { VariantModuleFor } from "@/schema/variant";

export type SelectVariantProps = ShadcnSelectVariantProps;

export const selectModule: VariantModuleFor<"select"> = {
   variant: "select",
   Variant: ShadcnSelectVariant,

   meta: {
      label: "Select",
      description: "Single-value dropdown based on Shadcn Select.",
      tags: ["select", "dropdown", "single-value"],
   },
};
```

---
#### 51


` File: packages/form-palette/src/variants/core/slider.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/slider.ts

import type { ValidateResult } from "@/schema/input-field";
import type { ShadcnSliderVariantProps } from "@/presets/shadcn-variants/slider";
import { ShadcnSliderVariant } from "@/presets/shadcn-variants/slider";
import { VariantModule } from "@/schema/variant";

/**
 * Slider value type:
 * - `number | undefined` for now (single-value slider).
 *   If/when you add range support, this can be widened to [number, number].
 */
export type SliderValue = number | undefined;


/**
 * Basic validation:
 * - if required → must have a numeric value
 * - otherwise always OK
 */
function validateSlider(
   value: SliderValue,
   ctx: { required?: boolean }
): ValidateResult {
   if (ctx.required) {
      if (value === undefined || value === null) {
         return "Required.";
      }
      if (typeof value !== "number" || Number.isNaN(value)) {
         return "Invalid number.";
      }
   }

   // You could optionally enforce min/max here using ctx.props
   return true;
}

/**
 * Register the slider variant with the global registry.
 *
 * No layout defaults are provided here:
 * - layout (inline vs stacked, label placement, etc.) is controlled by
 *   the host via FieldLayoutConfig / InputField overrides instead.
 */
export default {
   variant: "slider",
   Variant: ShadcnSliderVariant,
   validate(value, ctx): ValidateResult {
      return validateSlider(value as SliderValue, {
         required: ctx.required,
      });
   },
} as VariantModule<'slider'>;

export type SliderVariantProps = ShadcnSliderVariantProps;
```

---
#### 52


` File: packages/form-palette/src/variants/core/text.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/text.tsx

import * as React from "react";

import type { Dict } from "@/schema/core";
import type { VariantModule } from "@/schema/variant";
import type { ValidateResult } from "@/schema/input-field";
import { ShadcnTextVariant } from "@/presets/shadcn-variants/text";
import type { ShadcnTextUiProps, ShadcnTextVariantProps } from "@/presets/shadcn-variants/text";

/**
 * Text variant props (core layer).
 *
 * - Extends Dict so it can cleanly participate in the Variants registry.
 * - Extends the Shadcn UI props so the core variant can pass everything
 *   straight through to the underlying visual component.
 *
 * This is where we hang *semantic* flags that drive validation.
 */
export interface TextVariantProps extends Dict, ShadcnTextUiProps {
    /**
     * If true, the value will be trimmed before validation.
     * (Visual value is still whatever the user types; this is just for
     * validation semantics.)
     */
    trim?: boolean;

    /**
     * Minimum allowed string length (after optional trimming).
     */
    minLength?: number;

    /**
     * Maximum allowed string length (after optional trimming).
     */
    maxLength?: number;
}

/**
 * Simple validation helper for the text variant.
 */
function validateText(
    value: string | undefined,
    ctx: {
        required?: boolean;
        props: ShadcnTextVariantProps & TextVariantProps;
    }
): ValidateResult {
    const { required, props } = ctx;
    const { trim, minLength, maxLength } = props;

    const raw = value ?? "";
    const v = trim ? raw.trim() : raw;

    // required
    if (required && v.length === 0) {
        return "This field is required.";
    }

    // minLength
    if (typeof minLength === "number" && v.length > 0 && v.length < minLength) {
        return `Please enter at least ${minLength} characters.`;
    }

    // maxLength
    if (typeof maxLength === "number" && v.length > maxLength) {
        return `Please enter no more than ${maxLength} characters.`;
    }

    return true;
}

/**
 * Core text variant module.
 *
 * - Uses ShadcnTextVariant as the visual component.
 * - Adds simple length-based validation.
 * - Provides layout defaults for InputField to use.
 */
export const textVariant: VariantModule<"text"> = {
    variant: "text",

    // Visual component: Shadcn-based text input
    Variant: ShadcnTextVariant,

    // Validation logic (runs before/alongside per-field onValidate)
    validate(value, { required, props, field, form }) {
        //@ts-ignore field + form are available if you need them later.
        return validateText(value, { required, props });
    },

    // Layout defaults for this variant
    defaults: {
        layout: {
            labelPlacement: "top",
            sublabelPlacement: "right",
            descriptionPlacement: "below",
            helpTextPlacement: "below",
            errorTextPlacement: "below",
            inline: false,
            fullWidth: true,
            defaultSize: "md",
            defaultDensity: "comfortable",
        },
    },

    meta: {
        label: "Text",
        description: "Single-line text input",
        tags: ["text", "input", "string"],
    },
};

export default textVariant;
```

---
#### 53


` File: packages/form-palette/src/variants/core/textarea.tsx`  [↑ Back to top](#index)

```tsx
import ShadcnTextareaVariant from "@/presets/shadcn-variants/textarea";
import { VariantModuleFor } from "@/schema/variant";


export const textareaVariant: VariantModuleFor<"textarea"> = {
   variant: "textarea",
   Variant: ShadcnTextareaVariant as any,
   // Optional layout defaults – tweak as you like
   defaults: {
      layout: {
         fullWidth: true,
         // You can set defaultSize/defaultDensity here if you want:
         // defaultSize: "md",
         // defaultDensity: "normal",
      },
   },
   meta: {
      label: "Textarea",
      description: "Multi-line text input area.",
      tags: ["text", "multiline", "comments", "notes"],
   },
}
```

---
#### 54


` File: packages/form-palette/src/variants/core/toggle-group.tsx`  [↑ Back to top](#index)

```tsx
// ———————————————————————————————
// VariantModule wiring

import { ShadcnToggleVariant } from "@/presets/shadcn-variants/toggle-group";
import { VariantModule } from "@/schema/variant";

// ———————————————————————————————
export const toggleGroupModule: VariantModule<"toggle-group"> = {
   variant: "toggle-group",
   Variant: ShadcnToggleVariant,
   meta: {
      label: "Toggle group",
      description: "Toggle group component buttons.",
      tags: ["buttons", "toggle"],
   },
};
```

---
#### 55


` File: packages/form-palette/src/variants/core/toggle.tsx`  [↑ Back to top](#index)

```tsx
// src/variants/core/toggle.ts

import type { VariantModuleFor } from "@/schema/variant";
import type { FieldLayoutConfig } from "@/schema/input-field";
import ShadcnToggleVariant from "@/presets/shadcn-variants/toggle";

export const toggleLayoutDefaults: FieldLayoutConfig = {
   // Render label + control in a single row
   inline: true,

   // Semantically: label is to the "right" of the control for this variant.
   // (Your InputField can use this to decide macro-level positioning.)
   labelPlacement: "right",

   // Attach all helpers to the label root by default.
   // Sublabel will still use its own placement (default: "right"),
   // but it's logically anchored to the label block.
   relativeRoots: {
      sublabel: "label",
      description: "label",
      helpText: "label",
      errorText: "label",
   },

   fullWidth: false,

   // Within the label root, show error first, then description, then help,
   // then sublabel (all still respecting their individual placements).
   ordering: {
      label: ["errorText", "description", "helpText", "sublabel"],
      // For this variant we don't really use input-root helpers,
      // but we keep the key for completeness.
      input: [],
   },
};

export const ToggleVariantModule: VariantModuleFor<"toggle"> = {
   variant: "toggle",
   Variant: ShadcnToggleVariant as any,
   defaults: {
      layout: toggleLayoutDefaults,
   },
   meta: {
      label: "Toggle",
      description: "Boolean on/off switch",
      tags: ["boolean", "toggle", "switch"],
   },
};

export default ToggleVariantModule;
```

---
#### 56


` File: packages/form-palette/src/variants/core/treeselect.tsx`  [↑ Back to top](#index)

```tsx
import ShadcnTreeSelectVariant from "@/presets/shadcn-variants/treeselect";
import { VariantModule } from "@/schema/variant";



const treeselectModule: VariantModule<'treeselect'> = {
   variant: 'treeselect',
   Variant: ShadcnTreeSelectVariant as any
}

export default treeselectModule
```


---
*Generated with [Prodex](https://github.com/emxhive/prodex) — Codebase decoded.*
<!-- PRODEx v1.4.9 | 2025-12-29T20:37:55.967Z -->